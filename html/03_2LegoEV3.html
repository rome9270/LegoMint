<!doctype html>
<html lang="de">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>EV3 · Schritt 2 – Geradeaus & zurück (mit 2D-Simulator)</title>

<style>
/* ===== Deine CSS (unverändert, mit kleinem Bugfix) ===== */
/* Basislayout */
body { font-family: Arial, sans-serif; text-align: center; padding: 60px; }
h1 { margin-bottom: 30px; }
p  { margin-bottom: 30px; }
hr  { margin: 40px 0; }

/* Startseiten-Grid (Themen-Auswahl) */
.link-grid{
  display: grid !important;
  grid-template-columns: repeat(auto-fit, minmax(260px, 1fr));
  gap: 24px;
  padding: 20px 24px;        /* ✅ Bugfix: px ergänzt */
  background: #fff;
  margin-top: 40px;
}
.link-grid > a.topic,
.link-grid > button.topic{
  display: block; width: 100%; margin: 0; text-align: center;
  padding: 18px 24px; border-radius: 24px; background: #3fb257; color: #fff; font-weight: 700;
}
.link-grid.debug > *{ outline: 2px dashed #f0f; }

.level-grid { display:flex; flex-wrap:wrap; justify-content:center; column-gap:16px; row-gap:16px; margin-top:20px; }
.level-btn{
  display: inline-block; width: 260px; padding: 18px 28px; font-size: 20px; font-weight: bold;
  color: #fff; background: #4CAF50; border-radius: 12px; text-decoration: none; text-align: center;
  transition: background-color .3s, transform .2s; cursor: pointer; border: none;
}
.level-btn:hover{ background:#45a049; transform: translateY(-3px); }

/* Mobile Feinschliff */
@media (max-width: 640px){
  body{ padding: 32px 16px; }
  .level-btn{ width: 100%; max-width: 360px; }
}

/* ===== Zusatzstyles für Karte/Editor/Ausgabe/Simulator ===== */
main { max-width: 1100px; margin: 0 auto; }
.card { background:#fff; border: 1px solid #e7e7e7; border-radius:16px; padding:18px; text-align:left; box-shadow: 0 6px 24px rgba(0,0,0,.06); }
.card h2 { margin: 0 0 10px; }
.small, .status { color:#666; font-size:14px; }
.row{ display:flex; gap:12px; align-items:center; flex-wrap:wrap; }

textarea{
  width:100%; min-height: 280px; border:1px solid #ddd; border-radius:12px; padding:14px;
  font:14px/1.45 Consolas, ui-monospace, Menlo, Monaco, "Liberation Mono", monospace;
}
pre{
  margin:0; padding:12px; min-height:140px; background:#f7f7f7; border:1px solid #e7e7e7; border-radius:12px;
  white-space: pre-wrap; word-break: break-word;
}
.result{ font-weight:700; }
.ok{ color:#2e7d32; }
.fail{ color:#c62828; }

/* Simulator-Canvas */
.sim-wrap { margin-top: 14px; }
#sim {
  width: 100%;
  height: 360px;           /* visuelle Höhe, echtes Pixelmaß setzen wir in JS */
  display: block;
  background: #fff;
  border: 1px solid #e7e7e7;
  border-radius: 12px;
}
.sim-legend { margin-top: 6px; font-size: 13px; color:#666; }
</style>
</head>

<body>
  <main>
    <h1>EV3 · Schritt 2: Geradeaus & zurück (300&nbsp;mm)</h1>
    <p>Aufgabe: Fahre <b>300&nbsp;mm vor</b> und <b>300&nbsp;mm zurück</b>.<br>
       Verwende <code>DriveBase</code> und <code>robot.straight(…)</code>. Der Simulator zeigt den Roboter als Punkt mit Pfeil.</p>

    <section class="card">
      <h2 style="margin:0 0 8px">Dein Code</h2>
      <p class="status">Tipp: <code>robot = DriveBase(Motor(Port.B), Motor(Port.C), wheel_diameter=56, axle_track=114)</code></p>

      <textarea id="code" spellcheck="false">#!/usr/bin/env pybricks-micropython
from pybricks.hubs import EV3Brick
from pybricks.ev3devices import Motor
from pybricks.parameters import Port
from pybricks.robotics import DriveBase

# Roboter konfigurieren (Werte ggf. anpassen)
left = Motor(Port.B)
right = Motor(Port.C)
robot = DriveBase(left, right, wheel_diameter=56, axle_track=114)

# Deine Lösung:
robot.straight(300)
robot.straight(-300)
</textarea>

      <div class="row" style="margin-top:10px">
        <button id="run" class="level-btn">Simulation ausführen</button>
        <button id="check" class="level-btn" style="background:#3fb257">Aufgabe prüfen</button>
        <button id="download" class="level-btn" style="background:#3fb257">Als main.py herunterladen</button>
        <button id="next" class="level-btn" disabled>Nächster Schritt ▷</button>
        <span id="status" class="status">Bereit (Schnellmodus)</span>
      </div>

      <div class="sim-wrap">
        <canvas id="sim"></canvas>
        <div class="sim-legend">Simulator: Maßstab <b>1&nbsp;px = 1&nbsp;mm</b> · Start in der Mitte · Pfeil zeigt Fahrtrichtung</div>
      </div>

      <h3>Ausgabe</h3>
      <pre id="out" aria-live="polite"></pre>
      <p class="result" id="result"></p>
    </section>
  </main>

<script>
/* ========= Web Audio: Beep, wenn im Code ev3.speaker.beep() steht ========= */
let audioCtx;
async function ensureAudio(){
  if(!audioCtx){ audioCtx = new (window.AudioContext || window.webkitAudioContext)(); }
  if(audioCtx.state === 'suspended'){ try { await audioCtx.resume(); } catch(_){} }
  return audioCtx;
}
function playBeep(duration=120, freq=880, volume=0.15){
  const ctx = audioCtx;
  const osc = ctx.createOscillator();
  const gain = ctx.createGain();
  osc.type = 'square';
  osc.frequency.value = freq;
  gain.gain.value = volume;
  osc.connect(gain); gain.connect(ctx.destination);
  const t = ctx.currentTime;
  osc.start(t); osc.stop(t + duration/1000);
}

/* ========= DOM Helpers ========= */
const codeEl = document.getElementById('code');
const outEl  = document.getElementById('out');
const resEl  = document.getElementById('result');
const nextBtn= document.getElementById('next');
const statusEl = document.getElementById('status');
function clearOut(){ outEl.textContent=''; resEl.textContent=''; resEl.className='result'; }

/* ========= 2D-Simulator (Canvas) ========= */
const canvas = document.getElementById('sim');
const ctx = canvas.getContext('2d', { alpha: false });

function setupCanvas(){
  const dpr = window.devicePixelRatio || 1;
  // CSS-Höhe aus computed style lesen
  const cssHeight = parseFloat(getComputedStyle(canvas).height);
  const cssWidth  = canvas.clientWidth;
  canvas.width  = Math.round(cssWidth * dpr);
  canvas.height = Math.round(cssHeight * dpr);
  ctx.setTransform(dpr,0,0,dpr,0,0); // damit wir in CSS-px zeichnen
}
window.addEventListener('resize', ()=>{ setupCanvas(); drawAll(); });

const STATE = {
  scale: 1,                 // 1 px = 1 mm
  x: 0, y: 0, theta: 0,     // Position (px) & Richtung (rad), theta=0 => nach rechts
  path: []                  // Liniensegmente [[x1,y1,x2,y2], ...]
};

function resetSim(){
  setupCanvas();
  // Start in der Mitte
  STATE.x = canvas.clientWidth / 2;
  STATE.y = canvas.clientHeight / 2;
  STATE.theta = 0; // nach rechts
  STATE.path = [];
  drawAll();
}

function drawGrid(){
  const w = canvas.clientWidth, h = canvas.clientHeight;
  ctx.save();
  ctx.clearRect(0,0,w,h);
  // Hintergrund
  ctx.fillStyle = '#ffffff';
  ctx.fillRect(0,0,w,h);
  // feines Raster (50 mm)
  ctx.strokeStyle = '#eee';
  ctx.lineWidth = 1;
  for(let x=0; x<=w; x+=50){ ctx.beginPath(); ctx.moveTo(x,0); ctx.lineTo(x,h); ctx.stroke(); }
  for(let y=0; y<=h; y+=50){ ctx.beginPath(); ctx.moveTo(0,y); ctx.lineTo(w,y); ctx.stroke(); }
  // Achsenkreuz
  ctx.strokeStyle = '#ddd';
  ctx.beginPath(); ctx.moveTo(0,h/2); ctx.lineTo(w,h/2); ctx.stroke();
  ctx.beginPath(); ctx.moveTo(w/2,0); ctx.lineTo(w/2,h); ctx.stroke();
  ctx.restore();
}

function drawPath(){
  ctx.save();
  ctx.strokeStyle = '#3fb257'; // dein Grün (#3fb257) für die Spur
  ctx.lineWidth = 2;
  for(const seg of STATE.path){
    const [x1,y1,x2,y2] = seg;
    ctx.beginPath(); ctx.moveTo(x1,y1); ctx.lineTo(x2,y2); ctx.stroke();
  }
  ctx.restore();
}

function drawRobot(){
  const r = 8; // Punkt-Radius
  const L = 18; // Pfeil-Länge
  const a = STATE.theta;

  const x = STATE.x, y = STATE.y;

  // Punkt
  ctx.save();
  ctx.fillStyle = '#4CAF50'; // Button-Grün
  ctx.beginPath(); ctx.arc(x, y, r, 0, Math.PI*2); ctx.fill();

  // Pfeil (kleines Dreieck in Blickrichtung)
  const tipX = x + Math.cos(a) * (r + L);
  const tipY = y - Math.sin(a) * (r + L); // minus wegen Canvas-Y
  const leftX = x + Math.cos(a + Math.PI*0.75) * r;
  const leftY = y - Math.sin(a + Math.PI*0.75) * r;
  const rightX= x + Math.cos(a - Math.PI*0.75) * r;
  const rightY= y - Math.sin(a - Math.PI*0.75) * r;

  ctx.beginPath();
  ctx.moveTo(tipX, tipY);
  ctx.lineTo(leftX, leftY);
  ctx.lineTo(rightX, rightY);
  ctx.closePath();
  ctx.fill();
  ctx.restore();
}

function drawAll(){
  drawGrid();
  drawPath();
  drawRobot();
}

function forwardMM(mm){
  const dx = Math.cos(STATE.theta) * mm * STATE.scale;
  const dy = -Math.sin(STATE.theta) * mm * STATE.scale; // minus, weil Canvas-Y nach unten wächst
  const x1 = STATE.x, y1 = STATE.y;
  STATE.x += dx; STATE.y += dy;
  STATE.path.push([x1,y1, STATE.x, STATE.y]);
  drawAll();
}
function turnDeg(deg){
  // Positive Werte: Drehung gegen den Uhrzeiger (links)
  STATE.theta += (deg * Math.PI / 180);
  drawAll();
}

/* ========= Simulation (Parser + schnelle Animation) ========= */
function runSimulatorFromCode(src){
  resetSim();
  outEl.textContent = '';
  let t = 0;

  const lines = src.split(/\n/);

  // schnelle Hilfsfunktion
  const log = (s) => { outEl.textContent += s + "\n"; };

  for(const L of lines){
    // Beep
    if(/speaker\.beep\(\)/.test(L)){
      setTimeout(()=>{ playBeep(); log('[BEEP]'); }, t);
      t += 180;
      continue;
    }
    // Wait
    if(/wait\(\s*(\d+)\s*\)/.test(L)){
      const m = L.match(/wait\(\s*(\d+)\s*\)/);
      const ms = parseInt(m[1], 10);
      log(`[WAIT ${ms}ms]`);
      t += Math.min(600, ms); // wir warten kurz, aber nicht zu lang
      continue;
    }
    // Straight
    if(/robot\.straight\(\s*(-?\d+)\s*\)/.test(L)){
      const m = L.match(/robot\.straight\(\s*(-?\d+)\s*\)/);
      const d = parseInt(m[1], 10);
      setTimeout(()=>{ forwardMM(d); log(`[STRAIGHT ${d}mm]`); }, t);
      // Animationsdauer grob: 2ms pro mm, min 200ms
      t += Math.max(200, Math.min(1200, Math.abs(d)*2));
      continue;
    }
    // Turn
    if(/robot\.turn\(\s*(-?\d+)\s*\)/.test(L)){
      const m = L.match(/robot\.turn\(\s*(-?\d+)\s*\)/);
      const a = parseInt(m[1], 10);
      setTimeout(()=>{ turnDeg(a); log(`[TURN ${a}°]`); }, t);
      t += 250;
      continue;
    }
  }
}

/* ========= Checker (wie zuvor) ========= */
function checkTask(){
  const code = codeEl.value;
  const hasDriveBase = /DriveBase\s*\(/.test(code);

  const numRe = /robot\.straight\(\s*(-?\d+)\s*\)/g;
  let m, values = [];
  while((m = numRe.exec(code)) !== null){ values.push(parseInt(m[1],10)); }
  const pos300 = values.some(v => v >= 280 && v <= 320);
  const neg300 = values.some(v => v <= -280 && v >= -320);

  const ok = hasDriveBase && pos300 && neg300;

  if(ok){
    resEl.textContent = '✔︎ Aufgabe erfüllt – 300 mm vor und zurück erkannt.';
    resEl.className = 'result ok';
    nextBtn.disabled = false;
  }else{
    let msg = [];
    if(!hasDriveBase) msg.push('DriveBase fehlt');
    if(!pos300) msg.push('vorwärts 300 mm fehlt');
    if(!neg300) msg.push('rückwärts -300 mm fehlt');
    resEl.textContent = 'Noch nicht ganz: ' + msg.join(', ') + '.';
    resEl.className = 'result fail';
    nextBtn.disabled = true;
  }
}

/* ========= Download als main.py ========= */
function downloadMain(){
  const blob = new Blob([codeEl.value], {type:'text/x-python'});
  const url  = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url; a.download = 'main.py'; a.click();
  URL.revokeObjectURL(url);
}

/* ========= UI Events ========= */
document.getElementById('run').addEventListener('click', async ()=>{
  resEl.textContent=''; resEl.className='result';
  await ensureAudio(); // Ton erlauben
  runSimulatorFromCode(codeEl.value);
});
document.getElementById('check').addEventListener('click', checkTask);
document.getElementById('download').addEventListener('click', downloadMain);
nextBtn.addEventListener('click', ()=> alert('Weiter: Schritt 3 – Sensoren-Grundlagen (Schnellmodus).'));

/* Init */
resetSim();
</script>
</body>
</html>
