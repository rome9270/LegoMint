<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>EV3 - line follower</title>

  <link rel="stylesheet" href="../css/03_python.css" />
  <style>
    #arena {
      background:#f9fafb;
      border:2px solid #111;
      width:100%;
      height:auto;
      max-width:900px;
      border-radius:10px;
      display:block;
      margin-top:10px;
    }
    .status.ok { color:#15803d; }
    .status.error { color:#b91c1c; }
    .status.running { color:#374151; }
    .muted { color:#6b7280; }
    #error { color:#b91c1c; white-space:pre-wrap; }
  </style>
</head>
<body>
  <!-- NAV BAR -->
  <nav class="link-grid" aria-label="Topic selection">
    <a class="btn" href="../app/01_main.php" id="go-main" aria-label="Back to main">‚¨ÖÔ∏è Going to main</a>
    <a class="btn" href="../app/logout.php">üö™ Logout</a>
    <a class="btn" href="../html/03_10LegoEV3_I.html">Next ‚Üí</a>
  </nav>

  <header class="row" style="justify-content: space-between;">
    <div>
      <h1>EV3 (Pybricks) ¬∑ Line Follower</h1>
      <p>
        Write a <b>Pybricks</b> program that makes the robot <b>follow a black line</b> on the floor using a
        <b>ColorSensor on Port S1</b>.
      </p>

      <ol>
        <li>Use <code>ColorSensor(Port.S1)</code> and <code>.reflection()</code>.</li>
        <li>Store a <code>target_reflection</code> (mid between black and white).</li>
        <li>Loop while driving forward: compute error = target - reflection.</li>
        <li>Steer left/right from that error.</li>
      </ol>

      <p>
        After ~5 seconds of following:
        <b>stop</b>, <b>beep</b>, and print something with the word <code>line</code>.
      </p>

      <p class="muted" style="margin-top:8px;">
        Idea:<br>
        <code>target = 30</code><br>
        <code>while True:</code><br>
        <code>&nbsp;&nbsp;value = color.reflection()</code><br>
        <code>&nbsp;&nbsp;error = target - value</code><br>
        <code>&nbsp;&nbsp;steer = error * 2   # tuning</code><br>
        <code>&nbsp;&nbsp;drive.drive(100, steer)</code><br>
        <code>&nbsp;&nbsp;wait(10)</code>
      </p>
    </div>

    <div class="row">
      <button class="btn" id="tips-btn">üí° Tips</button>
      <button class="btn" id="solution-btn">‚úÖ Solution</button>
    </div>
  </header>

  <main class="layout">
    <!-- EDITOR CARD -->
    <section class="card">
      <h2>Editor</h2>
      <div class="row">
        <button class="btn primary" id="run-btn">‚ñ∂ Run</button>
        <button class="btn" id="reset-btn">‚ü≤ Reset</button>
        <button class="btn" id="save-btn">üíæ Save</button>
        <span id="status" class="status" aria-live="polite"></span>
      </div>

<textarea id="editor" spellcheck="false">#!/usr/bin/env pybricks-micropython
# EV3 (Pybricks) ‚Äì Line Follower
# - ColorSensor on Port.S1
# - follow the edge of a black line
# - simple P-control: steer = (target - reflection) * Kp

from pybricks.hubs import EV3Brick
from pybricks.ev3devices import Motor, ColorSensor
from pybricks.parameters import Port, Stop
from pybricks.tools import wait
from pybricks.robotics import DriveBase

brick = EV3Brick()

left   = Motor(Port.A)
right  = Motor(Port.B)
color  = ColorSensor(Port.S1)

drive = DriveBase(left, right, 56, 114)

target  = 30    # target reflection (tune this!)
kp      = 2     # proportional gain
runtime = 0     # ms

while runtime < 5000:   # follow line for ~5 seconds
    value = color.reflection()
    error = target - value
    steer = error * kp

    drive.drive(100, steer)   # forward speed 100 mm/s
    wait(10)
    runtime += 10

drive.stop(Stop.BRAKE)
brick.speaker.beep()
brick.screen.print("I followed the line!")
wait(500)
</textarea>
    </section>

    <!-- SIMULATION CARD -->
    <section class="card">
      <h2>Simulation</h2>
      <canvas id="arena" width="600" height="300"></canvas>
      <p class="muted">
        The black curve below is the "line". The robot (green circle) tries to stay on it.
      </p>
      <pre id="output"></pre>
      <div id="error"></div>
    </section>
  </main>

  <!-- Tips Modal -->
  <dialog id="tips-modal">
    <div class="modal-header">Tips</div>
    <div class="modal-body">
      <ul id="tips-list"></ul>
    </div>
    <div class="modal-actions">
      <button class="btn" id="close-tips">Close</button>
    </div>
  </dialog>

  <!-- Solution Modal -->
  <dialog id="solution-modal">
    <div class="modal-header">Solution (one example)</div>
    <div class="modal-body">
<pre id="solution-code" style="white-space:pre-wrap;">#!/usr/bin/env pybricks-micropython
from pybricks.hubs import EV3Brick
from pybricks.ev3devices import Motor, ColorSensor
from pybricks.parameters import Port, Stop
from pybricks.tools import wait
from pybricks.robotics import DriveBase

brick = EV3Brick()

left   = Motor(Port.A)
right  = Motor(Port.B)
color  = ColorSensor(Port.S1)

drive = DriveBase(left, right, 56, 114)

target  = 30    # depends on your line + lighting
kp      = 2
runtime = 0

while runtime < 5000:
    value = color.reflection()  # 0..100 (dark..bright)
    error = target - value      # how far from target
    steer = error * kp          # steering correction

    drive.drive(100, steer)
    wait(10)
    runtime += 10

drive.stop(Stop.BRAKE)
brick.speaker.beep()
brick.screen.print("Line done!")
wait(500)
</pre>
    </div>
    <div class="modal-actions">
      <button class="btn" id="copy-solution">Insert</button>
      <button class="btn" id="close-solution">Close</button>
    </div>
  </dialog>

  <script>
  /* ---------- TASK META ---------- */
  const TASK = { taskId: 9 };

  /* ---------- DOM refs ---------- */
  const editorEl   = document.getElementById("editor");
  const runBtn     = document.getElementById("run-btn");
  const resetBtn   = document.getElementById("reset-btn");
  const saveBtn    = document.getElementById("save-btn");
  const statusEl   = document.getElementById("status");
  const outputEl   = document.getElementById("output");
  const errorEl    = document.getElementById("error");
  const canvasEl   = document.getElementById("arena");

  const tipsBtn        = document.getElementById("tips-btn");
  const tipsModal      = document.getElementById("tips-modal");
  const closeTipsBtn   = document.getElementById("close-tips");

  const solutionBtn       = document.getElementById("solution-btn");
  const solutionModal     = document.getElementById("solution-modal");
  const closeSolutionBtn  = document.getElementById("close-solution");
  const copySolutionBtn   = document.getElementById("copy-solution");
  const solutionCodeEl    = document.getElementById("solution-code");

  /* ---------- UI helpers ---------- */
  function setStatus(cls, txt){
    statusEl.className = "status " + (cls || "");
    statusEl.textContent = txt || "";
  }
  function openDialog(d){
    if(!d) return;
    if(d.showModal) d.showModal();
    else d.setAttribute("open","");
  }
  function closeDialog(d){
    if(!d) return;
    if(d.close) d.close();
    else d.removeAttribute("open");
  }

  // tips list text
  const tipsListEl = document.getElementById("tips-list");
  if (tipsListEl){
    tipsListEl.innerHTML = [
      "Use ColorSensor(Port.S1) and reflection().",
      "Pick a target brightness between black tape and floor.",
      "error = target - value; steer = error * kp.",
      "drive.drive(100, steer) while wait(10).",
      "Run ~5 seconds.",
      'Stop with drive.stop(...), then beep + print(\"line\").'
    ].map(t=>"<li>"+t+"</li>").join("");
  }

  tipsBtn.onclick = ()=>openDialog(tipsModal);
  closeTipsBtn.onclick = ()=>closeDialog(tipsModal);

  solutionBtn.onclick = ()=>openDialog(solutionModal);
  closeSolutionBtn.onclick = ()=>closeDialog(solutionModal);
  copySolutionBtn.onclick = ()=>{
    if (editorEl && solutionCodeEl){
      editorEl.value = solutionCodeEl.textContent;
    }
    closeDialog(solutionModal);
    setStatus("ok","Solution inserted. You can run now.");
    outputEl.textContent = "";
    errorEl.textContent  = "";
  };

  /* ---------- Fortschritt -> Server ---------- */
  function sendEvent(ev){
    fetch("../app/event_update.php", {
      method: "POST",
      credentials: "include",
      headers: { "Content-Type": "application/x-www-form-urlencoded" },
      body: new URLSearchParams({
        task_id: String(TASK.taskId),
        event: ev
      })
    })
    .then(r => r.json())
    .then(data => {
      console.log("Server response:", data);
    })
    .catch(err => {
      console.warn("sendEvent failed:", err);
    });
  }

  /* ---------- Helpers ---------- */
  function stripComments(src){
    // kill full-line comments and trailing comments
    let x = src.replace(/^[ \t]*#.*$/gm, "");
    x = x.replace(/[ \t]+#.*$/gm, "");
    return x;
  }

  /* ---------- Validate student's Python code ---------- */
  function validateStudentCode(src){
    const raw  = src.replace(/\r/g,"");
    const code = stripComments(raw);
    const errs = [];

    if(code.trim()===""){
      errs.push("Please write your Pybricks program first.");
      return { ok:false, errors:errs };
    }

    // required imports
    [
      [/from\s+pybricks\.hubs\s+import\s+EV3Brick/, "Missing import: EV3Brick"],
      [/from\s+pybricks\.ev3devices\s+import\s+.*\bMotor\b/, "Missing import: Motor"],
      [/from\s+pybricks\.ev3devices\s+import\s+.*\bColorSensor\b/, "Missing import: ColorSensor"],
      [/from\s+pybricks\.parameters\s+import\s+.*\bPort\b/, "Missing import: Port"],
      [/from\s+pybricks\.parameters\s+import\s+.*\bStop\b/, "Missing import: Stop"],
      [/from\s+pybricks\.tools\s+import\s+.*\bwait\b/, "Missing import: wait"],
      [/from\s+pybricks\.robotics\s+import\s+.*\bDriveBase\b/, "Missing import: DriveBase"]
    ].forEach(([re,msg])=>{
      if(!re.test(code)) errs.push("‚úó "+msg);
    });

    // hardware init
    if(!/EV3Brick\s*\(\s*\)/.test(code)) errs.push("‚úó EV3Brick() missing");
    if(!/Motor\s*\(\s*Port\.A\s*\)/.test(code)) errs.push("‚úó Motor(Port.A) missing");
    if(!/Motor\s*\(\s*Port\.B\s*\)/.test(code)) errs.push("‚úó Motor(Port.B) missing");
    if(!/ColorSensor\s*\(\s*Port\.S1\s*\)/.test(code)) errs.push("‚úó ColorSensor(Port.S1) missing");
    if(!/DriveBase\s*\(/.test(code)) errs.push("‚úó DriveBase(...) missing");

    // must read reflection() in a loop
    if(!/reflection\s*\(\s*\)/.test(code)){
      errs.push("‚úó Missing color.reflection()");
    }

    // should compute error and steer
    if(!/error\s*=\s*.*target.*-.*(value|color\.reflection\(\))/s.test(code) &&
       !/error\s*=\s*target\s*-\s*\w+/s.test(code)){
      errs.push("‚úó Missing error = target - value");
    }
    if(!/steer\s*=\s*.*error.*\*/.test(code)){
      errs.push("‚úó Missing steer = error * kp (or similar)");
    }

    // should drive with drive.drive(..., steer)
    if(!/drive\.drive\s*\(\s*\d+\s*,\s*steer\s*\)/.test(code)){
      errs.push("‚úó Missing drive.drive(100, steer)");
    }

    // should loop ~5 seconds via runtime < 5000
    if(!/while\s+\w+\s*<\s*5000\s*:/.test(code)){
      errs.push("‚úó Missing while runtime < 5000: loop for ~5 seconds");
    }

    // should call wait(10) in the loop
    if(!/wait\s*\(\s*10\s*\)/.test(code)){
      errs.push("‚úó Missing wait(10) inside the loop");
    }

    // should stop & beep & say "line"
    if(!/drive\.stop\s*\(\s*Stop\.BRAKE\s*\)/.test(code)){
      errs.push("‚úó Missing drive.stop(Stop.BRAKE) at the end");
    }
    if(!/brick\s*\.\s*speaker\s*\.\s*beep\s*\(\s*\)/.test(code)){
      errs.push("‚úó Missing brick.speaker.beep() at the end");
    }
    if(!/brick\s*\.\s*screen\s*\.\s*print\s*\(\s*["'][^"']*line[^"']*["']\s*\)/i.test(code)){
      errs.push('‚úó Missing brick.screen.print("...line...") at the end');
    }

    return { ok: errs.length===0, errors: errs };
  }

  /* ---------- Canvas + Simulation ---------- */

  const ctx = canvasEl.getContext("2d");
  const degToRad = d => d * Math.PI/180;

  // Wavy reference "line"
  function lineY(x){
    return 150 + Math.sin(x / 60) * 40;
  }

  const WORLD = {
    robot: {
      x: 60,
      y: lineY(60),
      heading: 0,
      r: 6
    }
  };

  function drawWorld(){
    // bg + border
    ctx.fillStyle="#fff";
    ctx.fillRect(0,0,canvasEl.width,canvasEl.height);
    ctx.strokeStyle="#111";
    ctx.lineWidth=2;
    ctx.strokeRect(0,0,canvasEl.width,canvasEl.height);

    // black wavy line
    ctx.strokeStyle="#000";
    ctx.lineWidth=4;
    ctx.beginPath();
    for (let x=0; x<=canvasEl.width; x+=2){
      const y = lineY(x);
      if (x===0) ctx.moveTo(x,y); else ctx.lineTo(x,y);
    }
    ctx.stroke();

    // robot
    const r = WORLD.robot;
    ctx.fillStyle="#16a34a";
    ctx.beginPath();
    ctx.arc(r.x,r.y,r.r,0,Math.PI*2);
    ctx.fill();

    // heading indicator
    ctx.strokeStyle="#16a34a";
    ctx.lineWidth=2;
    ctx.beginPath();
    ctx.moveTo(r.x,r.y);
    ctx.lineTo(
      r.x + Math.cos(degToRad(r.heading))*(r.r+10),
      r.y + Math.sin(degToRad(r.heading))*(r.r+10)
    );
    ctx.stroke();
  }

  function resetWorld(){
    WORLD.robot = {
      x: 60,
      y: lineY(60),
      heading: 0,
      r: 6
    };
    drawWorld();
  }

  // ~5s follow: fake "sensor" is vertical offset to line
  async function followLineSim(){
    const kp = 0.15;    // steering gain in canvas sim
    const speedPx = 1.2;
    const frames = 300; // ~5s look & feel

    for (let i=0; i<frames; i++){
      const idealY = lineY(WORLD.robot.x);
      const error = idealY - WORLD.robot.y;

      // proportional steering -> heading change
      const steerDeg = kp * error;
      WORLD.robot.heading += steerDeg;

      // move forward in that heading
      WORLD.robot.x += Math.cos(degToRad(WORLD.robot.heading)) * speedPx;
      WORLD.robot.y += Math.sin(degToRad(WORLD.robot.heading)) * speedPx;

      drawWorld();
      await new Promise(res => setTimeout(res,16));
    }
  }

  /* ---------- RUN / RESET / SAVE ---------- */

  async function runSimulationIfValid(){
    // 1) validate student's Python
    const { ok, errors } = validateStudentCode(editorEl.value);

    if(!ok){
      setStatus("error","ERROR");
      outputEl.textContent = "Please fix first:\n" + errors.join("\n");
      errorEl.textContent  = "";
      return;
    }

    // 2) simulate
    setStatus("running","running‚Ä¶");
    outputEl.textContent = "";
    errorEl.textContent  = "";
    resetWorld();

    await followLineSim();

    // 3) done
    setStatus("ok","done.");
    outputEl.textContent = 'Simulated: line following ~5s, then stop + beep + "line".';

    // Fortschritt melden
    sendEvent("sim");
  }

  function doReset(){
    setStatus("","");
    outputEl.textContent = "";
    errorEl.textContent  = "";
    resetWorld();
  }

  function saveFile(){
    const blob = new Blob([editorEl.value], { type:"text/plain" });
    const a = document.createElement("a");
    a.href = URL.createObjectURL(blob);
    a.download = "main.py";
    a.click();
    URL.revokeObjectURL(a.href);

    // Fortschritt melden
    sendEvent("download");
  }

  runBtn.onclick   = runSimulationIfValid;
  resetBtn.onclick = doReset;
  saveBtn.onclick  = saveFile;

  // initial
  resetWorld();
  setStatus("","");
  </script>
</body>
</html>
