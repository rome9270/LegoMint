<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>EV3 - warehouse mission&person safety</title>

  <link rel="stylesheet" href="../css/03_python.css" />
  <style>
    #arena {
      background:#f9fafb;
      border:2px solid #111;
      width:100%;
      height:auto;
      max-width:900px;
      border-radius:10px;
      display:block;
      margin-top:10px;
    }

    .status.ok      { color:#15803d; }
    .status.error   { color:#b91c1c; }
    .status.running { color:#374151; }
    .muted { color:#6b7280; }
    #error { color:#b91c1c; white-space:pre-wrap; }

    .tipbox {
      background:#f0fdf4;
      border:1px solid #86efac;
      border-radius:8px;
      padding:10px 12px;
      margin-top:8px;
      font-size:0.9rem;
      color:#166534;
    }
  </style>
</head>
<body>
  <!-- NAV -->
  <nav class="link-grid" aria-label="Topic selection">
    <a class="btn" href="../app/01_main.php" id="go-main">‚¨ÖÔ∏è Main</a>
    <a class="btn" href="../app/logout.php">üö™ Logout</a>
    <!-- <a class="btn primary" id="next-btn" href="04_02LegoEV3_I.html">Next ‚Üí</a> -->
  </nav>

  <header class="row" style="justify-content: space-between;">
    <div>
      <h1>EV3 (Pybricks) ¬∑ Warehouse Mission + Person Safety</h1>

      <p>The robot should:</p>
      <ol>
        <li>Start <b>off the black line</b> (ColorSensor, Port S1, is not on the line yet).</li>
        <li><b>Seek the line</b>: move until it finds the black line (dark tape).</li>
        <li>Follow the line forward with slow P-control.</li>
        <li>At each <b>beige marker</b>: stop and say <code>"please load the vehicle"</code>.
            Do this 3 times.</li>
        <li><b>Safety:</b> If the InfraredSensor on <b>Port S2</b> sees a person close
            in front, stop and say
            <code>"you are in my way - please move"</code> until the path is clear.</li>
        <li>After the 3rd station, continue to the end and say:
          <code>"please unload the car"</code>,
          then
          <code>"job done, ready for the next one"</code>.
        </li>
      </ol>

      <p class="muted">
        ‚Ä¢ The editor is just a scaffold / help text.<br>
        ‚Ä¢ Click <b>‚úÖ Solution ‚Üí Insert</b> to load the working slow code into the editor.<br>
        ‚Ä¢ Press <b>‚ñ∂ Run</b> to watch the simulation (visual only).<br>
        ‚Ä¢ Motors: A = left, B = right. ColorSensor on S1. InfraredSensor on S2.
      </p>
    </div>

    <div class="row">
      <button class="btn" id="tips-btn">üí° Tips</button>
      <button class="btn" id="solution-btn">‚úÖ Solution</button>
    </div>
  </header>

  <main class="layout">
    <!-- EDITOR -->
    <section class="card">
      <h2>Editor</h2>
      <div class="row">
        <button class="btn primary" id="run-btn">‚ñ∂ Run</button>
        <button class="btn" id="reset-btn">‚ü≤ Reset</button>
        <button class="btn" id="save-btn">üíæ Save</button>
        <span id="status" class="status" aria-live="polite"></span>
      </div>

<textarea id="editor" spellcheck="false">#!/usr/bin/env pybricks-micropython
# Warehouse Mission + Person Safety (scaffold)
#
# 1. Start OFF the line.
# 2. SEEK black line using ColorSensor(S1).
# 3. FOLLOW black line slowly:
#    - Stop at beige markers 3x, say "please load the vehicle".
#    - If person in front (InfraredSensor on S2 is too close),
#      stop and say "you are in my way - please move"
#      until path is clear.
# 4. After 3rd stop, continue to the end:
#    - Say "please unload the car"
#    - Then "job done, ready for the next one"
#
# Hardware:
#   Motor A = left wheel
#   Motor B = right wheel
#   ColorSensor on Port.S1
#   InfraredSensor on Port.S2
#
# Use ‚úÖ Solution ‚Üí Insert for a ready-to-run slow version.
</textarea>
    </section>

    <!-- SIMULATION -->
    <section class="card">
      <h2>Simulation</h2>

      <canvas id="arena" width="600" height="300"></canvas>

      <p class="muted">
        Robot (green) starts below the black line ‚Üí seeks line ‚Üí
        follows the line. At each beige station it pauses
        ("please load the vehicle"). If there's a person in front,
        it waits ("you are in my way - please move").
        After station 3, it drives to the end and unloads.
      </p>

      <div class="tipbox">
        <strong>üí° Sensor tip:</strong><br>
        ‚Ä¢ Black line = low reflection (~10-20).<br>
        ‚Ä¢ Beige station = bright (~70+).<br>
        ‚Ä¢ Person = InfraredSensor(S2).distance() small (e.g. &lt;30 cm).<br>
        ‚Ä¢ After 3rd station, keep rolling to final drop zone and unload.
      </div>

      <pre id="output"></pre>
      <div id="error"></div>
    </section>
  </main>

  <!-- TIPS MODAL -->
  <dialog id="tips-modal">
    <div class="modal-header">Tips</div>
    <div class="modal-body">
      <ul id="tips-list"></ul>
    </div>
    <div class="modal-actions">
      <button class="btn" id="close-tips">Close</button>
    </div>
  </dialog>

  <!-- SOLUTION MODAL -->
  <dialog id="solution-modal">
    <div class="modal-header">Solution (slow EV3 code with IR safety)</div>
    <div class="modal-body">
<pre id="solution-code" style="white-space:pre-wrap;">#!/usr/bin/env pybricks-micropython
from pybricks.hubs import EV3Brick
from pybricks.ev3devices import Motor, ColorSensor, InfraredSensor
from pybricks.parameters import Port, Stop
from pybricks.tools import wait
from pybricks.robotics import DriveBase

brick = EV3Brick()

# MOTORS / SENSORS
left   = Motor(Port.A)                # left drive motor
right  = Motor(Port.B)                # right drive motor
color  = ColorSensor(Port.S1)         # down-facing line sensor
ir     = InfraredSensor(Port.S2)      # front safety sensor
drive  = DriveBase(left, right, 56, 114)

brick.speaker.beep()
brick.screen.clear()
brick.screen.print("Warehouse safety start")
wait(500)

# TUNING
DARK_TARGET        = 20       # ~ black line reflection
KP                 = 1.0      # steering gain
SPEED_FWD          = 40       # slow forward mm/s
BEIGE_LIMIT        = 70       # > this => beige station marker
STATION_WAIT_MS    = 2000     # wait at station
ROLL_AWAY_MS       = 800      # creep fwd after station
HUMAN_DISTANCE_CM  = 30       # stop if ir.distance() < 30 cm

TOTAL_STOPS_TARGET = 3        # 3x "please load the vehicle"
FINAL_ROLL_MS      = 3000     # then final drive to unload area

def wait_until_clear():
    # block while human is too close
    while ir.distance() < HUMAN_DISTANCE_CM:
        drive.stop(Stop.BRAKE)
        brick.speaker.say("you are in my way - please move")
        wait(500)

# 1) SEEK LINE
while color.reflection() > DARK_TARGET + 5:
    wait_until_clear()
    drive.drive(30, 0)        # creep forward slowly
    wait(20)
drive.stop(Stop.BRAKE)
brick.speaker.say("line found")
wait(500)

# 2) FOLLOW + 3 LOAD STATIONS
stops_done = 0
while stops_done < TOTAL_STOPS_TARGET:
    wait_until_clear()

    # line follow P-control
    ref   = color.reflection()
    error = DARK_TARGET - ref
    steer = error * KP
    drive.drive(SPEED_FWD, steer)

    # beige station?
    if color.reflection() > BEIGE_LIMIT:
        drive.stop(Stop.BRAKE)
        brick.speaker.say("please load the vehicle")
        wait(STATION_WAIT_MS)

        stops_done += 1

        # roll a bit forward to leave the marker
        drive.drive(SPEED_FWD, 0)
        wait(ROLL_AWAY_MS)
        drive.stop(Stop.BRAKE)

    wait(20)

# 3) FINAL ROLL TO UNLOAD AREA
wait_until_clear()
drive.drive(SPEED_FWD, 0)
wait(FINAL_ROLL_MS)
drive.stop(Stop.BRAKE)

brick.speaker.say("please unload the car")
wait(1000)
brick.speaker.say("job done, ready for the next one")
brick.speaker.beep()
brick.screen.clear()
brick.screen.print("mission done")
wait(1000)
</pre>
    </div>
    <div class="modal-actions">
      <button class="btn" id="copy-solution">Insert</button>
      <button class="btn" id="close-solution">Close</button>
    </div>
  </dialog>

  <script>
  /* ============================================================
     TASK META
  ============================================================ */
  const TASK = { taskId: 12 };

  /* ============================================================
     DOM ELEMENTS
  ============================================================ */
  const runBtn        = document.getElementById("run-btn");
  const resetBtn      = document.getElementById("reset-btn");
  const saveBtn       = document.getElementById("save-btn");
  const editorEl      = document.getElementById("editor");
  const statusEl      = document.getElementById("status");
  const outputEl      = document.getElementById("output");
  const errorEl       = document.getElementById("error");
  const canvasEl      = document.getElementById("arena");

  const tipsBtn       = document.getElementById("tips-btn");
  const tipsModal     = document.getElementById("tips-modal");
  const closeTips     = document.getElementById("close-tips");

  const solutionBtn   = document.getElementById("solution-btn");
  const solutionModal = document.getElementById("solution-modal");
  const copySolution  = document.getElementById("copy-solution");
  const closeSolution = document.getElementById("close-solution");
  const solutionCodeEl= document.getElementById("solution-code");

  const tipsListEl    = document.getElementById("tips-list");

  /* ============================================================
     STATUS HELPER
  ============================================================ */
  function setStatus(cls, txt){
    statusEl.className = "status " + (cls || "");
    statusEl.textContent = txt || "";
  }

  /* tips text */
  if (tipsListEl){
    tipsListEl.innerHTML = [
      "Seek the dark line first using ColorSensor(S1).",
      "Follow the line with P-control: steer = (target - reflection) * KP.",
      "Stop at beige markers and say 'please load the vehicle' (3x).",
      "If person ahead (IR S2 close): stop and say 'you are in my way - please move' until clear.",
      "At the end: 'please unload the car' + 'job done, ready for the next one'."
    ].map(t=>"<li>"+t+"</li>").join("");
  }

  /* ============================================================
     MODALS + INSERT SOLUTION
  ============================================================ */
  const gate = { ready:false };

  tipsBtn.onclick = ()=>{
    if (tipsModal.showModal) tipsModal.showModal();
    else tipsModal.setAttribute("open","");
  };
  closeTips.onclick = ()=>{
    if (tipsModal.close) tipsModal.close();
    else tipsModal.removeAttribute("open");
  };

  solutionBtn.onclick = ()=>{
    if (solutionModal.showModal) solutionModal.showModal();
    else solutionModal.setAttribute("open","");
  };
  closeSolution.onclick = ()=>{
    if (solutionModal.close) solutionModal.close();
    else solutionModal.removeAttribute("open");
  };
  copySolution.onclick = ()=>{
    editorEl.value = solutionCodeEl.textContent;
    gate.ready = true;

    if (solutionModal.close) solutionModal.close();
    else solutionModal.removeAttribute("open");

    setStatus("ok","Ready to run");
    outputEl.textContent = "Solution code inserted. Press ‚ñ∂ Run.";
    errorEl.textContent  = "";
    resetWorld();
  };

  /* ============================================================
     SERVER PROGRESS TRACKING
  ============================================================ */
  function sendEvent(ev){
    fetch("../app/event_update.php", {
      method: "POST",
      credentials: "include",
      headers: { "Content-Type": "application/x-www-form-urlencoded" },
      body: new URLSearchParams({
        task_id: String(TASK.taskId),
        event: ev
      })
    })
    .then(r => r.json())
    .then(data => console.log("Server response:", data))
    .catch(err => console.warn("sendEvent failed:", err));
  }

  /* ============================================================
     VALIDATION (check student code before sim)
     - imports
     - ColorSensor S1
     - InfraredSensor S2
     - seek loop
     - line follow P-control
     - "please load the vehicle"
     - IR safety message "you are in my way - please move"
     - final unload + job done messages
  ============================================================ */
  function stripComments(src){
    let x = src.replace(/^[ \t]*#.*$/gm, "");
    x = x.replace(/[ \t]+#.*$/gm, "");
    return x;
  }

  function validateStudentCode(src){
    const raw  = src.replace(/\r/g,"");
    const code = stripComments(raw);
    const errs = [];

    if(code.trim()===""){
      errs.push("Please write your Pybricks program first.");
      return {ok:false, errors:errs};
    }

    // imports we expect
    [
      [/from\s+pybricks\.hubs\s+import\s+EV3Brick/, "Missing import: EV3Brick"],
      [/from\s+pybricks\.ev3devices\s+import\s+.*\bMotor\b/, "Missing import: Motor"],
      [/from\s+pybricks\.ev3devices\s+import\s+.*\bColorSensor\b/, "Missing import: ColorSensor"],
      [/from\s+pybricks\.ev3devices\s+import\s+.*\bInfraredSensor\b/, "Missing import: InfraredSensor"],
      [/from\s+pybricks\.parameters\s+import\s+.*\bPort\b/, "Missing import: Port"],
      [/from\s+pybricks\.parameters\s+import\s+.*\bStop\b/, "Missing import: Stop"],
      [/from\s+pybricks\.tools\s+import\s+.*\bwait\b/, "Missing import: wait"],
      [/from\s+pybricks\.robotics\s+import\s+.*\bDriveBase\b/, "Missing import: DriveBase"]
    ].forEach(([re,msg])=>{ if(!re.test(code)) errs.push("‚úó "+msg); });

    // hardware init
    if(!/EV3Brick\s*\(\s*\)/.test(code)) errs.push("‚úó EV3Brick() missing");
    if(!/Motor\s*\(\s*Port\.A\s*\)/.test(code)) errs.push("‚úó Motor(Port.A) missing");
    if(!/Motor\s*\(\s*Port\.B\s*\)/.test(code)) errs.push("‚úó Motor(Port.B) missing");
    if(!/ColorSensor\s*\(\s*Port\.S1\s*\)/.test(code)) errs.push("‚úó ColorSensor(Port.S1) missing");
    if(!/InfraredSensor\s*\(\s*Port\.S2\s*\)/.test(code)) errs.push("‚úó InfraredSensor(Port.S2) missing");
    if(!/DriveBase\s*\(/.test(code)) errs.push("‚úó DriveBase(...) missing");

    // IR safety check loop: look for distance() and message
    if(!/ir\s*\.\s*distance\s*\(/.test(code)){
      errs.push("‚úó Must read ir.distance() for safety stop.");
    }
    if(!/you\s+are\s+in\s+my\s+way\s*-\s*please\s+move/i.test(code)){
      errs.push('‚úó Must say "you are in my way - please move" when blocked.');
    }

    // seek loop (drive until dark line)
    if(!/while\s+.*color\s*\.\s*reflection\s*\(\s*\)\s*>\s*.*\+\s*5/.test(code)
      && !/while\s+.*color\s*\.\s*reflection\s*\(\s*\)\s*>\s*\d+/.test(code)){
      errs.push("‚úó Missing seek loop that drives until the black line is found.");
    }

    // line follow P part
    if(!/error\s*=\s*.*-\s*.*reflection\s*\(\s*\)/s.test(code)){
      errs.push("‚úó Missing error = DARK_TARGET - color.reflection().");
    }
    if(!/steer\s*=\s*.*error.*\*/.test(code)){
      errs.push("‚úó Missing steer = error * KP.");
    }
    if(!/drive\.drive\s*\(\s*\w+.*,\s*steer\s*\)/.test(code) &&
       !/drive\.drive\s*\(\s*\d+.*,\s*steer\s*\)/.test(code)){
      errs.push("‚úó Missing drive.drive(SPEED_FWD, steer) in the follow loop.");
    }

    // station stop message
    if(!/please\s+load\s+the\s+vehicle/i.test(code)){
      errs.push('‚úó Must say "please load the vehicle" at beige stations.');
    }

    // final unload + job done
    if(!/please\s+unload\s+the\s+car/i.test(code)){
      errs.push('‚úó Must say "please unload the car" at the end.');
    }
    if(!/job\s+done,\s*ready\s*for\s*the\s*next\s*one/i.test(code)){
      errs.push('‚úó Must say "job done, ready for the next one" at the end.');
    }

    return { ok: errs.length===0, errors: errs };
  }

  /* ============================================================
     CANVAS / WORLD STATE / SIM LOGIC
  ============================================================ */

  // warehouse line geometry etc.
  const LINE_Y        = 200;
  const START_X       = 80;
  const START_Y       = 235;
  const START_HEADING = 0;

  // beige stations (3 stops)
  const STATION_XS    = [200, 350, 500];

  // person location (IR stop)
  const PERSON_X      = 280;
  const PERSON_TOL    = 15;

  // unload zone
  const LINE_END_X    = 560;

  // animation tuning
  const SEEK_SPEED_PX        = 1.0;
  const FOLLOW_SPEED_PX      = 0.6;
  const KP_FOLLOW            = 0.06;
  const ROTATE_MAX_PER_FRAME = 2;
  const STOP_WAIT_FRAMES     = 60;
  const PERSON_WAIT_FRAMES   = 60;
  const FINAL_ROLL_FRAMES    = 180;

  let running = false;

  const ctx = canvasEl.getContext("2d");
  const deg2rad = d => d * Math.PI/180;

  const WORLD = {
    robot: { x: START_X, y: START_Y, heading: START_HEADING, r: 6 }
  };

  function drawWorld(label){
    ctx.fillStyle="#fff";
    ctx.fillRect(0,0,canvasEl.width,canvasEl.height);

    ctx.strokeStyle="#111";
    ctx.lineWidth=2;
    ctx.strokeRect(0,0,canvasEl.width,canvasEl.height);

    // black line
    ctx.strokeStyle="#000";
    ctx.lineWidth=4;
    ctx.beginPath();
    ctx.moveTo(0, LINE_Y);
    ctx.lineTo(canvasEl.width, LINE_Y);
    ctx.stroke();

    // beige stations
    STATION_XS.forEach(xPos=>{
      ctx.strokeStyle="#e7e3c2";
      ctx.lineWidth=8;
      ctx.beginPath();
      ctx.moveTo(xPos, LINE_Y-20);
      ctx.lineTo(xPos, LINE_Y+20);
      ctx.stroke();
    });

    // person marker (IR obstacle)
    ctx.fillStyle="#f97316";
    ctx.beginPath();
    ctx.arc(PERSON_X, LINE_Y-30, 4, 0, Math.PI*2);
    ctx.fill();
    ctx.fillStyle="#000";
    ctx.font="10px sans-serif";
    ctx.fillText("üö∂", PERSON_X-4, LINE_Y-34);

    // robot
    const r = WORLD.robot;
    ctx.fillStyle="#16a34a";
    ctx.beginPath();
    ctx.arc(r.x, r.y, r.r, 0, Math.PI*2);
    ctx.fill();

    ctx.strokeStyle="#16a34a";
    ctx.lineWidth=2;
    ctx.beginPath();
    ctx.moveTo(r.x, r.y);
    ctx.lineTo(
      r.x + Math.cos(deg2rad(r.heading))*15,
      r.y + Math.sin(deg2rad(r.heading))*15
    );
    ctx.stroke();

    if(label){
      ctx.fillStyle="#374151";
      ctx.font="12px sans-serif";
      const lines = label.split("\n");
      lines.forEach((L,i)=>{
        ctx.fillText(L, 10, 20 + i*14);
      });
    }
  }

  function resetWorld(){
    WORLD.robot.x = START_X;
    WORLD.robot.y = START_Y;
    WORLD.robot.heading = START_HEADING;
    drawWorld("ready (off the line)");
  }

  function stepForward(px){
    WORLD.robot.x += Math.cos(deg2rad(WORLD.robot.heading)) * px;
    WORLD.robot.y += Math.sin(deg2rad(WORLD.robot.heading)) * px;
  }

  function turnToward(targetDeg, maxStepDeg){
    let cur = WORLD.robot.heading;
    let diff = ((targetDeg - cur + 540) % 360) - 180;
    const step = Math.sign(diff) * Math.min(Math.abs(diff), maxStepDeg);
    WORLD.robot.heading = (cur + step + 360) % 360;
  }

  // go vertically up to the line
  function simSeekLine(){
    return new Promise(resolve=>{
      const goingUp = WORLD.robot.y > LINE_Y;
      WORLD.robot.heading = goingUp ? 270 : 90;

      function tick(){
        if(!running) return resolve();

        stepForward(SEEK_SPEED_PX);
        drawWorld("seeking line‚Ä¶");

        const closeEnough = Math.abs(WORLD.robot.y - LINE_Y) <= 1;
        const crossed = goingUp
          ? (WORLD.robot.y <= LINE_Y)
          : (WORLD.robot.y >= LINE_Y);

        if (closeEnough || crossed){
          WORLD.robot.y = LINE_Y;
          WORLD.robot.heading = 0;
          drawWorld("line found");
          resolve();
          return;
        }

        requestAnimationFrame(tick);
      }

      requestAnimationFrame(tick);
    });
  }

  function gentleFollowStep(){
    const desiredHeading = 0;
    const errorY = LINE_Y - WORLD.robot.y;
    const correction = errorY * KP_FOLLOW;
    const targetHeading = desiredHeading + correction * 180;
    turnToward(targetHeading, ROTATE_MAX_PER_FRAME);
    stepForward(FOLLOW_SPEED_PX);
  }

  function nearPerson(){
    return Math.abs(WORLD.robot.x - PERSON_X) < PERSON_TOL;
  }

  // follow line, pause for person, pause at stations
  function simFollowStopsAndSafety(){
    return new Promise(resolve=>{
      let stationIndex = 0;
      let phase = "drive";
      let waitFrames = 0;

      function tick(){
        if(!running) return resolve();

        // all 3 stations handled?
        if (stationIndex >= STATION_XS.length){
          resolve();
          return;
        }

        if(phase === "drive"){
          gentleFollowStep();

          // IR person block?
          if(nearPerson()){
            phase = "personWait";
            waitFrames = 0;
            drawWorld('you are in my way - please move');
            requestAnimationFrame(tick);
            return;
          }

          drawWorld(`to station ${stationIndex+1}`);

          // station reached?
          if(WORLD.robot.x >= STATION_XS[stationIndex]){
            phase = "stationWait";
            waitFrames = 0;
          }

          requestAnimationFrame(tick);
          return;
        }

        if(phase === "personWait"){
          drawWorld('you are in my way - please move');
          waitFrames++;
          if(waitFrames >= PERSON_WAIT_FRAMES){
            phase = "drive";
          }
          requestAnimationFrame(tick);
          return;
        }

        if(phase === "stationWait"){
          drawWorld(`station ${stationIndex+1}:\n"please load the vehicle"`);
          waitFrames++;
          if(waitFrames >= STOP_WAIT_FRAMES){
            stationIndex++;
            phase = "drive";
          }
          requestAnimationFrame(tick);
          return;
        }
      }

      requestAnimationFrame(tick);
    });
  }

  // final roll to unload area
  function simFinalRun(){
    return new Promise(resolve=>{
      let f = 0;
      function tick(){
        if(!running) return resolve();

        gentleFollowStep();
        drawWorld('final run‚Ä¶');

        if(WORLD.robot.x >= LINE_END_X){
          WORLD.robot.x = LINE_END_X;
          WORLD.robot.heading = 0;
          drawWorld('please unload the car\njob done, ready for the next one');
          resolve();
          return;
        }

        f++;
        if(f >= FINAL_ROLL_FRAMES){
          WORLD.robot.heading = 0;
          drawWorld('please unload the car\njob done, ready for the next one');
          resolve();
          return;
        }

        requestAnimationFrame(tick);
      }
      requestAnimationFrame(tick);
    });
  }

  /* ============================================================
     RUN MISSION
     - requires gate.ready
     - validates student code
     - runs sim
     - reports sim event
  ============================================================ */
  async function runMission(){
    if(!gate.ready){
      setStatus("error","ERROR");
      errorEl.textContent = "‚ö†Ô∏è Click 'Solution ‚Üí Insert' first!";
      return;
    }

    const { ok, errors } = validateStudentCode(editorEl.value);
    if(!ok){
      setStatus("error","ERROR");
      outputEl.textContent = "Please fix first:\n" + errors.join("\n");
      errorEl.textContent  = "";
      return;
    }

    if(running) return;
    running = true;

    setStatus("running","running‚Ä¶");
    outputEl.textContent="";
    errorEl.textContent="";

    resetWorld();

    await simSeekLine();
    await simFollowStopsAndSafety();
    await simFinalRun();

    running = false;
    setStatus("ok","done.");
    outputEl.textContent =
      'Simulation: seek line ‚Üí 3√ó "please load the vehicle" (+ safety stop if person) ‚Üí unload at end.';

    // Fortschritt melden
    sendEvent("sim");
  }

  /* ============================================================
     BUTTONS
  ============================================================ */
  runBtn.onclick = runMission;

  resetBtn.onclick = ()=>{
    running = false;
    setStatus("","");
    outputEl.textContent="";
    errorEl.textContent="";
    resetWorld();
  };

  saveBtn.onclick = ()=>{
    const blob = new Blob([editorEl.value], {type:"text/plain"});
    const a = document.createElement("a");
    a.href = URL.createObjectURL(blob);
    a.download="main.py";
    a.click();
    URL.revokeObjectURL(a.href);

    // Fortschritt melden
    sendEvent("download");
  };

  /* ============================================================
     INIT
  ============================================================ */
  resetWorld();
  setStatus("","");
  </script>
</body>
</html>
