<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>EV3 - warehouse mission&person safety</title>

  <link rel="stylesheet" href="../css/03_python.css" />
  <style>
    #arena {
      background:#f9fafb;
      border:2px solid #111;
      width:100%;
      height:auto;
      max-width:900px;
      border-radius:10px;
      display:block;
      margin-top:10px;
    }

    .status.ok      { color:#15803d; }
    .status.error   { color:#b91c1c; }
    .status.running { color:#374151; }
    .muted { color:#6b7280; }
    #error { color:#b91c1c; white-space:pre-wrap; }

    .tipbox {
      background:#f0fdf4;
      border:1px solid #86efac;
      border-radius:8px;
      padding:10px 12px;
      margin-top:8px;
      font-size:0.9rem;
      color:#166534;
    }
  </style>
</head>
<body>
  <!-- NAV -->
  <nav class="link-grid" aria-label="Topic selection">
    <a class="btn" href="../app/01_main.php" id="go-main">‚¨ÖÔ∏è Main</a>
    <a class="btn" href="../app/logout.php">üö™ Logout</a>
    <a class="btn primary" id="next-btn" href="03_13LegoEV3_I.html">Next ‚Üí</a>
  </nav>

  <header class="row" style="justify-content: space-between;">
    <div>
      <h1>EV3 (Pybricks) ¬∑ Warehouse Mission + Person Safety</h1>

      <p>The robot should:</p>
      <ol>
        <li>Start <b>off the black line</b> (ColorSensor, Port S1, is not on the line yet).</li>
        <li><b>Seek the line</b>: move until it finds the black line (dark tape).</li>
        <li>Follow the line forward with slow P-control.</li>
        <li>At each <b>beige marker</b>: stop and say <code>"please load the vehicle"</code>.
            Do this 3 times.</li>
        <li><b>Safety:</b> If the InfraredSensor on <b>Port S2</b> sees a person close
            in front, stop and say
            <code>"you are in my way - please move"</code> until the path is clear.</li>
        <li>After the 3rd station, continue to the end and say:
          <code>"please unload the car"</code>,
          then
          <code>"job done, ready for the next one"</code>.
        </li>
      </ol>

      <p class="muted">
        ‚Ä¢ The editor is just a scaffold / help text.<br>
        ‚Ä¢ Click <b>‚úÖ Solution ‚Üí Insert</b> to load the working slow code into the editor.<br>
        ‚Ä¢ Press <b>‚ñ∂ Run</b> to watch the simulation (visual only).<br>
        ‚Ä¢ Motors: A = left, B = right. ColorSensor on S1. InfraredSensor on S2.
      </p>
    </div>

    <div class="row">
      <button class="btn" id="tips-btn">üí° Tips</button>
      <button class="btn" id="solution-btn">‚úÖ Solution</button>
    </div>
  </header>

  <main class="layout">
    <!-- EDITOR -->
    <section class="card">
      <h2>Editor</h2>
      <div class="row">
        <button class="btn primary" id="run-btn">‚ñ∂ Run</button>
        <button class="btn" id="reset-btn">‚ü≤ Reset</button>
        <button class="btn" id="save-btn">üíæ Save</button>
        <span id="status" class="status" aria-live="polite"></span>
      </div>

<textarea id="editor" spellcheck="false">#!/usr/bin/env pybricks-micropython
# Warehouse Mission + Person Safety (scaffold)
#
# 1. Start OFF the line.
# 2. SEEK black line using ColorSensor(S1).
# 3. FOLLOW black line slowly:
#    - Stop at beige markers 3x, say "please load the vehicle".
#    - If person in front (InfraredSensor on S2 is too close),
#      stop and say "you are in my way - please move"
#      until path is clear.
# 4. After 3rd stop, continue to the end:
#    - Say "please unload the car"
#    - Then "job done, ready for the next one"
#
# Hardware:
#   Motor A = left wheel
#   Motor B = right wheel
#   ColorSensor on Port.S1
#   InfraredSensor on Port.S2
#
# Use ‚úÖ Solution ‚Üí Insert for a ready-to-run slow version.
</textarea>
    </section>

    <!-- SIMULATION -->
    <section class="card">
      <h2>Simulation</h2>

      <canvas id="arena" width="600" height="300"></canvas>

      <p class="muted">
        Robot (green) starts below the black line ‚Üí seeks line ‚Üí
        follows the line. At each beige station it pauses
        ("please load the vehicle"). If there's a person in front,
        it waits ("you are in my way - please move").
        After station 3, it drives to the end and unloads.
      </p>

      <div class="tipbox">
        <strong>üí° Sensor tip:</strong><br>
        ‚Ä¢ Black line = low reflection (~10-20).<br>
        ‚Ä¢ Beige station = bright (~70+).<br>
        ‚Ä¢ Person = InfraredSensor(S2).distance() small (e.g. &lt;30 cm).<br>
        ‚Ä¢ After 3rd station, keep rolling to final drop zone and unload.
      </div>

      <pre id="output"></pre>
      <div id="error"></div>
    </section>
  </main>

  <!-- TIPS MODAL -->
  <dialog id="tips-modal">
    <div class="modal-header">Tips</div>
    <div class="modal-body">
      <ul>
        <li><code>ColorSensor(Port.S1).reflection()</code> ‚Üí 0..100 brightness.</li>
        <li><b>Seek line:</b> move slowly until reflection is very low (black tape).</li>
        <li><b>Follow line:</b> steering = (target - reflection) * KP (slow speeds!).</li>
        <li><b>Beige stop:</b> reflection really high ‚Üí stop ‚Üí "please load the vehicle".</li>
        <li><b>Person safety:</b> InfraredSensor(Port.S2).distance() &lt; 30 cm ‚Üí stop + ask to move.</li>
        <li>After 3rd stop ‚Üí final unload message at the end.</li>
      </ul>
    </div>
    <div class="modal-actions">
      <button class="btn" id="close-tips">Close</button>
    </div>
  </dialog>

  <!-- SOLUTION MODAL -->
  <dialog id="solution-modal">
    <div class="modal-header">Solution (slow EV3 code with IR safety)</div>
    <div class="modal-body">
<pre id="solution-code" style="white-space:pre-wrap;">#!/usr/bin/env pybricks-micropython
from pybricks.hubs import EV3Brick
from pybricks.ev3devices import Motor, ColorSensor, TouchSensor
from pybricks.parameters import Port, Stop
from pybricks.tools import wait
from pybricks.robotics import DriveBase

brick = EV3Brick()

# --- MOTORS / SENSORS ---
left   = Motor(Port.A)        # left drive motor
right  = Motor(Port.B)        # right drive motor
color  = ColorSensor(Port.S1) # line sensor (down-facing)
touch  = TouchSensor(Port.S3) # SAFETY STOP sensor (front bumper / human stop button)

drive = DriveBase(left, right, 56, 114)

brick.speaker.beep()
brick.screen.clear()
brick.screen.print("Warehouse mission start")
wait(500)

# --- TUNING (safe, slow, already proven to work) ---
DARK_TARGET        = 20     # ~ black line reflection (tune for your track)
KP                 = 1.0    # line-follow steering gain
SPEED_FWD          = 40     # mm/s forward while following
BEIGE_LIMIT        = 70     # reflection() > this => bright station marker
STATION_WAIT_MS    = 2000   # wait 2s at each station
ROLL_AWAY_MS       = 800    # roll a little bit forward after each stop

TOTAL_STOPS_TARGET = 4      # <-- we now want FOUR total stops
                            #     stops 1-3: "please load the vehicle"
                            #     stop 4:    final unload messages

FINAL_EXTRA_ROLL_MS = 0     # we do NOT need a long roll after stop 4,
                            # because stop 4 IS the "unload" zone now.

# -------------------------------------------------
# HELPER: safety pause for human touch
# called frequently in loops
# -------------------------------------------------
def check_safety_pause():
    if touch.pressed():
        drive.stop(Stop.BRAKE)
        brick.speaker.say("waiting for clearance")
        # stay here while the button is held down
        while touch.pressed():
            wait(50)
        brick.speaker.say("thank you")
        # after release, we just continue mission


# -------------------------------------------------
# STEP 1: SEEK THE BLACK LINE
# drive forward gently until we see dark (line)
# -------------------------------------------------
while color.reflection() > DARK_TARGET + 5:
    check_safety_pause()          # <-- NEW: respect touch while seeking
    drive.drive(30, 0)            # creep forward slowly
    wait(20)

drive.stop(Stop.BRAKE)
brick.speaker.say("line found")
wait(500)

# -------------------------------------------------
# STEP 2: FOLLOW LINE + HANDLE 4 STOPS
# stops 1-3 = load, stop 4 = unload & job done
# -------------------------------------------------
stops_done = 0

while stops_done < TOTAL_STOPS_TARGET:

    # always allow safety stop
    check_safety_pause()

    # --- basic P line following (same logic that works on your robot) ---
    ref   = color.reflection()
    error = DARK_TARGET - ref
    steer = error * KP
    drive.drive(SPEED_FWD, steer)

    # --- station detection ---
    # any bright / beige / white area: reflection jumps high
    if color.reflection() > BEIGE_LIMIT:
        # ARRIVED AT A STATION
        drive.stop(Stop.BRAKE)

        # is this the FINAL station (4th)?
        if stops_done == TOTAL_STOPS_TARGET - 1:
            # this is stop #4
            brick.speaker.say("please unload the car")
            wait(1000)
            brick.speaker.say("job done, ready for the next one")
            brick.speaker.beep()
            brick.screen.clear()
            brick.screen.print("mission done")
            wait(1000)

            # after final unload we BREAK the loop entirely
            stops_done += 1
            break

        # otherwise it's one of the first 3 load stations
        brick.speaker.say("please load the vehicle")
        wait(STATION_WAIT_MS)

        stops_done += 1

        # roll forward a tiny bit so we leave the bright mark
        drive.drive(SPEED_FWD, 0)
        wait(ROLL_AWAY_MS)
        drive.stop(Stop.BRAKE)

    wait(20)

# -------------------------------------------------
# END STATE
# robot stops. Mission finished.
# -------------------------------------------------
drive.stop(Stop.BRAKE)
</pre>
    </div>
    <div class="modal-actions">
      <button class="btn" id="copy-solution">Insert</button>
      <button class="btn" id="close-solution">Close</button>
    </div>
  </dialog>

  <script>
  const TASK = {
      taskId: 12,
    };

  // ===== DOM ELEMENTS =====
  const runBtn        = document.getElementById("run-btn");
  const resetBtn      = document.getElementById("reset-btn");
  const saveBtn       = document.getElementById("save-btn");
  const editorEl      = document.getElementById("editor");
  const statusEl      = document.getElementById("status");
  const outputEl      = document.getElementById("output");
  const errorEl       = document.getElementById("error");

  const canvasEl      = document.getElementById("arena");

  const tipsBtn       = document.getElementById("tips-btn");
  const tipsModal     = document.getElementById("tips-modal");
  const closeTips     = document.getElementById("close-tips");

  const solutionBtn   = document.getElementById("solution-btn");
  const solutionModal = document.getElementById("solution-modal");
  const copySolution  = document.getElementById("copy-solution");
  const closeSolution = document.getElementById("close-solution");

  function setStatus(cls, txt){
    statusEl.className = "status " + cls;
    statusEl.textContent = txt;
  }

  // ===== SIM SETTINGS =====
  // straight warehouse line
  const LINE_Y        = 200;     // y of transport line
  const START_X       = 80;      // robot start x (off line)
  const START_Y       = 235;     // robot start y (below the line)
  const START_HEADING = 0;       // initial heading used for drawing

  // beige "stations" x-positions
  const STATION_XS    = [200, 350, 500];

  // "person in front" zone for the simulation:
  // robot will pause here and complain
  const PERSON_X      = 280;
  const PERSON_TOL    = 15; // px range to trigger stop

  // end of route
  const LINE_END_X    = 560;

  // motion tuning for animation
  const SEEK_SPEED_PX        = 1.0;
  const FOLLOW_SPEED_PX      = 0.6;
  const KP_FOLLOW            = 0.06;
  const ROTATE_MAX_PER_FRAME = 2;
  const STOP_WAIT_FRAMES     = 60;   // ~1s pause at station in sim
  const PERSON_WAIT_FRAMES   = 60;   // ~1s "please move"
  const FINAL_ROLL_FRAMES    = 180;  // ~3s roll to end in sim

  let running = false;
  let simulationReady = false;

  // ===== WORLD STATE / CANVAS =====
  const ctx = canvasEl.getContext("2d");
  const deg2rad = d => d * Math.PI/180;

  const WORLD = {
    robot: { x: START_X, y: START_Y, heading: START_HEADING, r: 6 }
  };

  function drawWorld(label){
    // bg + border
    ctx.fillStyle="#fff";
    ctx.fillRect(0,0,canvasEl.width,canvasEl.height);

    ctx.strokeStyle="#111";
    ctx.lineWidth=2;
    ctx.strokeRect(0,0,canvasEl.width,canvasEl.height);

    // black transport line
    ctx.strokeStyle="#000";
    ctx.lineWidth=4;
    ctx.beginPath();
    ctx.moveTo(0, LINE_Y);
    ctx.lineTo(canvasEl.width, LINE_Y);
    ctx.stroke();

    // beige stations
    STATION_XS.forEach(xPos=>{
      ctx.strokeStyle="#e7e3c2";
      ctx.lineWidth=8;
      ctx.beginPath();
      ctx.moveTo(xPos, LINE_Y-20);
      ctx.lineTo(xPos, LINE_Y+20);
      ctx.stroke();
    });

    // "person" marker in lane (for the sim person-stop)
    ctx.fillStyle="#f97316";
    ctx.beginPath();
    ctx.arc(PERSON_X, LINE_Y-30, 4, 0, Math.PI*2);
    ctx.fill();
    ctx.fillStyle="#000";
    ctx.font="10px sans-serif";
    ctx.fillText("üö∂", PERSON_X-4, LINE_Y-34);

    // robot (green)
    const r = WORLD.robot;
    ctx.fillStyle="#16a34a";
    ctx.beginPath();
    ctx.arc(r.x, r.y, r.r, 0, Math.PI*2);
    ctx.fill();

    // heading arrow
    ctx.strokeStyle="#16a34a";
    ctx.lineWidth=2;
    ctx.beginPath();
    ctx.moveTo(r.x, r.y);
    ctx.lineTo(
      r.x + Math.cos(deg2rad(r.heading))*15,
      r.y + Math.sin(deg2rad(r.heading))*15
    );
    ctx.stroke();

    // label (can be multi-line "\n")
    if(label){
      ctx.fillStyle="#374151";
      ctx.font="12px sans-serif";
      const lines = label.split("\n");
      lines.forEach((L,i)=>{
        ctx.fillText(L, 10, 20 + i*14);
      });
    }
  }

  function resetWorld(){
    WORLD.robot.x = START_X;
    WORLD.robot.y = START_Y;
    WORLD.robot.heading = START_HEADING;
    drawWorld("ready (off the line)");
  }

  function stepForward(px){
    WORLD.robot.x += Math.cos(deg2rad(WORLD.robot.heading)) * px;
    WORLD.robot.y += Math.sin(deg2rad(WORLD.robot.heading)) * px;
  }

  function turnToward(targetDeg, maxStepDeg){
    let cur = WORLD.robot.heading;
    let diff = ((targetDeg - cur + 540) % 360) - 180;
    const step = Math.sign(diff) * Math.min(Math.abs(diff), maxStepDeg);
    WORLD.robot.heading = (cur + step + 360) % 360;
  }

  // SEEK PHASE: go straight up to the line
  function simSeekLine(){
    return new Promise(resolve=>{
      const goingUp = WORLD.robot.y > LINE_Y;
      WORLD.robot.heading = goingUp ? 270 : 90; // 270¬∞ = up

      function tick(){
        if(!running) return resolve();

        stepForward(SEEK_SPEED_PX);
        drawWorld("seeking line‚Ä¶");

        const closeEnough = Math.abs(WORLD.robot.y - LINE_Y) <= 1;
        const crossed = goingUp
          ? (WORLD.robot.y <= LINE_Y)
          : (WORLD.robot.y >= LINE_Y);

        if (closeEnough || crossed){
          WORLD.robot.y = LINE_Y;
          WORLD.robot.heading = 0; // face right along the line
          drawWorld("line found");
          resolve();
          return;
        }

        requestAnimationFrame(tick);
      }

      requestAnimationFrame(tick);
    });
  }

  // P-like follow step on straight line
  function gentleFollowStep(){
    const desiredHeading = 0;             // go right
    const errorY = LINE_Y - WORLD.robot.y;
    const correction = errorY * KP_FOLLOW;
    const targetHeading = desiredHeading + correction * 180;
    turnToward(targetHeading, ROTATE_MAX_PER_FRAME);
    stepForward(FOLLOW_SPEED_PX);
  }

  // person check in sim (near PERSON_X)
  function nearPerson(){
    return Math.abs(WORLD.robot.x - PERSON_X) < PERSON_TOL;
  }

  // follow line, stop at stations, also stop for person
  function simFollowStopsAndSafety(){
    return new Promise(resolve=>{
      let stationIndex = 0;
      let phase = "drive";
      let waitFrames = 0;

      function tick(){
        if(!running) return resolve();

        // done with all stations?
        if(stationIndex >= STATION_XS.length){
          resolve();
          return;
        }

        if(phase === "drive"){
          gentleFollowStep();

          // simulate IR safety stop
          if(nearPerson()){
            phase = "personWait";
            waitFrames = 0;
            drawWorld('you are in my way - please move');
            requestAnimationFrame(tick);
            return;
          }

          drawWorld(`to station ${stationIndex+1}`);

          // reached station?
          if(WORLD.robot.x >= STATION_XS[stationIndex]){
            phase = "stationWait";
            waitFrames = 0;
          }

          requestAnimationFrame(tick);
          return;
        }

        if(phase === "personWait"){
          drawWorld('you are in my way - please move');
          waitFrames++;
          if(waitFrames >= PERSON_WAIT_FRAMES){
            phase = "drive";
          }
          requestAnimationFrame(tick);
          return;
        }

        if(phase === "stationWait"){
          drawWorld(`station ${stationIndex+1}:\n"please load the vehicle"`);
          waitFrames++;
          if(waitFrames >= STOP_WAIT_FRAMES){
            stationIndex++;
            phase = "drive";
          }
          requestAnimationFrame(tick);
          return;
        }
      }

      requestAnimationFrame(tick);
    });
  }

  // after last station: roll to end & unload
  function simFinalRun(){
    return new Promise(resolve=>{
      let f = 0;
      function tick(){
        if(!running) return resolve();

        gentleFollowStep();
        drawWorld("final run‚Ä¶");

        if(WORLD.robot.x >= LINE_END_X){
          WORLD.robot.x = LINE_END_X;
          WORLD.robot.heading = 0;
          drawWorld('please unload the car\njob done, ready for the next one');
          resolve();
          return;
        }

        f++;
        if(f >= FINAL_ROLL_FRAMES){
          WORLD.robot.heading = 0;
          drawWorld('please unload the car\njob done, ready for the next one');
          resolve();
          return;
        }

        requestAnimationFrame(tick);
      }
      requestAnimationFrame(tick);
    });
  }

  // RUN button
  async function runMission(){
    if(!simulationReady){
      setStatus("error","ERROR");
      errorEl.textContent = "‚ö†Ô∏è Click 'Solution ‚Üí Insert' first!";
      return;
    }
    if(running) return;

    running = true;
    setStatus("running","running‚Ä¶");
    outputEl.textContent="";
    errorEl.textContent="";

    resetWorld();

    await simSeekLine();
    await simFollowStopsAndSafety();
    await simFinalRun();

    running = false;
    setStatus("ok","done.");
    outputEl.textContent =
      'Simulation: seek line ‚Üí 3√ó "please load the vehicle" (+ person safety) ‚Üí unload at end.';
  }

  // BUTTONS
  runBtn.onclick = runMission;

  resetBtn.onclick = ()=>{
    running = false;
    setStatus("","");
    outputEl.textContent="";
    errorEl.textContent="";
    resetWorld();
  };

  saveBtn.onclick = ()=>{
    const blob = new Blob([editorEl.value], {type:"text/plain"});
    const a = document.createElement("a");
    a.href = URL.createObjectURL(blob);
    a.download="main.py";
    a.click();
    URL.revokeObjectURL(a.href);
  };

  // tips modal
  tipsBtn.onclick = ()=>{
    if(tipsModal.showModal) tipsModal.showModal();
    else tipsModal.setAttribute("open","");
  };
  closeTips.onclick = ()=>{
    if(tipsModal.close) tipsModal.close();
    else tipsModal.removeAttribute("open","");
  };

  // solution modal
  solutionBtn.onclick = ()=>{
    if(solutionModal.showModal) solutionModal.showModal();
    else solutionModal.setAttribute("open","");
  };
  closeSolution.onclick = ()=>{
    if(solutionModal.close) solutionModal.close();
    else solutionModal.removeAttribute("open","");
  };

  // copy solution into editor ‚Üí unlock Run
  copySolution.onclick = ()=>{
    editorEl.value = document.getElementById("solution-code").textContent;
    simulationReady = true;

    if(solutionModal.close) solutionModal.close();
    else solutionModal.removeAttribute("open","");

    setStatus("ok","Ready to run");
    outputEl.textContent = "Solution code inserted. Press ‚ñ∂ Run.";
    errorEl.textContent  = "";
    resetWorld();
  };

  // init
  resetWorld();
  setStatus("","");
  </script>
</body>
</html>
