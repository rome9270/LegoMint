<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>EV3 (Pybricks) ‚Äì Drive a Figure-8</title>

  <link rel="stylesheet" href="../css/03_python.css" />

  <style>
    #arena { background:#f9fafb; border:2px solid #111; width:100%; height:auto; max-width:900px; border-radius:10px; display:block; margin-top:10px; }
    .status.ok { color:#15803d; }
    .status.error { color:#b91c1c; }
    .status.running { color:#374151; }
    .muted { color:#6b7280; }
  </style>
</head>
<body>
  <div class="nav-row">
    <a href="03_05LegoEV3.html" class="btn primary" id="next-btn">Next ‚Üí</a>
  </div>
<nav class="link-grid" aria-label="Topic selection">
  <a class="btn" href="../app/01_main.php" id="go-main" aria-label="Back to main">‚¨ÖÔ∏è Going to main
  <a class="btn" href="../app/logout.php">üö™ Logout</a>
  </a>
</nav>


  <header class="row" style="justify-content: space-between;">
    <div>
      <h1>EV3 (Pybricks) ¬∑ Drive a Figure-8</h1>
      <p>
        Write a correct <b>Pybricks</b> program (EV3Brick, motors A/B, <b>DriveBase</b>).<br>
        Use two loops to approximate a <b>figure-8</b> (first loop: turn +10¬∞, second loop: turn ‚àí10¬∞).<br>
        After both loops: <b>stop</b>, <b>beep</b>, and print something that includes <code>8</code> (or ‚Äúfigure eight‚Äù).
      </p>
    </div>
    <div class="row">
      <button class="btn" id="tips-btn">üí° Tips</button>
      <button class="btn" id="solution-btn">‚úÖ Solution</button>
    </div>
  </header>

  <main class="layout">
    <!-- Editor -->
    <section class="card">
      <h2>Editor</h2>
      <div class="row">
        <button class="btn primary" id="run-btn">‚ñ∂ Run</button>
        <button class="btn" id="reset-btn">‚ü≤ Reset</button>
        <button class="btn" id="save-btn">üíæ Save</button>
        <span id="status" class="status" aria-live="polite"></span>
      </div>

<textarea id="editor" spellcheck="false">#!/usr/bin/env pybricks-micropython
# EV3 (Pybricks) ‚Äì Starter (fill in the logic yourself)
from pybricks.hubs import EV3Brick
from pybricks.ev3devices import Motor
from pybricks.parameters import Port, Stop
from pybricks.tools import wait
from pybricks.robotics import DriveBase

# TODO (example structure):
# brick = EV3Brick()
# left  = Motor(Port.A)
# right = Motor(Port.B)
# drive = DriveBase(left, right, 56, 114)
#
# STEP_MM = 35
# for _ in range(36):
#     drive.straight(STEP_MM)
#     drive.turn(10)         # first loop: +10¬∞
# for _ in range(36):
#     drive.straight(STEP_MM)
#     drive.turn(-10)        # second loop: -10¬∞
#
# drive.stop(Stop.BRAKE)
# brick.speaker.beep()
# brick.screen.print("This is my figure 8")
# wait(500)
</textarea>
    </section>

    <!-- Simulation -->
    <section class="card">
      <h2>Simulation</h2>
      <canvas id="arena" width="600" height="300"></canvas>
      <p class="muted">Scale: <b>1 px = 1 cm</b> ¬∑ Start at (200, 180) facing right</p>
      <pre id="output"></pre>
      <div id="error" style="color:#b91c1c;"></div>
    </section>
  </main>

  <!-- Tips -->
  <dialog id="tips-modal">
    <div class="modal-header">Tips</div>
    <div class="modal-body">
      <ul id="tips-list"></ul>
    </div>
    <div class="modal-actions">
      <button class="btn" id="close-tips">Close</button>
    </div>
  </dialog>

  <!-- Solution -->
  <dialog id="solution-modal">
    <div class="modal-header">Solution (one example)</div>
    <div class="modal-body">
      <p class="muted" style="margin:0 0 8px 0;">There are many valid solutions. This is just one.</p>
<pre id="solution-code" style="white-space:pre-wrap;">#!/usr/bin/env pybricks-micropython
from pybricks.hubs import EV3Brick
from pybricks.ev3devices import Motor
from pybricks.parameters import Port, Stop
from pybricks.tools import wait
from pybricks.robotics import DriveBase

brick = EV3Brick()
left  = Motor(Port.A)
right = Motor(Port.B)

# Typical geometry (mm) ‚Äì adjust for your robot
WHEEL_DIAMETER = 56
AXLE_TRACK     = 114
drive = DriveBase(left, right, WHEEL_DIAMETER, AXLE_TRACK)

STEP_MM = 35
for _ in range(36):
    drive.straight(STEP_MM)
    drive.turn(10)

for _ in range(36):
    drive.straight(STEP_MM)
    drive.turn(-10)

drive.stop(Stop.BRAKE)
brick.speaker.beep()
brick.screen.print("This is my figure 8")
wait(500)
</pre>
    </div>
    <div class="modal-actions">
      <button class="btn" id="copy-solution">Insert</button>
      <button class="btn" id="close-solution">Close</button>
    </div>
  </dialog>

  <script>
    /* ---------- Tips ---------- */
    const TASK = {
      taskID: 4,
      tips: [
        "Use two loops: first arc with +10¬∞, second arc with -10¬∞.",
        "Keep steps small (e.g., STEP_MM = 35) for a smoother curve.",
        "After both loops: drive.stop(Stop.BRAKE), brick.speaker.beep(), brick.screen.print(\"...8...\").",
        "Adjust wheel diameter and axle track to your robot (56/114 mm are typical values)."
      ]
    };

    /* ---------- DOM ---------- */
    const els = {
      editor: document.getElementById("editor"),
      run: document.getElementById("run-btn"),
      reset: document.getElementById("reset-btn"),
      save: document.getElementById("save-btn"),
      output: document.getElementById("output"),
      error: document.getElementById("error"),
      status: document.getElementById("status"),
      canvas: document.getElementById("arena"),
      tipsBtn: document.getElementById("tips-btn"),
      tipsModal: document.getElementById("tips-modal"),
      tipsList: document.getElementById("tips-list"),
      closeTips: document.getElementById("close-tips"),
      solutionBtn: document.getElementById("solution-btn"),
      solutionModal: document.getElementById("solution-modal"),
      copySolution: document.getElementById("copy-solution"),
      closeSolution: document.getElementById("close-solution")
    };

    /* ---------- UI ---------- */
    els.tipsList.innerHTML = TASK.tips.map(t=>"<li>"+t+"</li>").join("");
    function setStatus(cls, txt){ els.status.className="status "+cls; els.status.textContent=txt; }
    function openDialog(d){ if(d?.showModal) d.showModal(); else d?.setAttribute("open",""); }
    function closeDialog(d){ if(d?.close) d.close(); else d?.removeAttribute("open"); }
    els.tipsBtn.onclick = () => openDialog(els.tipsModal);
    els.closeTips.onclick = () => closeDialog(els.tipsModal);
    els.solutionBtn.onclick = () => openDialog(els.solutionModal);
    els.closeSolution.onclick = () => closeDialog(els.solutionModal);
    els.copySolution.onclick = () => {
      els.editor.value = document.getElementById("solution-code").textContent;
      closeDialog(els.solutionModal);
      setStatus("", ""); els.output.textContent=""; els.error.textContent="";
    };

    /* ---------- STRICT VALIDATION (figure-8 task) ---------- */
    function validateFigure8Task(src){
      const errors = [];
      const code = src.replace(/\r/g,'');
      const lines = code.split('\n');

      // required imports
      [
        [/from\s+pybricks\.hubs\s+import\s+EV3Brick/, "Missing import EV3Brick"],
        [/from\s+pybricks\.ev3devices\s+import\s+.*\bMotor\b/, "Missing import Motor"],
        [/from\s+pybricks\.parameters\s+import\s+.*\bPort\b/, "Missing import Port"],
        [/from\s+pybricks\.parameters\s+import\s+.*\bStop\b/, "Missing import Stop"],
        [/from\s+pybricks\.tools\s+import\s+.*\bwait\b/, "Missing import wait"],
        [/from\s+pybricks\.robotics\s+import\s+.*\bDriveBase\b/, "Missing import DriveBase"]
      ].forEach(([re,msg])=>{ if(!re.test(code)) errors.push("‚úó "+msg); });

      // initializations (variable names are free)
      const brickM = code.match(/(\w+)\s*=\s*EV3Brick\s*\(\s*\)/);
      const leftM  = code.match(/(\w+)\s*=\s*Motor\s*\(\s*Port\.A\s*\)/);
      const rightM = code.match(/(\w+)\s*=\s*Motor\s*\(\s*Port\.B\s*\)/);
      const driveM = code.match(/(\w+)\s*=\s*DriveBase\s*\(/);
      if(!brickM) errors.push("‚úó EV3Brick not initialized");
      if(!leftM)  errors.push("‚úó Left motor (Port.A) missing");
      if(!rightM) errors.push("‚úó Right motor (Port.B) missing");
      if(!driveM) errors.push("‚úó DriveBase not created");
      const driveVar = driveM?.[1] || "drive";

      // constants/assignments
      const assigns = {};
      for(const L of lines){
        const m = L.match(/^\s*([A-Za-z_]\w*)\s*=\s*(-?\d+)\s*$/);
        if(m) assigns[m[1]] = parseInt(m[2],10);
      }

      // find first loop: range(36)
      function findLoop(startIdx){
        for(let i=startIdx;i<lines.length;i++){
          const m = lines[i].match(/^(\s*)for\s+\w+\s+in\s+range\s*\(\s*36\s*\)\s*:\s*$/);
          if(m) return { idx:i, indent:m[1]||"" };
        }
        return null;
      }

      const loop1 = findLoop(0);
      if(!loop1) errors.push("‚úó Missing first loop: for _ in range(36):");

      // inside a loop: straight + turn(¬±10). Returns {hasStraight, stepMm, turnOk}
      function scanLoop(loop){
        let hasStraight=false, stepMm=null, turnOk=false, endIdx=lines.length;
        if(!loop) return {hasStraight, stepMm, turnOk, endIdx};
        for(let j=loop.idx+1;j<lines.length;j++){
          const L=lines[j];
          if(L.trim()==="") continue;
          const indent=(L.match(/^(\s*)/)||["",""])[1];
          if(indent.length<=loop.indent.length){ endIdx=j; break; }

          const straightRe = new RegExp(`\\b${driveVar}\\s*\\.\\s*straight\\s*\\(\\s*([A-Za-z_]\\w*|\\d+)\\s*\\)`);
          const sm = L.match(straightRe);
          if(sm){
            hasStraight=true;
            const arg = sm[1];
            if(/^\d+$/.test(arg)) stepMm=parseInt(arg,10);
            else if(assigns[arg]!==undefined) stepMm=assigns[arg];
          }

          const turnRe = new RegExp(`\\b${driveVar}\\s*\\.\\s*turn\\s*\\(\\s*([A-Za-z_]\\w*|-?\\d+)\\s*\\)`);
          const tm = L.match(turnRe);
          if(tm){
            let ang=null; const arg=tm[1];
            if(/^-?\d+$/.test(arg)) ang=parseInt(arg,10);
            else if(assigns[arg]!==undefined) ang=assigns[arg];
            if(ang===10 || ang===-10) turnOk=true;
          }
        }
        return {hasStraight, stepMm, turnOk, endIdx};
      }

      const L1 = scanLoop(loop1);
      if(!L1.hasStraight) errors.push("‚úó First loop: missing drive.straight(mm)");
      if(!L1.turnOk)      errors.push("‚úó First loop: missing drive.turn(¬±10)");

      // second loop must exist after first loop
      const loop2 = findLoop((loop1?.idx ?? 0) + 1);
      if(!loop2) errors.push("‚úó Missing second loop: for _ in range(36):");

      const L2 = scanLoop(loop2);
      if(!L2.hasStraight) errors.push("‚úó Second loop: missing drive.straight(mm)");
      if(!L2.turnOk)      errors.push("‚úó Second loop: missing drive.turn(¬±10)");

      // step sanity (use the first detected step)
      const stepMm = L1.stepMm ?? L2.stepMm;
      if(!(Number.isFinite(stepMm) && stepMm >= 10 && stepMm <= 150)){
        errors.push("‚úó Step length should be 10‚Äì150 mm (via drive.straight(mm) or a constant)");
      }

      // turn directions: ideally + then ‚àí (or ‚àí then +)
      // We check signs if resolvable
      function loopTurnSign(loop){
        for(let j=loop.idx+1;j<lines.length;j++){
          const L=lines[j]; const indent=(L.match(/^(\s*)/)||["",""])[1];
          if(L.trim()!=="" && indent.length<=loop.indent.length) break;
          const tm = L.match(new RegExp(`\\b${driveVar}\\s*\\.\\s*turn\\s*\\(\\s*([A-Za-z_]\\w*|-?\\d+)\\s*\\)`));
          if(tm){
            let ang=null; const arg=tm[1];
            if(/^-?\d+$/.test(arg)) ang=parseInt(arg,10);
            else if(assigns[arg]!==undefined) ang=assigns[arg];
            if(ang!==null) return Math.sign(ang);
          }
        }
        return 0;
      }
      const s1 = loop1 ? loopTurnSign(loop1) : 0;
      const s2 = loop2 ? loopTurnSign(loop2) : 0;
      if(s1!==0 && s2!==0 && s1===s2){
        errors.push("‚úó Loops must turn in opposite directions (+10¬∞, then ‚àí10¬∞ or vice versa)");
      }

      // after the second loop: require stop + beep + screen print(...8...)
      let afterIdx = loop2 ? loop2.idx+1 : 0;
      if(loop2){
        // find end of loop2 block
        for(let j=loop2.idx+1;j<lines.length;j++){
          const L=lines[j];
          const indent=(L.match(/^(\s*)/)||["",""])[1];
          if(L.trim()!=="" && indent.length<=loop2.indent.length){ afterIdx=j; break; }
          if(j===lines.length-1) afterIdx=j+1;
        }
      }
      const afterCode = lines.slice(afterIdx).join("\n");
      if(!new RegExp(`\\b${(driveM?.[1]||"drive")}\\s*\\.\\s*stop\\s*\\(\\s*Stop\\.BRAKE\\s*\\)`).test(afterCode)){
        errors.push("‚úó Missing drive.stop(Stop.BRAKE) after the loops");
      }
      if(!/brick\s*\.speaker\s*\.beep\s*\(/.test(afterCode)) {
        errors.push("‚úó Missing brick.speaker.beep() after the loops");
      }
      if(!/(brick\s*\.screen\s*\.print\s*\(\s*["'][^"']*(8|figure\s*-?\s*8|figure\s*eight)[^"']*["']\s*\))/i.test(afterCode)) {
        errors.push('‚úó Missing brick.screen.print("‚Ä¶8‚Ä¶") (or ‚Äúfigure eight‚Äù) after the loops');
      }

      return { errors, stepMm: stepMm || 35, angle1: (s1>=0?10:-10), angle2: (s2<=0?-10:10) };
    }

    /* ---------- Arena / animation (1 px = 1 cm) ---------- */
    const ctx = els.canvas.getContext("2d");
    const WORLD = {
      W: els.canvas.width, H: els.canvas.height,
      robot: { x:200, y:180, heading:0, r:6 } // start at (200,180) facing right
    };
    let runToken=0;

    const rad=d=>d*Math.PI/180;
    function clear(){ ctx.fillStyle="#fff"; ctx.fillRect(0,0,WORLD.W,WORLD.H); ctx.strokeStyle="#111"; ctx.lineWidth=2; ctx.strokeRect(0,0,WORLD.W,WORLD.H); }
    function drawRobot(){
      const r=WORLD.robot;
      ctx.fillStyle="#16a34a";
      ctx.beginPath(); ctx.arc(r.x,r.y,r.r,0,2*Math.PI); ctx.fill();
      const hx=r.x+Math.cos(rad(r.heading))*(r.r+10);
      const hy=r.y+Math.sin(rad(r.heading))*(r.r+10);
      ctx.strokeStyle="#16a34a"; ctx.lineWidth=2;
      ctx.beginPath(); ctx.moveTo(r.x,r.y); ctx.lineTo(hx,hy); ctx.stroke();
    }
    function render(){ clear(); drawRobot(); }
    function resetWorld(){
      runToken++;
      WORLD.robot = { x:200, y:180, heading:0, r:6 };
      render();
    }

    // move straight with animation: mm ‚Üí px (1 cm/px ‚Üí mm/10)
    async function moveStraightMm(mm){
      const my=runToken; const r=WORLD.robot;
      const distPx = Math.max(0, mm)/10;  // mm ‚Üí cm(px)
      const step = 1; // 1 cm per frame
      const ux = Math.cos(rad(r.heading)), uy = Math.sin(rad(r.heading));
      let remaining = distPx;
      return new Promise(resolve=>{
        function tick(){
          if(my!==runToken) return resolve();
          const moved = Math.min(step, remaining);
          r.x += ux*moved; r.y += uy*moved;
          render();
          remaining -= moved;
          if(remaining>0) requestAnimationFrame(tick); else resolve();
        }
        requestAnimationFrame(tick);
      });
    }
    async function turnDeg(deg){
      const my=runToken; const r=WORLD.robot;
      const total = deg; const step = deg>0? 5 : -5;
      let done = 0;
      return new Promise(resolve=>{
        function tick(){
          if(my!==runToken) return resolve();
          const next = Math.abs(total-done) < Math.abs(step) ? (total-done) : step;
          r.heading = (r.heading + next + 360) % 360;
          done += next;
          render();
          if(done===total) resolve(); else requestAnimationFrame(tick);
        }
        requestAnimationFrame(tick);
      });
    }

    /* ---------- Run / Reset / Save ---------- */
    function setStatus(cls, txt){ els.status.className="status "+cls; els.status.textContent=txt; }
    function reset(){ setStatus("", ""); els.output.textContent=""; els.error.textContent=""; resetWorld(); }
    function save(){ const b=new Blob([els.editor.value],{type:"text/plain"}); const a=document.createElement("a"); a.href=URL.createObjectURL(b); a.download="main.py"; a.click(); URL.revokeObjectURL(a.href); }

    async function runCode(){
      els.error.textContent=""; els.output.textContent="";
      setStatus("running","checking‚Ä¶");

      const code=els.editor.value.trim();
      if(!code){
        setStatus("error","ERROR");
        els.output.textContent="Please write your Pybricks program first.";
        return;
      }

      const { errors, stepMm, angle1, angle2 } = validateFigure8Task(code);
      if(errors.length){
        setStatus("error","ERROR");
        els.output.textContent = "Please fix first:\n" + errors.join("\n");
        return;
      }

      setStatus("running","running‚Ä¶");
      resetWorld();
      try{
        for(let i=0;i<36;i++){
          await moveStraightMm(stepMm);
          await turnDeg(angle1);
        }
        for(let i=0;i<36;i++){
          await moveStraightMm(stepMm);
          await turnDeg(angle2);
        }
        setStatus("ok","done.");
        els.output.textContent = `Figure-8 completed (~2 √ó 36 steps √ó ${stepMm} mm; turns ${angle1}¬∞ and ${angle2}¬∞).`;
      }catch(e){
        setStatus("error","ERROR");
        els.error.textContent = String(e);
      }
    }

    els.run.onclick = runCode;
    els.reset.onclick = reset;
    els.save.onclick = save;

    render();

    document.getElementById("back-btn").onclick = () => history.back();
 </script>
</body>
</html>
