<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>EV3 - find the door (touch & gyro)</title>

  <link rel="stylesheet" href="../css/03_python.css" />

  <style>
    #arena {
      background:#f9fafb;
      border:2px solid #111;
      width:100%;
      height:240px;
      max-width:900px;
      border-radius:10px;
      display:block;
      margin-top:10px;
    }
    .status.ok { color:#15803d; }
    .status.error { color:#b91c1c; }
    .status.running { color:#374151; }
    .muted { color:#6b7280; }
    #error { color:#b91c1c; white-space:pre-wrap; }
  </style>
</head>
<body>
  <!--  NAVIGATION -->
  <nav class="link-grid" aria-label="Topic selection">
    <a class="btn" href="../app/01_main.php" id="go-main" aria-label="Back to main">‚¨ÖÔ∏è Going to main</a>
    <a class="btn" href="../app/logout.php">üö™ Logout</a>
    <a class="btn primary" id="next-btn" href="../html/03_08LegoEV3_I.html">Next ‚Üí</a>
  </nav>

  <header class="row" style="justify-content: space-between;">
    <div>
      <h1>EV3 (Pybricks) ¬∑ Touch + Gyro ‚Äî Bump 2 walls & leave the building</h1>
      <p>
        Write a correct <b>Pybricks program</b> (EV3Brick, motors A/B,
        <b>Touch S3</b>, <b>Gyro S4</b>) that
        <b>drives upward and bumps the top wall</b>,
        <b>backs ~50&nbsp;mm</b>,
        then <b>rotates RIGHT by 90¬∞ using the gyroscope</b>,
        <b>bumps the right wall</b>,
        <b>backs ~50&nbsp;mm</b>,
        <b>rotates RIGHT by 90¬∞ using the gyroscope</b> again,
        and finally
        <b>exits the building</b> through the door on the bottom wall (right side).<br>
        Use a gyro feedback loop (e.g.
        <code>gyro.reset_angle(0)</code> then
        <code>while abs(gyro.angle()) &lt; 90: ...</code>).
        <b>Do not use <code>drive.turn(...)</code>.</b>
      </p>
    </div>
    <div class="row">
      <button class="btn" id="tips-btn">üí° Tips</button>
      <button class="btn" id="solution-btn">‚úÖ Solution</button>
    </div>
  </header>

  <main class="layout">
    <!-- EDITOR -->
    <section class="card">
      <h2>Editor</h2>
      <div class="row">
        <button class="btn primary" id="run-btn">‚ñ∂ Run</button>
        <button class="btn" id="reset-btn">‚ü≤ Reset</button>
        <button class="btn" id="save-btn">üíæ Save</button>
        <span id="status" class="status" aria-live="polite"></span>
      </div>

<textarea id="editor" spellcheck="false">#!/usr/bin/env pybricks-micropython
# Touch + Gyro task: bump top ‚Üí back ‚Üí gyro-right 90;
# bump right ‚Üí back ‚Üí gyro-right 90; exit bottom-right door

from pybricks.hubs import EV3Brick
from pybricks.ev3devices import Motor, TouchSensor, GyroSensor
from pybricks.parameters import Port, Stop
from pybricks.tools import wait
from pybricks.robotics import DriveBase

# Initialize
brick = EV3Brick()
left  = Motor(Port.A)
right = Motor(Port.B)
touch = TouchSensor(Port.S3)
gyro  = GyroSensor(Port.S4)           # <-- Gyro on S4
drive = DriveBase(left, right, 56, 114)

# 1) Up to top wall
drive.drive(150, 0)
while not touch.pressed():
    wait(10)
drive.stop(Stop.BRAKE)
drive.straight(-50)

# Gyro right turn ~90¬∞
gyro.reset_angle(0)
drive.drive(0, -90)               # rotate in place to the right
while abs(gyro.angle()) < 90:
    wait(10)
drive.stop(Stop.BRAKE)

# 2) Right to right wall
drive.drive(150, 0)
while not touch.pressed():
    wait(10)
drive.stop(Stop.BRAKE)
drive.straight(-50)

# Gyro right turn again ~90¬∞ to face downward
gyro.reset_angle(0)
drive.drive(0, -90)
while abs(gyro.angle()) < 90:
    wait(10)
drive.stop(Stop.BRAKE)

# 3) Leave the building (downwards through the bottom-right door)
drive.drive(150, 0)
wait(1200)  # adjust if needed on the real robot
drive.stop(Stop.BRAKE)
brick.speaker.beep()
brick.screen.print("door found!")
</textarea>
    </section>

    <!-- SIMULATION -->
    <section class="card">
      <h2>Simulation</h2>
      <canvas id="arena" width="640" height="240"></canvas>
      <p class="muted">
        Scale: <b>1 px = 1 cm</b> ¬∑ Room walls at left x=40, top y=40, right x=600, bottom y=200 ¬∑
        Door in bottom wall: <b>x=560‚Äì600</b> (right side). Start at (120, 120), facing up.
      </p>
      <pre id="output"></pre>
      <div id="error"></div>
    </section>
  </main>

  <!-- Tips Modal -->
  <dialog id="tips-modal">
    <div class="modal-header">Tips</div>
    <div class="modal-body">
      <ul id="tips-list"></ul>
    </div>
    <div class="modal-actions">
      <button class="btn" id="close-tips">Close</button>
    </div>
  </dialog>

  <!-- Solution Modal -->
  <dialog id="solution-modal">
    <div class="modal-header">Solution (one example)</div>
    <div class="modal-body">
<pre id="solution-code" style="white-space:pre-wrap;">#!/usr/bin/env pybricks-micropython
from pybricks.hubs import EV3Brick
from pybricks.ev3devices import Motor, TouchSensor, GyroSensor
from pybricks.parameters import Port, Stop
from pybricks.tools import wait
from pybricks.robotics import DriveBase

brick = EV3Brick()
left  = Motor(Port.A)
right = Motor(Port.B)
touch = TouchSensor(Port.S3)
gyro  = GyroSensor(Port.S4)
drive = DriveBase(left, right, 56, 114)

# 1) Up to top wall
drive.drive(150, 0)
while not touch.pressed():
    wait(10)
drive.stop(Stop.BRAKE)
drive.straight(-50)

# Gyro right turn ~90¬∞
gyro.reset_angle(0)
drive.drive(0, -90)            # rotate to the right using gyro feedback
while abs(gyro.angle()) < 90:
    wait(10)
drive.stop(Stop.BRAKE)

# 2) Right to right wall
drive.drive(150, 0)
while not touch.pressed():
    wait(10)
drive.stop(Stop.BRAKE)
drive.straight(-50)

# Gyro right turn again ~90¬∞ to face downward
gyro.reset_angle(0)
drive.drive(0, -90)
while abs(gyro.angle()) < 90:
    wait(10)
drive.stop(Stop.BRAKE)

# 3) Leave the building (downwards through right-side door)
drive.drive(150, 0)
wait(1200)
drive.stop(Stop.BRAKE)
brick.speaker.beep()
brick.screen.print("door found!")
</pre>
    </div>
    <div class="modal-actions">
      <button class="btn" id="copy-solution">Insert</button>
      <button class="btn" id="close-solution">Close</button>
    </div>
  </dialog>

  <script>
    /* ---------- Task metadata / Tips ---------- */
    const TASK = {
      taskId: 7,
      tips: [
        'Touch sensor front: <code>touch = TouchSensor(Port.S3)</code> then <code>touch.pressed()</code>.',
        'Gyro on S4: <code>gyro = GyroSensor(Port.S4)</code>.',
        'Before each rotation: <code>gyro.reset_angle(0)</code>.',
        'Rotate in place to the RIGHT: <code>drive.drive(0, -90)</code> while <code>abs(gyro.angle()) &lt; 90</code>.',
        'After each bump: back off with <code>drive.straight(-50)</code>.',
        'Do NOT use <code>drive.turn(...)</code> in this mission.',
        'At the end, exit through the bottom-right ‚Äúdoor‚Äù, then beep and print a message.'
      ]
    };

    /* ---------- DOM refs ---------- */
    const els = {
      editor: document.getElementById("editor"),
      run: document.getElementById("run-btn"),
      reset: document.getElementById("reset-btn"),
      save: document.getElementById("save-btn"),
      output: document.getElementById("output"),
      error: document.getElementById("error"),
      status: document.getElementById("status"),
      canvas: document.getElementById("arena"),
      tipsBtn: document.getElementById("tips-btn"),
      tipsModal: document.getElementById("tips-modal"),
      tipsList: document.getElementById("tips-list"),
      closeTips: document.getElementById("close-tips"),
      solutionBtn: document.getElementById("solution-btn"),
      solutionModal: document.getElementById("solution-modal"),
      copySolution: document.getElementById("copy-solution"),
      closeSolution: document.getElementById("close-solution"),
    };

    /* ---------- Status + Modals ---------- */
    function setStatus(cls, txt){
      els.status.className = "status "+(cls||"");
      els.status.textContent = txt||"";
    }
    function openDialog(d){
      if(!d) return;
      if(d.showModal) d.showModal();
      else d.setAttribute("open","");
    }
    function closeDialog(d){
      if(!d) return;
      if(d.close) d.close();
      else d.removeAttribute("open");
    }

    els.tipsList.innerHTML = TASK.tips.map(t=>"<li>"+t+"</li>").join("");

    els.tipsBtn.onclick = ()=>openDialog(els.tipsModal);
    els.closeTips.onclick = ()=>closeDialog(els.tipsModal);

    els.solutionBtn.onclick = ()=>openDialog(els.solutionModal);
    els.closeSolution.onclick = ()=>closeDialog(els.solutionModal);
    els.copySolution.onclick = ()=>{
      els.editor.value = document.getElementById("solution-code").textContent;
      closeDialog(els.solutionModal);
      els.output.textContent="";
      els.error.textContent="";
      setStatus("ok","Solution inserted. You can run now.");
    };

    /* ---------- Server-Progress melden ---------- */
    function sendEvent(ev){
      fetch("../app/event_update.php", {
        method: "POST",
        credentials: "include",
        headers: { "Content-Type": "application/x-www-form-urlencoded" },
        body: new URLSearchParams({
          task_id: String(TASK.taskId),
          event: ev
        })
      })
      .then(r => r.json())
      .then(data => {
        console.log("Server response:", data);
      })
      .catch(err => {
        console.warn("sendEvent failed:", err);
      });
    }

    /* ---------- Strip comments from Python ---------- */
    function stripComments(src){
      let x = src.replace(/^[ \t]*#.*$/gm, "");
      x = x.replace(/[ \t]+#.*$/gm, "");
      return x;
    }

    /* ---------- Strict validation (Touch + Gyro) ---------- */
    function validate(src){
      els.output.textContent="";
      els.error.textContent="";
      const raw = src.replace(/\r/g,"");
      const code = stripComments(raw);
      const lines = code.split("\n");
      const errors = [];

      if(code.trim()===""){
        errors.push("Please write your Pybricks program first.");
        return {ok:false, errors, backMm:50};
      }

      // Required imports
      [
        [/from\s+pybricks\.hubs\s+import\s+EV3Brick/, "Missing import: EV3Brick"],
        [/from\s+pybricks\.ev3devices\s+import\s+.*\bMotor\b/, "Missing import: Motor"],
        [/from\s+pybricks\.ev3devices\s+import\s+.*\bTouchSensor\b/, "Missing import: TouchSensor"],
        [/from\s+pybricks\.ev3devices\s+import\s+.*\bGyroSensor\b/, "Missing import: GyroSensor"],
        [/from\s+pybricks\.parameters\s+import\s+.*\bPort\b/, "Missing import: Port"],
        [/from\s+pybricks\.parameters\s+import\s+.*\bStop\b/, "Missing import: Stop"],
        [/from\s+pybricks\.tools\s+import\s+.*\bwait\b/, "Missing import: wait"],
        [/from\s+pybricks\.robotics\s+import\s+.*\bDriveBase\b/, "Missing import: DriveBase"]
      ].forEach(([re,msg])=>{
        if(!re.test(code)) errors.push("‚úó "+msg);
      });

      // Inits / wiring
      const leftM  = code.match(/\b(\w+)\s*=\s*Motor\s*\(\s*Port\.A\s*\)/);
      const rightM = code.match(/\b(\w+)\s*=\s*Motor\s*\(\s*Port\.B\s*\)/);
      const touchM = code.match(/\b(\w+)\s*=\s*TouchSensor\s*\(\s*Port\.S3\s*\)/);
      const gyroM  = code.match(/\b(\w+)\s*=\s*GyroSensor\s*\(\s*Port\.S4\s*\)/);
      const driveM = code.match(/\b(\w+)\s*=\s*DriveBase\s*\(/);

      if(!/EV3Brick\s*\(\s*\)/.test(code)) errors.push("‚úó EV3Brick not initialized");
      if(!leftM)  errors.push("‚úó Left motor (Port.A) missing");
      if(!rightM) errors.push("‚úó Right motor (Port.B) missing");
      if(!touchM) errors.push("‚úó TouchSensor on S3 missing");
      if(!gyroM)  errors.push("‚úó GyroSensor on S4 missing");
      if(!driveM) errors.push("‚úó DriveBase not created");

      const driveVar = driveM?.[1] || "drive";
      const touchVar = touchM?.[1] || "touch";
      const gyroVar  = gyroM?.[1] || "gyro";

      // Loop to top wall & right wall: while not touch.pressed()
      const touchLoopRE = new RegExp(
        `^([ \\t]*)while\\s+not\\s+${touchVar}\\s*\\.\\s*pressed\\s*\\(\\s*\\)\\s*:\\s*$`
      );
      const loopIdx = [];
      for(let i=0;i<lines.length;i++){
        if(lines[i].match(touchLoopRE)) loopIdx.push(i);
      }
      if(loopIdx.length < 2){
        errors.push("‚úó Need two loops: while not touch.pressed(): (top wall and right wall)");
      }

      // drive.drive(150,0) before those loops
      const driveStartRe = new RegExp(
        `\\b${driveVar}\\s*\\.\\s*drive\\s*\\(\\s*\\d+\\s*,\\s*0\\s*\\)`
      );
      if(!driveStartRe.test(code)){
        errors.push("‚úó Missing drive.drive(150, 0) before the touch loops");
      }

      // wait(...) inside each touch loop
      for(const idx of loopIdx){
        let hasWait=false;
        const indent=(lines[idx].match(/^([ \t]*)/)||["",""])[1];
        for(let j=idx+1;j<lines.length;j++){
          const L=lines[j];
          if(L.trim()==="") continue;
          const ind=(L.match(/^([ \t]*)/)||["",""])[1];
          if(ind.length<=indent.length) break;
          if(/\bwait\s*\(/.test(L)){ hasWait=true; break; }
        }
        if(!hasWait){
          errors.push("‚úó Missing wait(...) inside while not touch.pressed(): loop");
          break;
        }
      }

      // must NOT use drive.turn(...)
      if(/\bdrive\s*\.\s*turn\s*\(/.test(code)){
        errors.push("‚úó Do NOT use drive.turn(...). Use gyro control instead.");
      }

      // gyro part: need at least two loops that watch gyro.angle() vs 90
      // e.g. while abs(gyro.angle()) < 90:
      const gyroWhileRE = new RegExp(
        `^\\s*while\\s+.*${gyroVar}\\s*\\.\\s*angle\\s*\\(\\s*\\).*90\\s*[:)]`,
        "i"
      );
      let gyroLoops = 0;
      for(const L of lines){
        if(gyroWhileRE.test(L)) gyroLoops++;
      }
      if(gyroLoops < 2){
        errors.push("‚úó Need two gyro loops (while abs(gyro.angle()) < 90: ...)");
      }

      // rotation actuation: drive.drive(0, -90) or opposite motor runs
      const hasDriveOmega =
        new RegExp(`\\b${driveVar}\\s*\\.\\s*drive\\s*\\(\\s*0\\s*,\\s*-?\\d+\\s*\\)`).test(code);
      const hasOppMotors =
        /\bleft\s*\.run\s*\(\s*-?\d+\s*\)[\s\S]*\bright\s*\.run\s*\(\s*-\s*\d+\s*\)/.test(code) ||
        /\bright\s*\.run\s*\(\s*-?\d+\s*\)[\s\S]*\bleft\s*\.run\s*\(\s*-\s*\d+\s*\)/.test(code);
      if(!(hasDriveOmega || hasOppMotors)){
        errors.push("‚úó Rotate using drive.drive(0, ¬±œâ) or opposite motor.run(...) while checking gyro");
      }

      // stop after rotations
      const stopRe = new RegExp(
        `\\b${driveVar}\\s*\\.\\s*stop\\s*\\(\\s*Stop\\.BRAKE\\s*\\)`
      );
      if(!stopRe.test(code)){
        errors.push("‚úó Missing drive.stop(Stop.BRAKE) after rotations");
      }

      // must back off twice with drive.straight(-N)
      const backMatches = code.match(
        new RegExp(`\\b${driveVar}\\s*\\.\\s*straight\\s*\\(\\s*-(\\d+)\\s*\\)`, "g")
      );
      if(!(backMatches && backMatches.length>=2)){
        errors.push("‚úó Need two backups: drive.straight(-50) (30‚Äì200 mm ok)");
      }

      // final beep + screen.print(...)
      if(!/brick\s*\.\s*speaker\s*\.\s*beep\s*\(\s*\)/.test(code)){
        errors.push("‚úó Missing brick.speaker.beep() at the end");
      }
      if(!/brick\s*\.\s*screen\s*\.\s*print\s*\(/.test(code)){
        errors.push("‚úó Missing brick.screen.print(...) at the end");
      }

      // backMm param for sim (take first backup distance)
      let backMm = 50;
      if(backMatches){
        const first = /-(\d+)/.exec(backMatches[0]);
        const mm = first ? parseInt(first[1],10) : 50;
        if(Number.isFinite(mm)){
          backMm = Math.min(200, Math.max(30, mm));
        }
      }

      return { ok: errors.length===0, errors, backMm };
    }

    /* ---------- Canvas / simulation ---------- */
    const ctx2 = els.canvas.getContext("2d");
    const WORLD = {
      W: els.canvas.width,
      H: els.canvas.height,
      walls: {
        left:   { type:'v', x:40,  y1:40,  y2:200 },
        top:    { type:'h', y:40,  x1:40,  x2:600 },
        right:  { type:'v', x:600, y1:40,  y2:200 },
        bottom1:{ type:'h', y:200, x1:40,  x2:560 }, // solid segment
        // gap 560..600 is door
      },
      robot: { x:120, y:120, heading:90, r:6 } // start up-facing
    };
    let runToken = 0;
    const rad = d => d*Math.PI/180;

    function clear(){
      ctx2.fillStyle="#fff";
      ctx2.fillRect(0,0,WORLD.W,WORLD.H);
      ctx2.strokeStyle="#111";
      ctx2.lineWidth=2;
      ctx2.strokeRect(0,0,WORLD.W,WORLD.H);
    }
    function drawWalls(){
      ctx2.strokeStyle="#111";
      ctx2.lineWidth=4;
      const w = WORLD.walls;
      // top
      ctx2.beginPath();
      ctx2.moveTo(w.top.x1||40, w.top.y);
      ctx2.lineTo(w.top.x2||600, w.top.y);
      ctx2.stroke();
      // left
      ctx2.beginPath();
      ctx2.moveTo(w.left.x, w.left.y1);
      ctx2.lineTo(w.left.x, w.left.y2);
      ctx2.stroke();
      // right
      ctx2.beginPath();
      ctx2.moveTo(w.right.x, w.right.y1);
      ctx2.lineTo(w.right.x, w.right.y2);
      ctx2.stroke();
      // bottom (left segment)
      ctx2.beginPath();
      ctx2.moveTo(w.bottom1.x1, w.bottom1.y);
      ctx2.lineTo(w.bottom1.x2, w.bottom1.y);
      ctx2.stroke();
      // dashed door hint
      ctx2.setLineDash([6,6]);
      ctx2.strokeStyle="#9ca3af";
      ctx2.beginPath();
      ctx2.moveTo(560, 200);
      ctx2.lineTo(600, 200);
      ctx2.stroke();
      ctx2.setLineDash([]);
      ctx2.strokeStyle="#111";
    }
    function drawRobot(){
      const r=WORLD.robot;
      ctx2.fillStyle="#16a34a";
      ctx2.beginPath();
      ctx2.arc(r.x,r.y,r.r,0,2*Math.PI);
      ctx2.fill();
      const hx=r.x+Math.cos(rad(r.heading))*(r.r+12);
      const hy=r.y+Math.sin(rad(r.heading))*(r.r+12);
      ctx2.strokeStyle="#16a34a";
      ctx2.lineWidth=2;
      ctx2.beginPath();
      ctx2.moveTo(r.x,r.y);
      ctx2.lineTo(hx,hy);
      ctx2.stroke();
    }
    function render(){
      clear(); drawWalls(); drawRobot();
    }
    function resetWorld(){
      runToken++;
      WORLD.robot={x:120,y:120,heading:90,r:6};
      render();
    }

    function contactTopWall(nextY){
      const r=WORLD.robot;
      return (r.heading%360===90 && r.y>40 && nextY <= 40 + r.r);
    }
    function contactRightWall(nextX){
      const r=WORLD.robot;
      return (r.heading%360===0 && r.x<600 && nextX >= 600 - r.r);
    }

    async function forwardUntilTop(){
      const my=++runToken;
      const r=WORLD.robot;
      const step=1;
      return new Promise(resolve=>{
        function tick(){
          if(my!==runToken) return resolve();
          const nx=r.x, ny=r.y - step;
          if(contactTopWall(ny)){
            r.y = 40 + r.r;
            render();
            return resolve();
          }
          r.x=nx; r.y=ny;
          render();
          requestAnimationFrame(tick);
        }
        requestAnimationFrame(tick);
      });
    }

    async function forwardUntilRight(){
      const my=runToken;
      const r=WORLD.robot;
      const step=1;
      return new Promise(resolve=>{
        function tick(){
          if(my!==runToken) return resolve();
          const nx=r.x + step, ny=r.y;
          if(contactRightWall(nx)){
            r.x = 600 - r.r;
            render();
            return resolve();
          }
          r.x=nx; r.y=ny;
          render();
          requestAnimationFrame(tick);
        }
        requestAnimationFrame(tick);
      });
    }

    async function straightPx(deltaPx){
      const my=runToken;
      const r=WORLD.robot;
      const step = deltaPx>=0 ? 1 : -1;
      let remain = Math.abs(deltaPx);
      return new Promise(resolve=>{
        function tick(){
          if(my!==runToken) return resolve();
          const mv = Math.min(1, remain);
          r.x += Math.cos(rad(r.heading)) * step * mv;
          r.y += Math.sin(rad(r.heading)) * step * mv;
          render();
          remain -= mv;
          if(remain>0) requestAnimationFrame(tick); else resolve();
        }
        requestAnimationFrame(tick);
      });
    }

    async function turnBy(deg){
      const my=runToken;
      const r=WORLD.robot;
      const total = Math.abs(deg);
      const sign = deg>=0 ? 1 : -1;
      const step=3*sign;
      let turned=0;
      return new Promise(resolve=>{
        function tick(){
          if(my!==runToken) return resolve();
          const d = Math.min(3, total-turned)*sign;
          r.heading = (r.heading + d + 360)%360;
          turned += Math.abs(d);
          render();
          if(turned<total) requestAnimationFrame(tick); else resolve();
        }
        requestAnimationFrame(tick);
      });
    }

    async function forwardOutDoor(){
      const my=runToken;
      const r=WORLD.robot;
      const step=1;
      return new Promise(resolve=>{
        function tick(){
          if(my!==runToken) return resolve();

          const nx = r.x + Math.cos(rad(r.heading))*step;
          const ny = r.y + Math.sin(rad(r.heading))*step;

          // bottom wall except door (560..600)
          if(r.heading%360===270){
            const doorL=560, doorR=600, bottom=200;
            const inDoor = (r.x >= doorL) && (r.x <= doorR);
            if(!inDoor && r.y < bottom && ny >= bottom - r.r){
              r.y = bottom - r.r;
              render();
              throw new Error("Hit bottom wall (not at door). Adjust turns in your code.");
            }
            if(inDoor && r.y < bottom && ny >= bottom + r.r){
              r.y = bottom + r.r;
              render();
              return resolve();
            }
          }

          r.x = nx; r.y = ny;
          render();
          if(r.y > 210) return resolve();
          requestAnimationFrame(tick);
        }
        requestAnimationFrame(tick);
      });
    }

    /* ---------- Run / Reset / Save + Server Update ---------- */
    function reset(){
      setStatus("","");
      els.output.textContent="";
      els.error.textContent="";
      resetWorld();
    }

    function save(){
      const b = new Blob([els.editor.value], {type:"text/plain"});
      const a = document.createElement("a");
      a.href = URL.createObjectURL(b);
      a.download="main.py";
      a.click();
      URL.revokeObjectURL(a.href);

      // Fortschritt melden: Datei gespeichert
      sendEvent("download");
    }

    async function runCode(){
      els.output.textContent="";
      els.error.textContent="";

      const raw = els.editor.value;
      const codeNoComments = stripComments(raw).trim();
      if(!codeNoComments){
        setStatus("error","ERROR");
        els.output.textContent = "Please write your Pybricks program first.";
        return;
      }

      setStatus("running","checking‚Ä¶");
      const { ok, errors, backMm } = validate(raw);

      if(!ok){
        setStatus("error","ERROR");
        els.output.textContent = "Please fix first:\n" + errors.join("\n");
        return;
      }

      // Code scheint g√ºltig ‚Üí Simulation fahren
      setStatus("running","running‚Ä¶");
      resetWorld();
      try{
        await forwardUntilTop();
        await straightPx(-(backMm/10));   // mm -> cm(px)
        await turnBy(-90);                // Gyro-right ~90¬∞

        await forwardUntilRight();
        await straightPx(-(backMm/10));
        await turnBy(-90);                // again right -> facing down

        await forwardOutDoor();

        setStatus("ok","done.");
        els.output.textContent =
          `Simulated: bump top, back ${backMm} mm, gyro-turn ‚Üí bump right, back ${backMm} mm, gyro-turn ‚Üí exit door.`;

        // Fortschritt melden: Simulation erfolgreich
        sendEvent("sim");

      }catch(e){
        setStatus("error","ERROR");
        els.error.textContent = String(e.message || e);
      }
    }

    els.run.onclick = runCode;
    els.reset.onclick = reset;
    els.save.onclick = save;

    // initial draw
    resetWorld();
    setStatus("","");

    // next button just goes to next page as given in nav
    // (kein alert override mehr)
  </script>
</body>
</html>
