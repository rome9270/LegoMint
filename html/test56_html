<!doctype html>
<html lang="de">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>EV3 Template ‚Äì A4/A5/A6 mit Hindernis-Schalter</title>

<style>
/* ===== Dein Grund-CSS (mit kleinem padding-Bugfix) ===== */
body{font-family:Arial,sans-serif;text-align:center;padding:60px}
h1{margin-bottom:30px}
p{margin-bottom:30px}
hr{margin:40px 0}

.link-grid{display:grid!important;grid-template-columns:repeat(auto-fit,minmax(260px,1fr));gap:24px;padding:20px 24px;background:#fff;margin-top:40px}
.link-grid>button.topic,.link-grid>a.topic{display:block;width:100%;margin:0;text-align:center;padding:18px 24px;border-radius:24px;background:#3fb257;color:#fff;font-weight:700}
.level-grid{display:flex;flex-wrap:wrap;justify-content:center;column-gap:16px;row-gap:16px;margin-top:20px}
.level-btn{display:inline-block;width:260px;padding:18px 28px;font-size:20px;font-weight:700;color:#fff;background:#4CAF50;border-radius:12px;text-decoration:none;text-align:center;transition:background-color .3s,transform .2s;cursor:pointer;border:none}
.level-btn:hover{background:#45a049;transform:translateY(-3px)}
@media (max-width:640px){body{padding:32px 16px}.level-btn{width:100%;max-width:360px}}

main{max-width:1100px;margin:0 auto}
.card{background:#fff;border:1px solid #e7e7e7;border-radius:16px;padding:18px;text-align:left;box-shadow:0 6px 24px rgba(0,0,0,.06)}
.card h2{margin:0 0 10px}
.small,.status{color:#666;font-size:14px}
.row{display:flex;gap:12px;align-items:center;flex-wrap:wrap}
textarea{width:100%;min-height:280px;border:1px solid #ddd;border-radius:12px;padding:14px;font:14px/1.45 Consolas,ui-monospace,Menlo,Monaco,"Liberation Mono",monospace}
pre{margin:0;padding:12px;min-height:140px;background:#f7f7f7;border:1px solid #e7e7e7;border-radius:12px;white-space:pre-wrap;word-break:break-word}
.result{font-weight:700}.ok{color:#2e7d32}.fail{color:#c62828}

/* Simulator */
.sim-wrap{margin-top:14px}
#sim{width:100%;height:400px;display:block;background:#fff;border:1px solid #e7e7e7;border-radius:12px}
.sim-legend{margin-top:6px;font-size:13px;color:#666}
.badge{font-size:12px;color:#555;background:#f3f5f7;border:1px solid #e5e7eb;border-radius:10px;padding:4px 8px;margin-left:auto}

/* Regler */
.controls{display:grid;grid-template-columns:repeat(auto-fit,minmax(220px,1fr));gap:12px;margin:12px 0}
.ctrl{background:#fff;border:1px solid #e7e7e7;border-radius:12px;padding:10px}
.ctrl label{display:block;font-size:14px;color:#333;margin-bottom:6px}
.ctrl output{font-weight:700}

/* Kleiner Toggle */
.toggle{display:inline-flex;align-items:center;gap:10px}
.toggle input{width:42px;height:24px;appearance:none;background:#d1d5db;border-radius:999px;position:relative;outline:none;cursor:pointer;transition:.2s}
.toggle input:checked{background:#22c55e}
.toggle input::after{content:"";position:absolute;top:3px;left:3px;width:18px;height:18px;border-radius:50%;background:#fff;transition:.2s}
.toggle input:checked::after{transform:translateX(18px)}
.score{font-weight:700}
</style>
</head>

<body>
<main>
  <h1>EV3 ‚Äì Unified Template (A4/A5/A6) mit Hindernis-Schalter</h1>
  <p>W√§hle die Aufgabe. Schreibe Python (Pybricks) in den Editor. <b>Run</b> startet den Simulator, <b>Check</b> pr√ºft die L√∂sung, <b>Download</b> speichert <code>main.py</code>.</p>

  <!-- Aufgaben-Auswahl + Hindernis-Schalter -->
  <section class="card">
    <h2 style="margin:0 0 8px">Aufgabe w√§hlen</h2>
    <div class="row">
      <div>
        <label for="task">Modus:</label>
        <select id="task" class="level-btn" style="width:auto;background:#3fb257">
          <option value="A4">A4 ‚Äì Ultraschall: Stopp, zur√ºck, abbiegen</option>
          <option value="A5">A5 ‚Äì Linienfolger (P)</option>
          <option value="A6">A6 ‚Äì Challenge (PID, S-Kurve & Tor)</option>
        </select>
      </div>
      <label class="toggle" title="Hindernisse an/aus">
        <input id="obsToggle" type="checkbox" />
        <span>Hindernisse aktiv</span>
      </label>
      <span class="badge" id="dbg">‚Äî</span>
    </div>
  </section>

  <!-- Parameter (wird dynamisch gef√ºllt) -->
  <section class="card">
    <h2 style="margin:0 0 8px">Parameter</h2>
    <div id="controls" class="controls"></div>
  </section>

  <!-- Editor -->
  <section class="card" style="margin-top:14px">
    <h2 style="margin:0 0 8px">Dein Code</h2>
    <p class="status" id="hint"></p>
    <textarea id="code" spellcheck="false"></textarea>

    <div class="row" style="margin-top:10px">
      <button id="run" class="level-btn">Simulation ausf√ºhren</button>
      <button id="reset" class="level-btn" style="background:#3fb257">Reset</button>
      <button id="check" class="level-btn" style="background:#3fb257">Aufgabe pr√ºfen</button>
      <button id="download" class="level-btn" style="background:#3fb257">Als main.py herunterladen</button>
      <button id="next" class="level-btn" disabled>N√§chster Schritt ‚ñ∑</button>
      <span id="status" class="status">Bereit</span>
      <span id="score" class="score"></span>
    </div>

    <div class="sim-wrap">
      <canvas id="sim"></canvas>
      <div class="sim-legend" id="legend"></div>
    </div>

    <h3>Logs</h3>
    <pre id="out" aria-live="polite"></pre>
    <p class="result" id="result"></p>
  </section>
</main>

<script>
/* ====== Hilfen / Kurz-Utils ====== */
const $ = (id)=>document.getElementById(id);
const out = $('out'), result = $('result'), nextBtn = $('next'), dbg = $('dbg'), legend = $('legend'), scoreEl = $('score');
function clearLogs(){ out.textContent=''; result.textContent=''; result.className='result'; scoreEl.textContent=''; }

/* ====== Canvas / Welt ====== */
const canvas = $('sim');
const ctx = canvas.getContext('2d', {alpha:false});
function setupCanvas(){
  const dpr = window.devicePixelRatio || 1;
  const cssH = parseFloat(getComputedStyle(canvas).height) || 400;
  const cssW = canvas.clientWidth || 800;
  canvas.width = Math.round(cssW*dpr); canvas.height = Math.round(cssH*dpr);
  ctx.setTransform(dpr,0,0,dpr,0,0);
}
window.addEventListener('resize', ()=>{ setupCanvas(); drawAll(); });

const WORLD = {
  robotR: 8,
  path: [],
  x:0, y:0, a:0,  // Pose
  running:false, timer:null, t:0,
  obstacles: []   // Kreise: {x,y,r}
};

function resetWorld(){
  setupCanvas();
  WORLD.path = [];
  WORLD.t = 0; WORLD.running = false; if(WORLD.timer){ clearInterval(WORLD.timer); WORLD.timer=null; }
  // Startpose je nach Task beim Start gesetzt
}

function drawGrid(){
  const w=canvas.clientWidth,h=canvas.clientHeight;
  ctx.save();
  ctx.clearRect(0,0,w,h);
  ctx.fillStyle='#fff'; ctx.fillRect(0,0,w,h);
  ctx.strokeStyle='#eee'; for(let x=0;x<=w;x+=50){ ctx.beginPath(); ctx.moveTo(x,0); ctx.lineTo(x,h); ctx.stroke(); }
  for(let y=0;y<=h;y+=50){ ctx.beginPath(); ctx.moveTo(0,y); ctx.lineTo(w,y); ctx.stroke(); }
  ctx.restore();
}

function drawObstacles(){
  ctx.save();
  ctx.fillStyle = '#ef4444';
  WORLD.obstacles.forEach(o=>{ ctx.beginPath(); ctx.arc(o.x,o.y,o.r,0,Math.PI*2); ctx.fill(); });
  ctx.restore();
}

function drawPath(){
  ctx.save();
  ctx.strokeStyle = '#3fb257'; ctx.lineWidth = 2;
  for(const [x1,y1,x2,y2] of WORLD.path){ ctx.beginPath(); ctx.moveTo(x1,y1); ctx.lineTo(x2,y2); ctx.stroke(); }
  ctx.restore();
}

function drawRobot(){
  const r=WORLD.robotR, L=18, a=WORLD.a, x=WORLD.x, y=WORLD.y;
  ctx.save();
  ctx.fillStyle='#4CAF50'; ctx.beginPath(); ctx.arc(x,y,r,0,Math.PI*2); ctx.fill();
  const tipX=x+Math.cos(a)*(r+L), tipY=y-Math.sin(a)*(r+L);
  const leftX=x+Math.cos(a+Math.PI*0.75)*r, leftY=y-Math.sin(a+Math.PI*0.75)*r;
  const rightX=x+Math.cos(a-Math.PI*0.75)*r, rightY=y-Math.sin(a-Math.PI*0.75)*r;
  ctx.beginPath(); ctx.moveTo(tipX,tipY); ctx.lineTo(leftX,leftY); ctx.lineTo(rightX,rightY); ctx.closePath(); ctx.fill();
  ctx.restore();
}

function drawAll(){
  drawGrid();
  // task-spezifische Sachen (Linie/S-Kurve/Finish) werden im Task-Renderer gezeichnet
  CURRENT.drawCourse();
  drawObstacles();
  drawPath();
  drawRobot();
}

/* ====== Hindernisse ====== */
function setObstacles(enabled){
  WORLD.obstacles = [];
  if(!enabled) return;
  const w = canvas.clientWidth, h = canvas.clientHeight;
  const task = $('task').value;
  if(task === 'A4'){
    // Ein Hindernis 400 mm vor Startlinie (anpassbar √ºber Slider in Controls falls vorhanden)
    const dist = CONTROL_VALUES.obsDist || 400;
    WORLD.obstacles.push({ x: CONTROL_VALUES.startX + dist, y: CONTROL_VALUES.startY, r: 30 });
  } else if(task === 'A5'){
    // Zwei kleine Hindernisse auf/nahe der Linie
    const y = CURRENT.lineY; // aktuelle Linien-Y (wird von drawCourse gesetz)
    WORLD.obstacles.push({ x: Math.floor(w*0.55), y: y+0, r: 24 });
    WORLD.obstacles.push({ x: Math.floor(w*0.75), y: y+40, r: 24 });
  } else if(task === 'A6'){
    // Entlang der S-Kurve
    const y1 = CURRENT.lineYAt(w*0.55), y2 = CURRENT.lineYAt(w*0.75);
    WORLD.obstacles.push({ x: Math.floor(w*0.55), y: y1+50, r: 24 });
    WORLD.obstacles.push({ x: Math.floor(w*0.75), y: y2-50, r: 24 });
  }
}

/* ====== Helfer: Physik-Schritt ====== */
function stepMove(v_mm_s, turn_deg_s, dt){
  const w = (turn_deg_s * Math.PI/180);
  WORLD.a += w*dt;
  const dx = Math.cos(WORLD.a)*v_mm_s*dt;
  const dy = -Math.sin(WORLD.a)*v_mm_s*dt;
  const x1=WORLD.x, y1=WORLD.y;
  WORLD.x += dx; WORLD.y += dy;
  WORLD.path.push([x1,y1,WORLD.x,WORLD.y]);
}

/* ====== Kollision & Distanz ====== */
function hitObstacle(){
  const r = WORLD.robotR;
  return WORLD.obstacles.find(o=>{
    const dx=WORLD.x-o.x, dy=WORLD.y-o.y;
    return Math.hypot(dx,dy) <= (o.r + r);
  });
}
// Distance vom Sensor (20 mm vor Bot) zur n√§chsten (!) Kollision auf Blickrichtung (nur nach vorne)
function ultrasonicDistanceAhead(maxRange=2000){
  const sx = WORLD.x + Math.cos(WORLD.a)*20;
  const sy = WORLD.y - Math.sin(WORLD.a)*20;
  let best = Infinity;
  WORLD.obstacles.forEach(o=>{
    // Ray-Circle-Intersection
    const dx = Math.cos(WORLD.a), dy = -Math.sin(WORLD.a);
    const ox = o.x - sx, oy = o.y - sy;
    const b = ox*dx + oy*dy;
    const c = ox*ox + oy*oy - o.r*o.r;
    const disc = b*b - c;
    if(disc >= 0){
      const t1 = b - Math.sqrt(disc); // nach vorne (Parameter t entlang Strahl)
      if(t1 > 0) best = Math.min(best, t1);
    }
  });
  return Math.min(best, maxRange);
}

/* ====== Controls-Baukasten ====== */
const CONTROL_VALUES = {}; // wird von Controls gef√ºllt
function makeSlider(id,label,min,max,step,val,unit=''){
  const wrap = document.createElement('div'); wrap.className='ctrl';
  wrap.innerHTML = `<label>${label}: <output id="${id}Val">${val}</output>${unit?'<span> '+unit+'</span>':''}</label>
                    <input id="${id}" type="range" min="${min}" max="${max}" step="${step}" value="${val}" />`;
  return wrap;
}
function bindSlider(id, parser = parseFloat){
  const el = $(id), outEl = $(id+'Val');
  const update = ()=>{ CONTROL_VALUES[id] = parser(el.value); outEl.textContent = el.value; };
  el.addEventListener('input', update); update();
}

/* ====== Aufgaben-Definitionen ====== */
const TASKS = {
  A4: {
    name: 'Ultraschall: Stopp/Back/Turn',
    hint: 'Nutze UltrasonicSensor + while ultra.distance() > THRESHOLD, dann robot.stop(), robot.straight(-‚Ä¶), robot.turn(‚Ä¶)',
    legend: '1px = 1mm ¬∑ Hindernis (rot) voraus',
    defaultCode:
`from pybricks.hubs import EV3Brick
from pybricks.ev3devices import Motor, UltrasonicSensor
from pybricks.parameters import Port
from pybricks.robotics import DriveBase
from pybricks.tools import wait

left=Motor(Port.B); right=Motor(Port.C)
robot=DriveBase(left,right,wheel_diameter=56,axle_track=114)
ultra=UltrasonicSensor(Port.S4)

THRESHOLD=150
robot.drive(150,0)
while ultra.distance() > THRESHOLD:
    wait(10)
robot.stop()
robot.straight(-120)
robot.turn(90)
`,
    buildControls(container){
      container.innerHTML='';
      container.appendChild(makeSlider('thr', 'THRESHOLD (mm)', 50, 300, 10, 150));
      container.appendChild(makeSlider('spd', 'Fahrgeschwindigkeit (sim) mm/s', 50, 400, 10, 150));
      container.appendChild(makeSlider('back','R√ºckw√§rts (mm)', 60, 300, 10, 120));
      container.appendChild(makeSlider('ang','Abbiegen (¬∞)', 30, 180, 5, 90));
      container.appendChild(makeSlider('obsDist','Hindernis vor Start (mm)', 200, 800, 20, 400));
      ['thr','spd','back','ang','obsDist'].forEach(id=>bindSlider(id, parseInt));
    },
    drawCourse(){
      // Nur Grid + Obstacle (Track ist egal)
      CURRENT.lineY = null; // f√ºr Obstacle-Set ggf. nicht n√∂tig
    },
    placeStart(){
      CONTROL_VALUES.startX = canvas.clientWidth*0.25;
      CONTROL_VALUES.startY = canvas.clientHeight/2;
      WORLD.x = CONTROL_VALUES.startX; WORLD.y = CONTROL_VALUES.startY; WORLD.a = 0;
    },
    run(code){
      // Set obstacles
      setObstacles($('obsToggle').checked);
      clearLogs(); resetWorld(); this.placeStart(); drawAll();
      // Parameter ggf. aus Code lesen
      const mThr = code.match(/THRESHOLD\s*=\s*(\d+)/i); if(mThr) CONTROL_VALUES.thr = parseInt(mThr[1],10);
      const mBack= code.match(/robot\.straight\(\s*-(\d+)/); if(mBack) CONTROL_VALUES.back = parseInt(mBack[1],10);
      const mAng = code.match(/robot\.turn\(\s*(-?\d+)/);    if(mAng) CONTROL_VALUES.ang  = parseInt(mAng[1],10);
      const spdM = code.match(/robot\.drive\(\s*(\d+)\s*,\s*0/); if(spdM) CONTROL_VALUES.spd = parseInt(spdM[1],10);

      // Distanz bis Stop (Ultraschall)
      const dAhead = ultrasonicDistanceAhead();
      const thr = CONTROL_VALUES.thr;
      const travel = isFinite(dAhead) ? Math.max(0, Math.round(dAhead - thr)) : 300;

      let t=0;
      // Anrollen
      setTimeout(()=>{ out.textContent+=`[DRIVE ${CONTROL_VALUES.spd}mm/s]\n`; }, t);
      const seg = Math.max(200, Math.min(1600, travel*2*(150/Math.max(50,CONTROL_VALUES.spd))));
      setTimeout(()=>{ stepMove(travel/ (seg/1000), 0, seg/1000); out.textContent+=`[APPROACH ${travel}mm]\n`; drawAll(); }, t); t+=seg;
      // Stop
      setTimeout(()=>{ out.textContent+='[STOP]\n'; }, t); t+=120;
      // Back
      setTimeout(()=>{ stepMove(-CONTROL_VALUES.back/(0.6), 0, 0.6); out.textContent+=`[STRAIGHT -${CONTROL_VALUES.back}mm]\n`; drawAll(); }, t); t+=600;
      // Turn
      setTimeout(()=>{ WORLD.a += CONTROL_VALUES.ang*Math.PI/180; drawAll(); out.textContent+=`[TURN ${CONTROL_VALUES.ang}¬∞]\n`; }, t);
    },
    check(code){
      const hasU = /UltrasonicSensor\s*\(/.test(code);
      const varM = code.match(/([A-Za-z_]\w*)\s*=\s*UltrasonicSensor\s*\(/);
      let cond=false; if(varM){ const v=varM[1].replace(/[.*+?^${}()|[\]\\]/g,'\\$&'); cond = new RegExp(v+String.raw`\.distance\(\)\s*>\s*\d+`).test(code); }
      const stop=/robot\.stop\s*\(\s*\)/.test(code);
      const back=/robot\.straight\(\s*-\d+/.test(code);
      const trn =/robot\.turn\(\s*-?\d+/.test(code);
      const thrMatch = code.match(/THRESHOLD\s*=\s*(\d+)/i);
      const thrOK = thrMatch ? Math.abs(parseInt(thrMatch[1],10)-CONTROL_VALUES.thr)<=10 : false;
      const ok = hasU && cond && stop && back && trn && thrOK;
      if(ok){ result.textContent='‚úîÔ∏é A4 ok ‚Äì Sensor/Stop/Back/Turn/THR passen.'; result.className='result ok'; nextBtn.disabled=false; }
      else{
        const miss=[]; if(!hasU)miss.push('UltrasonicSensor fehlt'); if(!cond)miss.push('while ‚Ä¶ distance() > THRESHOLD fehlt'); if(!stop)miss.push('robot.stop() fehlt'); if(!back)miss.push('R√ºckw√§rts fehlt'); if(!trn)miss.push('Turn fehlt'); if(!thrOK)miss.push('THRESHOLD passt nicht');
        result.textContent='Noch nicht ganz: '+miss.join(', '); result.className='result fail'; nextBtn.disabled=true;
      }
    }
  },

  A5: {
    name: 'Linienfolger (P)',
    hint: 'ColorSensor.reflection() ‚Üí error = THR - r; turn = Kp * error; robot.drive(speed, turn)',
    legend: '1px = 1mm ¬∑ Schwarze Linie quer; optional Hindernisse',
    defaultCode:
`from pybricks.hubs import EV3Brick
from pybricks.ev3devices import Motor, ColorSensor
from pybricks.parameters import Port
from pybricks.robotics import DriveBase
from pybricks.tools import wait

left=Motor(Port.B); right=Motor(Port.C)
robot=DriveBase(left,right,wheel_diameter=56,axle_track=114)
color=ColorSensor(Port.S3)

THRESHOLD=50
Kp=1.2
SPEED=120

while True:
    r=color.reflection()
    error=THRESHOLD - r
    turn=Kp*error
    robot.drive(SPEED, turn)
    wait(10)
`,
    buildControls(container){
      container.innerHTML='';
      container.appendChild(makeSlider('thr','THRESHOLD (Reflexion)', 20, 80, 1, 50));
      container.appendChild(makeSlider('kp','Kp', 0.2, 3.0, 0.1, 1.2));
      container.appendChild(makeSlider('spd','Speed (mm/s)', 60, 300, 10, 120));
      container.appendChild(makeSlider('lineY','Linien-Y (mm)', -120, 120, 5, 80));
      ['thr','kp','spd','lineY'].forEach(id=>bindSlider(id, Number));
    },
    drawCourse(){
      // Linie quer
      const y = canvas.clientHeight/2 + (CONTROL_VALUES.lineY||80);
      CURRENT.lineY = y;
      ctx.save(); ctx.fillStyle='#000'; ctx.fillRect(0, y-12, canvas.clientWidth, 24); ctx.restore();
    },
    placeStart(){
      WORLD.x = canvas.clientWidth*0.25; WORLD.y = canvas.clientHeight/2; WORLD.a = 0;
    },
    run(code){
      clearLogs(); resetWorld(); this.placeStart();
      // Obstacles setzen (Optional)
      this.drawCourse(); setObstacles($('obsToggle').checked); drawAll();

      // aus Code lesen
      const mThr = code.match(/THRESHOLD\s*=\s*(\d+)/i); if(mThr) CONTROL_VALUES.thr = parseInt(mThr[1],10);
      const mKp  = code.match(/\bKp\s*=\s*([0-9.]+)/); if(mKp) CONTROL_VALUES.kp = parseFloat(mKp[1]);
      const mSpd = code.match(/SPEED\s*=\s*(\d+)/) || code.match(/robot\.drive\(\s*(\d+)/); if(mSpd) CONTROL_VALUES.spd = parseInt(mSpd[1],10);

      // Loop
      const dt=0.02; WORLD.running=true; WORLD.t=0;
      if(WORLD.timer) clearInterval(WORLD.timer);
      WORLD.timer=setInterval(()=>{
        if(!WORLD.running){ clearInterval(WORLD.timer); WORLD.timer=null; return; }
        // Sensor vorneweg (20mm), Gau√üprofil zur Linie
        const SENSOR_OFFSET=20;
        const sx=WORLD.x+Math.cos(WORLD.a)*SENSOR_OFFSET, sy=WORLD.y-Math.sin(WORLD.a)*SENSOR_OFFSET;
        const d = Math.abs(sy - CURRENT.lineY);
        const WHITE=80, BLACK=15, sigma=12;
        const dark=Math.exp(-(d*d)/(2*sigma*sigma));
        const r = Math.round(WHITE-(WHITE-BLACK)*dark);

        const err = (CONTROL_VALUES.thr - r);
        const turn = Math.max(-360, Math.min(360, -(CONTROL_VALUES.kp * err))); // Minus wg. Canvas
        stepMove(CONTROL_VALUES.spd, turn, dt);
        WORLD.t += dt;

        if((Math.round(WORLD.t*10)%5)===0){ out.textContent += `[t ${WORLD.t.toFixed(1)}] REF ${r} ERR ${err} TURN ${turn.toFixed(1)}\n`; dbg.textContent=`REF ${r} ‚Ä¢ ERR ${err} ‚Ä¢ TURN ${turn.toFixed(1)}`; }

        // optional: Kollision stoppt
        if($('obsToggle').checked && hitObstacle()){
          WORLD.running=false; clearInterval(WORLD.timer); out.textContent+='[HIT OBSTACLE]\n'; result.textContent='‚ùå Hindernis getroffen.'; result.className='result fail';
        }

        drawAll();
        if(WORLD.t>=8){ WORLD.running=false; clearInterval(WORLD.timer); out.textContent+='[END]\n'; }
      }, dt*1000);
    },
    check(code){
      const hasC = /ColorSensor\s*\(/.test(code);
      const hasR = /\.reflection\s*\(\s*\)/.test(code);
      const hasL = /while\s+True|while\s+.+:/.test(code);
      const hasD = /robot\.drive\s*\(\s*[^,]+,\s*[^)]+\)/.test(code);
      const mThr = code.match(/THRESHOLD\s*=\s*(\d+)/i);
      const thrOK = mThr ? Math.abs(parseInt(mThr[1],10) - CONTROL_VALUES.thr)<=5 : false;
      const ok = hasC && hasR && hasL && hasD && thrOK;
      if(ok){ result.textContent='‚úîÔ∏é A5 ok ‚Äì P-Regler & THR passen.'; result.className='result ok'; nextBtn.disabled=false; }
      else{
        const miss=[]; if(!hasC)miss.push('ColorSensor fehlt'); if(!hasR)miss.push('reflection() fehlt'); if(!hasL)miss.push('Schleife fehlt'); if(!hasD)miss.push('robot.drive(...) fehlt'); if(!thrOK)miss.push('THRESHOLD passt nicht');
        result.textContent='Noch nicht ganz: '+miss.join(', '); result.className='result fail'; nextBtn.disabled=true;
      }
    }
  },

  A6: {
    name: 'Challenge (PID, S-Kurve & Tor)',
    hint: 'PID: turn = Kp*e + Ki*‚à´e + Kd*Œîe (mit Minus f√ºrs Canvas). Ziel: durchs Tor.',
    legend: '1px = 1mm ¬∑ S-Kurve (schwarz) ¬∑ Zieltor rechts (gr√ºn) ¬∑ optional Hindernisse',
    defaultCode:
`from pybricks.hubs import EV3Brick
from pybricks.ev3devices import Motor, ColorSensor
from pybricks.parameters import Port
from pybricks.robotics import DriveBase
from pybricks.tools import wait

left=Motor(Port.B); right=Motor(Port.C)
robot=DriveBase(left,right,wheel_diameter=56,axle_track=114)
color=ColorSensor(Port.S3)

THRESHOLD=50
SPEED=140
Kp=1.1; Ki=0.0; Kd=0.2

integral=0; prev_error=0
while True:
    r=color.reflection()
    error=THRESHOLD - r
    integral+=error
    derivative=error-prev_error
    turn=Kp*error + Ki*integral + Kd*derivative
    robot.drive(SPEED, turn)
    prev_error=error
    wait(10)
`,
    buildControls(container){
      container.innerHTML='';
      container.appendChild(makeSlider('thr','THRESHOLD (Reflexion)', 20, 80, 1, 50));
      container.appendChild(makeSlider('spd','Speed (mm/s)', 60, 300, 10, 140));
      container.appendChild(makeSlider('kp','Kp', 0.2, 3.0, 0.1, 1.1));
      container.appendChild(makeSlider('ki','Ki', 0.0, 1.5, 0.05, 0.0));
      container.appendChild(makeSlider('kd','Kd', 0.0, 2.5, 0.05, 0.2));
      ['thr','spd','kp','ki','kd'].forEach(id=>bindSlider(id, Number));
    },
    // Kurs & Tor
    lineYAt(x){
      const h = canvas.clientHeight, w = canvas.clientWidth;
      const amp = 80, periods = 1.6, phase = (x / w) * (Math.PI*2*periods);
      return h/2 + amp * Math.sin(phase);
    },
    drawCourse(){
      const w=canvas.clientWidth, step=2; ctx.save(); ctx.fillStyle='#000';
      for(let x=0;x<=w;x+=step){ const y=this.lineYAt(x); ctx.fillRect(x,y-13, step+1, 26); }
      ctx.restore();
      // Zieltor
      const gateX = Math.floor(w*0.88), gateH=120, gateY=this.lineYAt(gateX)-gateH/2;
      ctx.save(); ctx.fillStyle='#22c55e'; ctx.fillRect(gateX, gateY, 10, gateH); ctx.restore();
      CURRENT.FINISH_X = gateX;
      CURRENT.lineYAt = this.lineYAt.bind(this);
    },
    placeStart(){
      const x0 = canvas.clientWidth*0.08, y0 = this.lineYAt(x0);
      WORLD.x=x0; WORLD.y=y0; WORLD.a=0;
    },
    run(code){
      clearLogs(); resetWorld(); this.placeStart();
      this.drawCourse(); setObstacles($('obsToggle').checked); drawAll();
      // aus Code lesen
      const g = (re, def)=>{ const m=code.match(re); return m? parseFloat(m[1]) : def; };
      CONTROL_VALUES.thr = g(/THRESHOLD\s*=\s*([0-9.]+)/i, CONTROL_VALUES.thr||50);
      CONTROL_VALUES.spd = g(/SPEED\s*=\s*([0-9.]+)/i, CONTROL_VALUES.spd||140);
      CONTROL_VALUES.kp  = g(/\bKp\s*=\s*([0-9.]+)/, CONTROL_VALUES.kp||1.1);
      CONTROL_VALUES.ki  = g(/\bKi\s*=\s*([0-9.]+)/, CONTROL_VALUES.ki||0.0);
      CONTROL_VALUES.kd  = g(/\bKd\s*=\s*([0-9.]+)/, CONTROL_VALUES.kd||0.2);

      const dt=0.02; let integ=0, prevE=0, errInt=0;
      WORLD.running=true; WORLD.t=0;
      if(WORLD.timer) clearInterval(WORLD.timer);
      WORLD.timer=setInterval(()=>{
        if(!WORLD.running){ clearInterval(WORLD.timer); WORLD.timer=null; return; }
        // Sensor (20 mm vor Bot), Reflexion relativ zur S-Kurve
        const SENSOR_OFFSET=20;
        const sx=WORLD.x+Math.cos(WORLD.a)*SENSOR_OFFSET, sy=WORLD.y-Math.sin(WORLD.a)*SENSOR_OFFSET;
        const d = Math.abs(sy - CURRENT.lineYAt(sx));
        const WHITE=80, BLACK=15, sigma=13;
        const dark=Math.exp(-(d*d)/(2*sigma*sigma));
        const r = Math.round(WHITE-(WHITE-BLACK)*dark);

        const e = (CONTROL_VALUES.thr - r);
        integ += e;
        const deriv = e - prevE;
        let turn = CONTROL_VALUES.kp*e + CONTROL_VALUES.ki*integ + CONTROL_VALUES.kd*deriv;
        turn = Math.max(-360, Math.min(360, -turn)); // Minus wg. Canvas
        stepMove(CONTROL_VALUES.spd, turn, dt);
        WORLD.t += dt; errInt += Math.abs(e)*dt;

        if((Math.round(WORLD.t*10)%5)===0){ out.textContent += `[t ${WORLD.t.toFixed(1)}] REF ${r} ERR ${e} TURN ${turn.toFixed(1)}\n`; dbg.textContent=`REF ${r} ‚Ä¢ ERR ${e} ‚Ä¢ TURN ${turn.toFixed(1)}`; }

        // Hindernis-Kollision
        if($('obsToggle').checked && hitObstacle()){
          WORLD.running=false; clearInterval(WORLD.timer); scoreEl.textContent='‚ùå Hindernis getroffen'; result.textContent='Noch nicht ganz ‚Äì weicher regeln/Speed anpassen.'; result.className='result fail';
        }

        drawAll();

        // Ziel / Timeout
        const gateX = CURRENT.FINISH_X, gateY = CURRENT.lineYAt(gateX);
        const inGate = (WORLD.x >= gateX) && (Math.abs(WORLD.y - gateY) <= 60);
        const oob = (WORLD.y<0 || WORLD.y>canvas.clientHeight);
        if(inGate || oob || WORLD.t>20){
          WORLD.running=false; clearInterval(WORLD.timer);
          const timeScore = Math.max(0, 20 - WORLD.t) * 50;
          const errScore  = Math.max(0, 120 - errInt);
          const bonus     = inGate ? 150 : 0;
          const score     = Math.round(timeScore + errScore + bonus);
          const status    = inGate ? 'üéâ Ziel erreicht!' : (oob ? '‚ùå Abseits' : '‚è±Ô∏è Zeit abgelaufen');
          scoreEl.textContent = `${status} | Zeit: ${WORLD.t.toFixed(2)} s ¬∑ Abweichung: ${errInt.toFixed(1)} ¬∑ Score: ${score}`;
          if(inGate){ result.textContent='‚úîÔ∏é A6 bestanden ‚Äì durchs Tor!'; result.className='result ok'; }
          else{ result.textContent='Noch nicht ganz ‚Äì PID feinjustieren.'; result.className='result fail'; }
        }
        prevE = e;
      }, dt*1000);
    },
    check(code){
      const hasC=/ColorSensor\s*\(/.test(code);
      const hasR=/\.reflection\s*\(\s*\)/.test(code);
      const hasL=/while\s+True|while\s+.+:/.test(code);
      const hasD=/robot\.drive\s*\(\s*[^,]+,\s*[^)]+\)/.test(code);
      const mThr=code.match(/THRESHOLD\s*=\s*(\d+)/i); const thrOK = mThr ? Math.abs(parseInt(mThr[1],10)-(CONTROL_VALUES.thr||50))<=5 : false;
      const ok = hasC && hasR && hasL && hasD && thrOK;
      if(ok){ result.textContent='‚úîÔ∏é Formal ok ‚Äì jetzt z√§hlt die Performance (Score).'; result.className='result ok'; nextBtn.disabled=false; }
      else{
        const miss=[]; if(!hasC)miss.push('ColorSensor fehlt'); if(!hasR)miss.push('reflection() fehlt'); if(!hasL)miss.push('Schleife fehlt'); if(!hasD)miss.push('robot.drive(...) fehlt'); if(!thrOK)miss.push('THRESHOLD passt nicht');
        result.textContent='Noch nicht ganz: '+miss.join(', '); result.className='result fail'; nextBtn.disabled=true;
      }
    }
  }
};

/* ====== Aktiver Task ====== */
let CURRENT = {
  drawCourse: ()=>{}, // wird vom Task √ºberschrieben
  lineY: null,
  lineYAt: (x)=>canvas.clientHeight/2,
  FINISH_X: null
};

function loadTask(id){
  const T = TASKS[id];
  CURRENT = Object.assign(CURRENT, { drawCourse: T.drawCourse.bind(T) });
  $('hint').textContent = T.hint;
  $('legend').textContent = T.legend;
  $('code').value = T.defaultCode.trim();
  // Controls bauen
  T.buildControls($('controls'));
  // Startpose setzen & Hindernisse
  clearLogs(); resetWorld(); T.placeStart(); T.drawCourse(); setObstacles($('obsToggle').checked); drawAll();
}

/* ====== Buttons / Events ====== */
$('task').addEventListener('change', e=> loadTask(e.target.value));
$('obsToggle').addEventListener('change', ()=>{
  clearLogs(); resetWorld();
  const id=$('task').value; TASKS[id].placeStart(); TASKS[id].drawCourse(); setObstacles($('obsToggle').checked); drawAll();
});
$('run').addEventListener('click', ()=>{
  const id=$('task').value; TASKS[id].run($('code').value||'');
});
$('check').addEventListener('click', ()=>{
  const id=$('task').value; TASKS[id].check($('code').value||'');
});
$('reset').addEventListener('click', ()=>{
  clearLogs(); resetWorld();
  const id=$('task').value; TASKS[id].placeStart(); TASKS[id].drawCourse(); setObstacles($('obsToggle').checked); drawAll();
});
$('download').addEventListener('click', ()=>{
  const blob = new Blob([($('code').value||'')], {type:'text/x-python'});
  const url = URL.createObjectURL(blob); const a=document.createElement('a');
  a.href=url; a.download='main.py'; a.click(); URL.revokeObjectURL(url);
});

/* ====== Init ====== */
resetWorld();
loadTask('A4');
</script>
</body>
</html>
