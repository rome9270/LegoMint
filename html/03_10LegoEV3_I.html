<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>EV3 - line follower&touch</title>

  <link rel="stylesheet" href="../css/03_python.css" />
  <style>
    #arena {
      background:#f9fafb;
      border:2px solid #111;
      width:100%;
      height:auto;
      max-width:900px;
      border-radius:10px;
      display:block;
      margin-top:10px;
    }

    .status.ok { color:#15803d; }
    .status.error { color:#b91c1c; }
    .status.running { color:#374151; }
    .muted { color:#6b7280; }
    #error { color:#b91c1c; white-space:pre-wrap; }
  </style>
</head>
<body>
  <!-- NAV (einziger Block) -->
  <nav class="link-grid" aria-label="Topic selection">
    <a class="btn" href="../app/01_main.php" id="go-main" aria-label="Back to main">‚¨ÖÔ∏è Going to main</a>
    <a class="btn" href="../app/logout.php">üö™ Logout</a>
    <a class="btn primary" id="next-btn" href="03_10LegoEV3_I.html">Next ‚Üí</a>
  </nav>

  <header class="row" style="justify-content: space-between;">
    <div>
      <h1>EV3 (Pybricks) ¬∑ Line Follower + TouchSensor Return</h1>

      <p>Your robot should:</p>
      <ol>
        <li>Drive straight until it reaches the black line.</li>
        <li>Follow the line using the ColorSensor on <b>Port S1</b>.</li>
        <li>Stop when the TouchSensor on <b>Port S3</b> hits the wall.</li>
        <li>Back up, turn 180¬∞, and drive back to the start position.</li>
      </ol>

      <p class="muted">
        ‚Ä¢ The editor is only a scaffold / help text.<br>
        ‚Ä¢ Click <b>‚úÖ Solution ‚Üí Insert</b> to load the working code (SLOW version for real robot).<br>
        ‚Ä¢ Then press <b>‚ñ∂ Run</b> to watch the simulation of the mission.<br>
        ‚Ä¢ The simulation does NOT execute the Python code ‚Äì it just visualizes the steps.
      </p>
    </div>

    <div class="row">
      <button class="btn" id="tips-btn">üí° Tips</button>
      <button class="btn" id="solution-btn">‚úÖ Solution</button>
    </div>
  </header>

  <main class="layout">
    <!-- EDITOR -->
    <section class="card">
      <h2>Editor</h2>

      <div class="row">
        <button class="btn primary" id="run-btn">‚ñ∂ Run</button>
        <button class="btn" id="reset-btn">‚ü≤ Reset</button>
        <button class="btn" id="save-btn">üíæ Save</button>
        <span id="status" class="status" aria-live="polite"></span>
      </div>

<textarea id="editor" spellcheck="false">#!/usr/bin/env pybricks-micropython
# EV3 (Pybricks) ‚Äì Line Follower (Scaffold)
# This is NOT yet the final solution.
# Use "‚úÖ Solution ‚Üí Insert" to get a working slow version for the real robot.

from pybricks.hubs import EV3Brick
from pybricks.ev3devices import Motor, ColorSensor, TouchSensor
from pybricks.parameters import Port, Stop
from pybricks.tools import wait
from pybricks.robotics import DriveBase

brick = EV3Brick()
left  = Motor(Port.A)
right = Motor(Port.B)
color = ColorSensor(Port.S1)
touch = TouchSensor(Port.S3)
drive = DriveBase(left, right, 56, 114)

# TODO:
# 1) Drive forward until black line detected
# 2) Follow the line using reflection() + P-controller
# 3) Stop when TouchSensor pressed (wall)
# 4) Back up slowly, turn 180¬∞, drive back to start

brick.speaker.beep()
brick.screen.print("Start coding!")
wait(500)
</textarea>
    </section>

    <!-- SIMULATION -->
    <section class="card">
      <h2>Simulation</h2>

      <canvas id="arena" width="600" height="300"></canvas>
      <p class="muted">
        Robot (green) drives to the black line, follows it slowly,
        stops at the red wall, backs up, turns, and returns to start.
      </p>

      <pre id="output"></pre>
      <div id="error"></div>
    </section>
  </main>

  <!-- TIPS MODAL -->
  <dialog id="tips-modal">
    <div class="modal-header">Tips</div>
    <div class="modal-body">
      <ul id="tips-list"></ul>
    </div>
    <div class="modal-actions">
      <button class="btn" id="close-tips">Close</button>
    </div>
  </dialog>

  <!-- SOLUTION MODAL -->
  <dialog id="solution-modal">
    <div class="modal-header">Solution (Slow / Real Robot)</div>
    <div class="modal-body">
<pre id="solution-code" style="white-space:pre-wrap;">#!/usr/bin/env pybricks-micropython
from pybricks.hubs import EV3Brick
from pybricks.ev3devices import Motor, ColorSensor, TouchSensor
from pybricks.parameters import Port, Stop
from pybricks.tools import wait
from pybricks.robotics import DriveBase

brick = EV3Brick()
left  = Motor(Port.A)
right = Motor(Port.B)
color = ColorSensor(Port.S1)
touch = TouchSensor(Port.S3)
drive = DriveBase(left, right, 56, 114)

# ------------------------------
# TUNING FOR REAL ROBOT (SLOW):
# ------------------------------
LINE_DETECT_THRESHOLD = 20      # reflection < 20 => black line seen
FOLLOW_SPEED_MM_S     = 60      # slow line-follow speed
KP                     = 1.2    # smaller kp => smoother
TARGET_REFLECTION     = 30      # aim brightness between black & white
BACKUP_SPEED_MM_S     = -80     # slow reverse (negative = backwards)
BACKUP_TIME_MS        = 1000    # 1s back away from wall
RETURN_SPEED_MM_S     = 120     # go home (still not crazy fast)

# === 1) Drive until black line ===
while True:
    drive.drive(80, 0)  # approach line slowly
    if color.reflection() < LINE_DETECT_THRESHOLD:
        break
    wait(10)
drive.stop(Stop.BRAKE)

# === 2) Follow line (slow) until wall hit ===
while not touch.pressed():
    value = color.reflection()
    error = TARGET_REFLECTION - value
    steer = error * KP
    drive.drive(FOLLOW_SPEED_MM_S, steer)
    wait(15)
drive.stop(Stop.BRAKE)
brick.speaker.beep()

# === 3) Back up slowly, then turn 180 ===
drive.drive(BACKUP_SPEED_MM_S, 0)
wait(BACKUP_TIME_MS)
drive.stop(Stop.BRAKE)

drive.turn(180)

# === 4) Go home (straight) ===
drive.drive(RETURN_SPEED_MM_S, 0)
wait(3000)  # approx distance back to start
drive.stop(Stop.BRAKE)

brick.speaker.beep()
brick.screen.print("Mission complete!")
wait(500)
</pre>
    </div>
    <div class="modal-actions">
      <button class="btn" id="copy-solution">Insert</button>
      <button class="btn" id="close-solution">Close</button>
    </div>
  </dialog>

<script>
/* ============================================================
   TASK META
============================================================ */
const TASK = { taskId: 10 };

/* ============================================================
   DOM ELEMENTS
============================================================ */
const runBtn        = document.getElementById("run-btn");
const resetBtn      = document.getElementById("reset-btn");
const saveBtn       = document.getElementById("save-btn");
const editorEl      = document.getElementById("editor");
const statusEl      = document.getElementById("status");
const outputEl      = document.getElementById("output");
const errorEl       = document.getElementById("error");
const canvasEl      = document.getElementById("arena");

const tipsBtn       = document.getElementById("tips-btn");
const tipsModal     = document.getElementById("tips-modal");
const closeTipsBtn  = document.getElementById("close-tips");

const solutionBtn   = document.getElementById("solution-btn");
const solutionModal = document.getElementById("solution-modal");
const copySolution  = document.getElementById("copy-solution");
const closeSolution = document.getElementById("close-solution");

const solutionCodeEl = document.getElementById("solution-code");

function setStatus(cls, txt){
  statusEl.className = "status " + (cls || "");
  statusEl.textContent = txt || "";
}

/* tips text */
const tipsListEl = document.getElementById("tips-list");
if (tipsListEl){
  tipsListEl.innerHTML = [
    "Approach line: drive until ColorSensor reflection() < threshold.",
    "Then follow the line using error = TARGET - reflection.",
    "steer = error * KP; drive.drive(SLOW_SPEED, steer).",
    "Stop when TouchSensor (S3) is pressed ‚Üí wall reached.",
    "Back up slowly, turn 180¬∞, drive back to start.",
    "End with beep + print a success message."
  ].map(t=>"<li>"+t+"</li>").join("");
}

/* modals */
tipsBtn.onclick = ()=>{
  if (tipsModal.showModal) tipsModal.showModal();
  else tipsModal.setAttribute("open","");
};
closeTipsBtn.onclick = ()=>{
  if (tipsModal.close) tipsModal.close();
  else tipsModal.removeAttribute("open");
};

solutionBtn.onclick = ()=>{
  if (solutionModal.showModal) solutionModal.showModal();
  else solutionModal.setAttribute("open","");
};
closeSolution.onclick = ()=>{
  if (solutionModal.close) solutionModal.close();
  else solutionModal.removeAttribute("open");
};

let simulationReady = false;
copySolution.onclick = ()=>{
  editorEl.value = solutionCodeEl.textContent;
  simulationReady = true;

  if (solutionModal.close) solutionModal.close();
  else solutionModal.removeAttribute("open");

  setStatus("ok","Ready to run");
  outputEl.textContent = "Slow solution inserted. Now press ‚ñ∂ Run.";
  errorEl.textContent  = "";

  resetWorld();
};

/* ============================================================
   Fortschritt an Server (sim / download)
============================================================ */
function sendEvent(ev){
  fetch("../app/event_update.php", {
    method: "POST",
    credentials: "include",
    headers: { "Content-Type": "application/x-www-form-urlencoded" },
    body: new URLSearchParams({
      task_id: String(TASK.taskId),
      event: ev
    })
  })
  .then(r => r.json())
  .then(data => {
    console.log("Server response:", data);
  })
  .catch(err => {
    console.warn("sendEvent failed:", err);
  });
}

/* ============================================================
   VALIDATION of student's Python code
   (so wir geben sim_ok nur bei sinnvollem Code)
============================================================ */
function stripComments(src){
  let x = src.replace(/^[ \t]*#.*$/gm, "");
  x = x.replace(/[ \t]+#.*$/gm, "");
  return x;
}

function validateStudentCode(src){
  const raw  = src.replace(/\r/g,"");
  const code = stripComments(raw);
  const errs = [];

  if(code.trim()===""){
    errs.push("Please write your Pybricks program first.");
    return { ok:false, errors:errs };
  }

  // imports we expect
  [
    [/from\s+pybricks\.hubs\s+import\s+EV3Brick/, "Missing import: EV3Brick"],
    [/from\s+pybricks\.ev3devices\s+import\s+.*\bMotor\b/, "Missing import: Motor"],
    [/from\s+pybricks\.ev3devices\s+import\s+.*\bColorSensor\b/, "Missing import: ColorSensor"],
    [/from\s+pybricks\.ev3devices\s+import\s+.*\bTouchSensor\b/, "Missing import: TouchSensor"],
    [/from\s+pybricks\.parameters\s+import\s+.*\bPort\b/, "Missing import: Port"],
    [/from\s+pybricks\.parameters\s+import\s+.*\bStop\b/, "Missing import: Stop"],
    [/from\s+pybricks\.tools\s+import\s+.*\bwait\b/, "Missing import: wait"],
    [/from\s+pybricks\.robotics\s+import\s+.*\bDriveBase\b/, "Missing import: DriveBase"]
  ].forEach(([re,msg])=>{
    if(!re.test(code)) errs.push("‚úó "+msg);
  });

  // hardware init
  if(!/EV3Brick\s*\(\s*\)/.test(code)) errs.push("‚úó EV3Brick() missing");
  if(!/Motor\s*\(\s*Port\.A\s*\)/.test(code)) errs.push("‚úó Motor(Port.A) missing");
  if(!/Motor\s*\(\s*Port\.B\s*\)/.test(code)) errs.push("‚úó Motor(Port.B) missing");
  if(!/ColorSensor\s*\(\s*Port\.S1\s*\)/.test(code)) errs.push("‚úó ColorSensor(Port.S1) missing");
  if(!/TouchSensor\s*\(\s*Port\.S3\s*\)/.test(code)) errs.push("‚úó TouchSensor(Port.S3) missing");
  if(!/DriveBase\s*\(/.test(code)) errs.push("‚úó DriveBase(...) missing");

  // phase 1: approach line until reflection<threshold
  if(!/color\s*\.\s*reflection\s*\(/.test(code)){
    errs.push("‚úó Must read color.reflection()");
  }
  if(!/while\s+True\s*:/.test(code) && !/while\s+not\s+\w+\.pressed\s*\(\s*\)\s*:/.test(code)){
    // we at least want some while-based drive logic before touch
    // we won't force "while True", but we need some loop structure
    errs.push("‚úó Missing driving loop structure (while ...:)");
  }
  // look for threshold check
  if(!/reflection\s*\(\)\s*<\s*\w+/.test(code) && !/reflection\s*\(\)\s*<\s*\d+/.test(code)){
    errs.push("‚úó Must detect black line with a threshold, e.g. if color.reflection() < LINE_DETECT_THRESHOLD:");
  }

  // phase 2: line follow with P controller until touch.pressed()
  if(!/touch\s*\.\s*pressed\s*\(\s*\)/.test(code)){
    errs.push("‚úó Must stop when TouchSensor is pressed (touch.pressed())");
  }
  if(!/error\s*=\s*.*TARGET_REFLECTION.*-.*(value|color\.reflection\(\))/s.test(code) &&
     !/error\s*=\s*.*target.*-.*(value|color\.reflection\(\))/s.test(code)){
    errs.push("‚úó Missing error = TARGET_REFLECTION - value (or similar)");
  }
  if(!/steer\s*=\s*.*error.*\*/.test(code)){
    errs.push("‚úó Missing steer = error * KP (or similar)");
  }
  if(!/drive\.drive\s*\(\s*\w+.*,\s*steer\s*\)/.test(code) &&
     !/drive\.drive\s*\(\s*\d+.*,\s*steer\s*\)/.test(code)){
    errs.push("‚úó Missing drive.drive(SLOW_SPEED, steer) during line follow");
  }

  // phase 3: backup and turn 180
  // backup usually: drive.drive(negative,0) then wait(...)
  if(!/drive\.drive\s*\(\s*-\s*\d+.*,\s*0\s*\)/.test(code) &&
     !/drive\.drive\s*\(\s*BACKUP_SPEED_MM_S\s*,\s*0\s*\)/.test(code)){
    errs.push("‚úó Missing backward drive after wall impact");
  }
  if(!/drive\.turn\s*\(\s*180\s*\)/.test(code) &&
     !/drive\.turn\s*\(\s*-180\s*\)/.test(code)){
    errs.push("‚úó Missing 180¬∞ turn to face home");
  }

  // phase 4: go home (some forward drive again)
  if(!/drive\.drive\s*\(\s*\w+.*,\s*0\s*\)/.test(code)){
    errs.push("‚úó Missing forward drive back home (drive.drive(RETURN_SPEED_MM_S, 0))");
  }

  // end feedback (beep + print message)
  if(!/brick\s*\.\s*speaker\s*\.\s*beep\s*\(\s*\)/.test(code)){
    errs.push("‚úó Missing brick.speaker.beep() at the end");
  }
  if(!/brick\s*\.\s*screen\s*\.\s*print\s*\(\s*["'][^"']+["']\s*\)/.test(code)){
    errs.push("‚úó Missing brick.screen.print(...) at the end");
  }

  return { ok: errs.length===0, errors: errs };
}

/* ============================================================
   CANVAS / WORLD STATE & SIMULATION
============================================================ */
const ctx = canvasEl.getContext("2d");
const deg2rad = d => d * Math.PI/180;

// --- START / LINE / WALL GEOMETRY -----------------
const START_X        = 80;     // px
const START_Y        = 230;    // px
const START_HEADING  = -90;    // deg  (-90 = nach oben)

const LINE_Y         = 150;    // px
const WALL_X         = 480;    // px
const WALL_HEIGHT    = 60;     // px

// --- MOTION + CONTROL (langsam) -------------------
const SPEED_APPROACH = 0.25;
const SPEED_FOLLOW   = 0.25;
const KP_FOLLOW      = 0.8;
const SPEED_BACK     = 0.6;
const BACK_FRAMES    = 60;
const TURN_SPEED     = 3;
const SPEED_RETURN   = 0.8;

let running = false;

const WORLD = {
  robot: {
    x: START_X,
    y: START_Y,
    heading: START_HEADING,
    r: 6
  }
};

function drawWorld(label){
  ctx.fillStyle="#fff";
  ctx.fillRect(0,0,canvasEl.width,canvasEl.height);

  ctx.strokeStyle="#111";
  ctx.lineWidth=2;
  ctx.strokeRect(0,0,canvasEl.width,canvasEl.height);

  // black line
  ctx.strokeStyle="#000";
  ctx.lineWidth=4;
  ctx.beginPath();
  ctx.moveTo(0, LINE_Y);
  ctx.lineTo(canvasEl.width, LINE_Y);
  ctx.stroke();

  // red wall
  ctx.strokeStyle="#b91c1c";
  ctx.lineWidth=4;
  ctx.beginPath();
  ctx.moveTo(WALL_X, LINE_Y - WALL_HEIGHT/2);
  ctx.lineTo(WALL_X, LINE_Y + WALL_HEIGHT/2);
  ctx.stroke();

  // robot
  const r = WORLD.robot;
  ctx.fillStyle="#16a34a";
  ctx.beginPath();
  ctx.arc(r.x, r.y, r.r, 0, Math.PI*2);
  ctx.fill();

  ctx.strokeStyle="#16a34a";
  ctx.lineWidth=2;
  ctx.beginPath();
  ctx.moveTo(r.x, r.y);
  ctx.lineTo(
    r.x + Math.cos(deg2rad(r.heading))*15,
    r.y + Math.sin(deg2rad(r.heading))*15
  );
  ctx.stroke();

  if (label){
    ctx.fillStyle="#374151";
    ctx.font="12px sans-serif";
    ctx.fillText(label, 10, 20);
  }
}

function resetWorld(){
  WORLD.robot.x = START_X;
  WORLD.robot.y = START_Y;
  WORLD.robot.heading = START_HEADING;
  drawWorld("ready (slow)");
}

function stepForward(px){
  WORLD.robot.x += Math.cos(deg2rad(WORLD.robot.heading)) * px;
  WORLD.robot.y += Math.sin(deg2rad(WORLD.robot.heading)) * px;
}

function rotateTowards(targetDeg, maxStepDeg){
  let cur = WORLD.robot.heading;
  let diff = targetDeg - cur;
  diff = ((diff + 540) % 360) - 180; // [-180..180]
  const step = Math.sign(diff) * Math.min(Math.abs(diff), maxStepDeg);
  WORLD.robot.heading = (cur + step + 360) % 360;
}

/* Phase 1: approach line */
function simApproachLine(){
  return new Promise(resolve=>{
    function tick(){
      if(!running) return resolve();
      stepForward(SPEED_APPROACH);
      drawWorld("Phase 1: approach line (slow)");
      if (Math.abs(WORLD.robot.y - LINE_Y) < 2){
        WORLD.robot.y = LINE_Y;
        WORLD.robot.heading = 0; // face right
        resolve();
        return;
      }
      requestAnimationFrame(tick);
    }
    requestAnimationFrame(tick);
  });
}

/* Phase 2: follow line to wall */
function simFollowLineToWall(){
  return new Promise(resolve=>{
    function tick(){
      if(!running) return resolve();

      const error = LINE_Y - WORLD.robot.y;
      const steerDeg = KP_FOLLOW * error;
      WORLD.robot.heading = (WORLD.robot.heading + steerDeg + 360) % 360;

      stepForward(SPEED_FOLLOW);
      drawWorld("Phase 2: follow line (slow)");

      if (WORLD.robot.x + WORLD.robot.r >= WALL_X){
        resolve();
        return;
      }
      requestAnimationFrame(tick);
    }
    requestAnimationFrame(tick);
  });
}

function beepSound(){
  try {
    const ac = new AudioContext();
    const osc = ac.createOscillator();
    osc.type = "sine";
    osc.frequency.value = 800;
    osc.connect(ac.destination);
    osc.start();
    osc.stop(ac.currentTime + 0.2);
  } catch(e){}
}

/* Phase 3: bump, beep, back up slowly, rotate toward home */
function simTouchBackAndTurn(){
  return new Promise(resolve=>{
    let framesBack = 0;
    let phaseStep = 0;
    // 0 -> beep
    // 1 -> reverse
    // 2 -> rotate to start

    function tick(){
      if(!running) return resolve();

      if (phaseStep === 0){
        drawWorld("Phase 3: touch! stop + beep");
        beepSound();
        phaseStep = 1;
        framesBack = 0;
        requestAnimationFrame(tick);
        return;
      }

      if (phaseStep === 1){
        WORLD.robot.heading = (WORLD.robot.heading + 180) % 360;
        stepForward(SPEED_BACK);
        WORLD.robot.heading = (WORLD.robot.heading + 180) % 360;

        framesBack++;
        drawWorld("Phase 3: backing away (slow)");

        if(framesBack >= BACK_FRAMES){
          phaseStep = 2;
        }
        requestAnimationFrame(tick);
        return;
      }

      if (phaseStep === 2){
        const dx = START_X - WORLD.robot.x;
        const dy = START_Y - WORLD.robot.y;
        const targetDeg = (Math.atan2(dy,dx)*180/Math.PI + 360) % 360;

        rotateTowards(targetDeg, TURN_SPEED);
        drawWorld("Phase 3: turning to home");

        let diff = targetDeg - WORLD.robot.heading;
        diff = ((diff + 540) % 360) - 180;
        if (Math.abs(diff) < 5){
          resolve();
          return;
        }
        requestAnimationFrame(tick);
        return;
      }
    }
    requestAnimationFrame(tick);
  });
}

/* Phase 4: go home */
function simReturnHome(){
  return new Promise(resolve=>{
    function tick(){
      if(!running) return resolve();

      const dx = START_X - WORLD.robot.x;
      const dy = START_Y - WORLD.robot.y;
      const dist = Math.hypot(dx, dy);

      if (dist < 4){
        WORLD.robot.x = START_X;
        WORLD.robot.y = START_Y;
        WORLD.robot.heading = START_HEADING;
        drawWorld("done");
        resolve();
        return;
      }

      const targetDeg = (Math.atan2(dy,dx)*180/Math.PI + 360) % 360;
      rotateTowards(targetDeg, 2);
      stepForward(SPEED_RETURN);
      drawWorld("Phase 4: return to start (slow)");

      requestAnimationFrame(tick);
    }
    requestAnimationFrame(tick);
  });
}

/* ============================================================
   MAIN RUN BUTTON HANDLER
   - checks that student code is reasonable
   - checks that they inserted solution (simulationReady)
   - runs sim
   - sendEvent("sim") on success
============================================================ */
async function runMission(){
  if (!simulationReady){
    setStatus("error","ERROR");
    errorEl.textContent = "‚ö†Ô∏è Please click 'Solution ‚Üí Insert' first!";
    return;
  }

  const { ok, errors } = validateStudentCode(editorEl.value);
  if (!ok){
    setStatus("error","ERROR");
    outputEl.textContent = "Please fix first:\n" + errors.join("\n");
    errorEl.textContent  = "";
    return;
  }

  if (running) return;
  running = true;

  setStatus("running","running‚Ä¶");
  outputEl.textContent = "";
  errorEl.textContent  = "";

  resetWorld();

  await simApproachLine();
  await simFollowLineToWall();
  await simTouchBackAndTurn();
  await simReturnHome();

  running = false;
  setStatus("ok","done.");
  outputEl.textContent =
    "Simulation finished (slow profile): approach line ‚Üí follow line (slow) ‚Üí touch & slow backup ‚Üí turn ‚Üí return.";

  // Fortschritt markieren
  sendEvent("sim");
}

/* ============================================================
   OTHER BUTTONS
============================================================ */
resetBtn.onclick = ()=>{
  running = false;
  setStatus("","");
  outputEl.textContent="";
  errorEl.textContent="";
  resetWorld();
};

saveBtn.onclick = ()=>{
  const blob = new Blob([editorEl.value], {type:"text/plain"});
  const a = document.createElement("a");
  a.href = URL.createObjectURL(blob);
  a.download="main.py";
  a.click();
  URL.revokeObjectURL(a.href);

  // Fortschritt markieren
  sendEvent("download");
};

runBtn.onclick = runMission;

/* ============================================================
   INIT
============================================================ */
resetWorld();
setStatus("","");
</script>
</body>
</html>
