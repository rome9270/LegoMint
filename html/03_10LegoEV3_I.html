<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>EV3 (Pybricks) ‚Äì Line Follower + TouchSensor Return</title>

  <link rel="stylesheet" href="../css/03_python.css" />
  <style>
    #arena {
      background:#f9fafb;
      border:2px solid #111;
      width:100%;
      height:auto;
      max-width:900px;
      border-radius:10px;
      display:block;
      margin-top:10px;
    }

    .status.ok { color:#15803d; }
    .status.error { color:#b91c1c; }
    .status.running { color:#374151; }
    .muted { color:#6b7280; }
    #error { color:#b91c1c; white-space:pre-wrap; }
  </style>
</head>
<body>
  <!-- NAV (einziger Block) -->
  <nav class="link-grid" aria-label="Topic selection">
    <a class="btn" href="../app/01_main.php" id="go-main" aria-label="Back to main">‚¨ÖÔ∏è Going to main</a>
    <a class="btn" href="../app/logout.php">üö™ Logout</a>
    <a class="btn primary" id="next-btn" href="03_10LegoEV3_I.html">Next ‚Üí</a>
  </nav>

  <header class="row" style="justify-content: space-between;">
    <div>
      <h1>EV3 (Pybricks) ¬∑ Line Follower + TouchSensor Return</h1>

      <p>Your robot should:</p>
      <ol>
        <li>Drive straight until it reaches the black line.</li>
        <li>Follow the line using the ColorSensor on <b>Port S1</b>.</li>
        <li>Stop when the TouchSensor on <b>Port S3</b> hits the wall.</li>
        <li>Back up, turn 180¬∞, and drive back to the start position.</li>
      </ol>

      <p class="muted">
        ‚Ä¢ The editor is only a scaffold / help text.<br>
        ‚Ä¢ Click <b>‚úÖ Solution ‚Üí Insert</b> to load the working code (SLOW version for real robot).<br>
        ‚Ä¢ Then press <b>‚ñ∂ Run</b> to watch the simulation of the mission.<br>
        ‚Ä¢ The simulation does NOT execute the Python code ‚Äì it just visualizes the steps.
      </p>
    </div>

    <div class="row">
      <button class="btn" id="tips-btn">üí° Tips</button>
      <button class="btn" id="solution-btn">‚úÖ Solution</button>
    </div>
  </header>

  <main class="layout">
    <!-- EDITOR -->
    <section class="card">
      <h2>Editor</h2>

      <div class="row">
        <button class="btn primary" id="run-btn">‚ñ∂ Run</button>
        <button class="btn" id="reset-btn">‚ü≤ Reset</button>
        <button class="btn" id="save-btn">üíæ Save</button>
        <span id="status" class="status" aria-live="polite"></span>
      </div>

<textarea id="editor" spellcheck="false">#!/usr/bin/env pybricks-micropython
# EV3 (Pybricks) ‚Äì Line Follower (Scaffold)
# This is NOT yet the final solution.
# Use "‚úÖ Solution ‚Üí Insert" to get a working slow version for the real robot.

from pybricks.hubs import EV3Brick
from pybricks.ev3devices import Motor, ColorSensor, TouchSensor
from pybricks.parameters import Port, Stop
from pybricks.tools import wait
from pybricks.robotics import DriveBase

brick = EV3Brick()
left  = Motor(Port.A)
right = Motor(Port.B)
color = ColorSensor(Port.S1)
touch = TouchSensor(Port.S3)
drive = DriveBase(left, right, 56, 114)

# TODO:
# 1) Drive forward until black line detected
# 2) Follow the line using reflection() + P-controller
# 3) Stop when TouchSensor pressed (wall)
# 4) Back up slowly, turn 180¬∞, drive back to start

brick.speaker.beep()
brick.screen.print("Start coding!")
wait(500)
</textarea>
    </section>

    <!-- SIMULATION -->
    <section class="card">
      <h2>Simulation</h2>

      <canvas id="arena" width="600" height="300"></canvas>
      <p class="muted">
        Robot (green) drives to the black line, follows it slowly,
        stops at the red wall, backs up, turns, and returns to start.
      </p>

      <pre id="output"></pre>
      <div id="error"></div>
    </section>
  </main>

  <!-- TIPS MODAL -->
  <dialog id="tips-modal">
    <div class="modal-header">Tips</div>
    <div class="modal-body">
      <ul>
        <li>ColorSensor(Port.S1).reflection() gives brightness 0..100.</li>
        <li>You pick a <code>target</code> (like 30) and compute <code>error = target - value</code>.</li>
        <li>Then <code>steer = error * kp</code> (kp is a tuning factor).</li>
        <li>Use <code>drive.drive(SLOW_SPEED_MM_S, steer)</code> ‚Üí <b>slow is better</b>.</li>
        <li>When TouchSensor is pressed: stop, back up slowly, turn, drive home.</li>
      </ul>
    </div>
    <div class="modal-actions">
      <button class="btn" id="close-tips">Close</button>
    </div>
  </dialog>

  <!-- SOLUTION MODAL -->
  <dialog id="solution-modal">
    <div class="modal-header">Solution (Slow / Real Robot)</div>
    <div class="modal-body">
<pre id="solution-code" style="white-space:pre-wrap;">#!/usr/bin/env pybricks-micropython
from pybricks.hubs import EV3Brick
from pybricks.ev3devices import Motor, ColorSensor, TouchSensor
from pybricks.parameters import Port, Stop
from pybricks.tools import wait
from pybricks.robotics import DriveBase

brick = EV3Brick()
left  = Motor(Port.A)
right = Motor(Port.B)
color = ColorSensor(Port.S1)
touch = TouchSensor(Port.S3)
drive = DriveBase(left, right, 56, 114)

# ------------------------------
# TUNING FOR REAL ROBOT (SLOW):
# ------------------------------
LINE_DETECT_THRESHOLD = 20      # reflection < 20 => black line seen
FOLLOW_SPEED_MM_S     = 60      # SLOW line-follow speed (was 100)
KP                     = 1.2    # smaller kp => smoother, less oscillation
TARGET_REFLECTION     = 30      # "aim" brightness between black & white
BACKUP_SPEED_MM_S     = -80     # slow reverse (negative = backwards)
BACKUP_TIME_MS        = 1000    # 1s back away from wall
RETURN_SPEED_MM_S     = 120     # go home speed (still not crazy fast)

# === 1) Drive until black line ===
while True:
    drive.drive(80, 0)  # approach speed slower than before
    if color.reflection() < LINE_DETECT_THRESHOLD:
        break
    wait(10)
drive.stop(Stop.BRAKE)

# === 2) Follow line (slow) until wall hit ===
while not touch.pressed():
    value = color.reflection()
    error = TARGET_REFLECTION - value
    steer = error * KP
    drive.drive(FOLLOW_SPEED_MM_S, steer)
    wait(15)  # slightly more wait for stability
drive.stop(Stop.BRAKE)
brick.speaker.beep()

# === 3) Back up slowly, then turn 180 ===
drive.drive(BACKUP_SPEED_MM_S, 0)
wait(BACKUP_TIME_MS)
drive.stop(Stop.BRAKE)

drive.turn(180)

# === 4) Go home (straight) ===
drive.drive(RETURN_SPEED_MM_S, 0)
wait(3000)  # depends on how far you drove
drive.stop(Stop.BRAKE)

brick.speaker.beep()
brick.screen.print("Mission complete!")
wait(500)
</pre>
    </div>
    <div class="modal-actions">
      <button class="btn" id="copy-solution">Insert</button>
      <button class="btn" id="close-solution">Close</button>
    </div>
  </dialog>

<script>
/* ============================================================
   DOM ELEMENTS
============================================================ */
const runBtn        = document.getElementById("run-btn");
const resetBtn      = document.getElementById("reset-btn");
const saveBtn       = document.getElementById("save-btn");
const editorEl      = document.getElementById("editor");
const statusEl      = document.getElementById("status");
const outputEl      = document.getElementById("output");
const errorEl       = document.getElementById("error");
const canvasEl      = document.getElementById("arena");

const tipsBtn       = document.getElementById("tips-btn");
const tipsModal     = document.getElementById("tips-modal");
const closeTipsBtn  = document.getElementById("close-tips");

const solutionBtn   = document.getElementById("solution-btn");
const solutionModal = document.getElementById("solution-modal");
const copySolution  = document.getElementById("copy-solution");
const closeSolution = document.getElementById("close-solution");

function setStatus(cls, txt){
  statusEl.className = "status " + cls;
  statusEl.textContent = txt;
}

/* ============================================================
   TUNING PARAMETERS FOR SIMULATION
   (SLOW VERSION FOR REAL ROBOT BEHAVIOR)
   -------------------------------------------------
   Diese Werte sind absichtlich langsam markiert.
   Du kannst sie √§ndern ohne den Rest anzufassen.
============================================================ */
// --- START / LINE / WALL GEOMETRY -----------------
const START_X        = 80;     // px
const START_Y        = 230;    // px
const START_HEADING  = -90;    // deg  (-90 = nach oben)

const LINE_Y         = 150;    // px  -> schwarze Linie verl√§uft horizontal
const WALL_X         = 480;    // px  -> wo die Wand steht
const WALL_HEIGHT    = 60;     // px  -> L√§nge der roten Wand

// --- MOTION + CONTROL (LANGSAM ABGESTIMMT) --------
// SLOW-TUNED FOR REAL ROBOT:
const SPEED_APPROACH = 0.8;    // px/frame (war 1.5)  langsamer zur Linie
const SPEED_FOLLOW   = 0.8;    // px/frame (war 1.5)  langsamer auf Linie
const KP_FOLLOW      = 0.10;   // (war 0.18) kleiner => weniger Zickzack
const SPEED_BACK     = 0.6;    // px/frame r√ºckw√§rts weg von Wand (war 1.2)
const BACK_FRAMES    = 60;     // l√§nger r√ºckw√§rts: 60 Frames statt 40
const TURN_SPEED     = 4;      // deg/frame drehen nach dem Backup (war 6)
const SPEED_RETURN   = 1.0;    // px/frame Heimfahrt (war 2.0)

// -------------------------------------------------
// Steuert, ob wir laufen d√ºrfen:
let simulationReady  = false;
let running          = false;

/* ============================================================
   CANVAS / WORLD STATE
============================================================ */
const ctx = canvasEl.getContext("2d");
const deg2rad = d => d * Math.PI/180;

const WORLD = {
  robot: {
    x: START_X,
    y: START_Y,
    heading: START_HEADING,
    r: 6
  }
};

function drawWorld(label){
  // Hintergrund + Rand
  ctx.fillStyle="#fff";
  ctx.fillRect(0,0,canvasEl.width,canvasEl.height);

  ctx.strokeStyle="#111";
  ctx.lineWidth=2;
  ctx.strokeRect(0,0,canvasEl.width,canvasEl.height);

  // schwarze Linie
  ctx.strokeStyle="#000";
  ctx.lineWidth=4;
  ctx.beginPath();
  ctx.moveTo(0, LINE_Y);
  ctx.lineTo(canvasEl.width, LINE_Y);
  ctx.stroke();

  // rote Wand
  ctx.strokeStyle="#b91c1c";
  ctx.lineWidth=4;
  ctx.beginPath();
  ctx.moveTo(WALL_X, LINE_Y - WALL_HEIGHT/2);
  ctx.lineTo(WALL_X, LINE_Y + WALL_HEIGHT/2);
  ctx.stroke();

  // Roboter gr√ºn
  const r = WORLD.robot;
  ctx.fillStyle="#16a34a";
  ctx.beginPath();
  ctx.arc(r.x, r.y, r.r, 0, Math.PI*2);
  ctx.fill();

  // Heading-Pfeil
  ctx.strokeStyle="#16a34a";
  ctx.lineWidth=2;
  ctx.beginPath();
  ctx.moveTo(r.x, r.y);
  ctx.lineTo(
    r.x + Math.cos(deg2rad(r.heading))*15,
    r.y + Math.sin(deg2rad(r.heading))*15
  );
  ctx.stroke();

  if (label){
    ctx.fillStyle="#374151";
    ctx.font="12px sans-serif";
    ctx.fillText(label, 10, 20);
  }
}

function resetWorld(){
  WORLD.robot.x = START_X;
  WORLD.robot.y = START_Y;
  WORLD.robot.heading = START_HEADING;
  drawWorld("ready (slow)");
}

/* ============================================================
   SMALL HELPERS
============================================================ */
function stepForward(px){
  WORLD.robot.x += Math.cos(deg2rad(WORLD.robot.heading)) * px;
  WORLD.robot.y += Math.sin(deg2rad(WORLD.robot.heading)) * px;
}

function rotateTowards(targetDeg, maxStepDeg){
  let cur = WORLD.robot.heading;
  let diff = targetDeg - cur;
  diff = ((diff + 540) % 360) - 180; // normalize to [-180..180]
  const step = Math.sign(diff) * Math.min(Math.abs(diff), maxStepDeg);
  WORLD.robot.heading = (cur + step + 360) % 360;
}

/* ============================================================
   PHASE 1:
   Drive forward (upwards) slowly until we hit the line.
============================================================ */
function simApproachLine(){
  return new Promise(resolve=>{
    function tick(){
      if(!running) return resolve();

      // vorw√§rts in aktueller Heading (START_HEADING = -90, also nach oben)
      stepForward(SPEED_APPROACH);

      drawWorld("Phase 1: approach line (slow)");

      // schon bei der Linie angekommen?
      if (Math.abs(WORLD.robot.y - LINE_Y) < 2){
        WORLD.robot.y = LINE_Y;
        WORLD.robot.heading = 0; // nach rechts ausrichten
        resolve();
        return;
      }

      requestAnimationFrame(tick);
    }
    requestAnimationFrame(tick);
  });
}

/* ============================================================
   PHASE 2:
   Follow the line to the wall using slow P-control.
   error = (LINE_Y - current_y)
   heading += KP_FOLLOW * error
============================================================ */
function simFollowLineToWall(){
  return new Promise(resolve=>{
    function tick(){
      if(!running) return resolve();

      const error = LINE_Y - WORLD.robot.y;
      const steerDeg = KP_FOLLOW * error; // kleiner KP => weiche Korrektur
      WORLD.robot.heading = (WORLD.robot.heading + steerDeg + 360) % 360;

      stepForward(SPEED_FOLLOW);

      drawWorld("Phase 2: follow line (slow)");

      // TouchSensor: Wand erreicht?
      if (WORLD.robot.x + WORLD.robot.r >= WALL_X){
        resolve();
        return;
      }

      requestAnimationFrame(tick);
    }
    requestAnimationFrame(tick);
  });
}

/* ============================================================
   BEEP helper
============================================================ */
function beepSound(){
  try {
    const ac = new AudioContext();
    const osc = ac.createOscillator();
    osc.type = "sine";
    osc.frequency.value = 800;
    osc.connect(ac.destination);
    osc.start();
    osc.stop(ac.currentTime + 0.2);
  } catch(e){}
}

/* ============================================================
   PHASE 3:
   Stop at wall ‚Üí beep ‚Üí back up SLOWLY ‚Üí rotate toward start.
   This matches: bumper hits, robot backs away, turns.
============================================================ */
function simTouchBackAndTurn(){
  return new Promise(resolve=>{
    let framesBack = 0;
    let phaseStep = 0;
    // 0 = beep & pause
    // 1 = slow reverse
    // 2 = rotate towards start

    function tick(){
      if(!running) return resolve();

      if (phaseStep === 0){
        drawWorld("Phase 3: touch! stop + beep");
        beepSound();
        phaseStep = 1;
        framesBack = 0;
        requestAnimationFrame(tick);
        return;
      }

      if (phaseStep === 1){
        // r√ºckw√§rts langsam:
        // Trick: Heading um 180 drehen, vorw√§rts Schritt, Heading zur√ºck
        WORLD.robot.heading = (WORLD.robot.heading + 180) % 360;
        stepForward(SPEED_BACK); // SPEED_BACK jetzt klein!
        WORLD.robot.heading = (WORLD.robot.heading + 180) % 360;

        framesBack++;

        drawWorld("Phase 3: backing away (slow)");

        if (framesBack >= BACK_FRAMES){
          phaseStep = 2;
        }
        requestAnimationFrame(tick);
        return;
      }

      if (phaseStep === 2){
        // richte Heading Richtung Start aus (drehe langsam)
        const dx = START_X - WORLD.robot.x;
        const dy = START_Y - WORLD.robot.y;
        const targetDeg = (Math.atan2(dy,dx)*180/Math.PI + 360) % 360;

        rotateTowards(targetDeg, TURN_SPEED); // TURN_SPEED reduziert!

        drawWorld("Phase 3: turning to home");

        // Abbruch wenn wir fast genau heimw√§rts schauen
        let diff = targetDeg - WORLD.robot.heading;
        diff = ((diff + 540) % 360) - 180;
        if (Math.abs(diff) < 5){
          resolve();
          return;
        }

        requestAnimationFrame(tick);
        return;
      }
    }

    requestAnimationFrame(tick);
  });
}

/* ============================================================
   PHASE 4:
   Drive back home (slow).
   Drive until we're basically at START_X / START_Y.
============================================================ */
function simReturnHome(){
  return new Promise(resolve=>{
    function tick(){
      if(!running) return resolve();

      const dx = START_X - WORLD.robot.x;
      const dy = START_Y - WORLD.robot.y;
      const dist = Math.hypot(dx, dy);

      if (dist < 4){
        WORLD.robot.x = START_X;
        WORLD.robot.y = START_Y;
        WORLD.robot.heading = START_HEADING;
        drawWorld("done");
        resolve();
        return;
      }

      // sanft Richtung Start drehen
      const targetDeg = (Math.atan2(dy,dx)*180/Math.PI + 360) % 360;
      rotateTowards(targetDeg, 2); // noch langsamer drehen nach Hause
      stepForward(SPEED_RETURN);   // SPEED_RETURN reduziert

      drawWorld("Phase 4: return to start (slow)");
      requestAnimationFrame(tick);
    }
    requestAnimationFrame(tick);
  });
}

/* ============================================================
   MAIN MISSION RUN
============================================================ */
async function runMission(){
  if (!simulationReady){
    setStatus("error","ERROR");
    errorEl.textContent = "‚ö†Ô∏è Please click 'Solution ‚Üí Insert' first!";
    return;
  }
  if (running) return;

  running = true;
  setStatus("running","running‚Ä¶");
  outputEl.textContent = "";
  errorEl.textContent  = "";

  resetWorld();

  // Phase 1: langsam zur Linie
  await simApproachLine();

  // Phase 2: langsam Linie folgen
  await simFollowLineToWall();

  // Phase 3: stoppen, piep, LANGSAM zur√ºck, drehen
  await simTouchBackAndTurn();

  // Phase 4: langsam heimfahren
  await simReturnHome();

  running = false;
  setStatus("ok","done.");
  outputEl.textContent =
    "Simulation finished (slow profile): approach line ‚Üí follow line (slow) ‚Üí touch & slow backup ‚Üí turn ‚Üí return.";
}

/* ============================================================
   BUTTONS / MODALS
============================================================ */
runBtn.onclick = runMission;

resetBtn.onclick = ()=>{
  running = false;
  setStatus("","");
  outputEl.textContent="";
  errorEl.textContent="";
  resetWorld();
};

saveBtn.onclick = ()=>{
  const blob = new Blob([editorEl.value], {type:"text/plain"});
  const a = document.createElement("a");
  a.href = URL.createObjectURL(blob);
  a.download="main.py";
  a.click();
  URL.revokeObjectURL(a.href);
};

tipsBtn.onclick = ()=>{
  if (tipsModal.showModal) tipsModal.showModal();
  else tipsModal.setAttribute("open","");
};
closeTipsBtn.onclick = ()=>{
  if (tipsModal.close) tipsModal.close();
  else tipsModal.removeAttribute("open");
};

solutionBtn.onclick = ()=>{
  if (solutionModal.showModal) solutionModal.showModal();
  else solutionModal.setAttribute("open","");
};

closeSolution.onclick = ()=>{
  if (solutionModal.close) solutionModal.close();
  else solutionModal.removeAttribute("open");
};

copySolution.onclick = ()=>{
  editorEl.value = document.getElementById("solution-code").textContent;
  simulationReady = true;

  if (solutionModal.close) solutionModal.close();
  else solutionModal.removeAttribute("open");

  setStatus("ok","Ready to run");
  outputEl.textContent = "Slow solution inserted. Now press ‚ñ∂ Run.";
  errorEl.textContent  = "";

  resetWorld();
};

/* ============================================================
   INIT
============================================================ */
resetWorld();
setStatus("","");

</script>
</body>
</html>
