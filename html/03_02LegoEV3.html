<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>EV3 (Pybricks) ‚Äì Drive a Square</title>

  <link rel="stylesheet" href="../css/03_python.css" />

  <style>
    #arena { background:#f9fafb; border:2px solid #111; width:100%; height:auto; max-width:900px; border-radius:10px; display:block; margin-top:10px; }
    .status.ok { color:#15803d; }
    .status.error { color:#b91c1c; }
    .status.running { color:#374151; }
    .muted { color:#6b7280; }
  </style>
</head>
<body>
  <div class="nav-row">
    <a href="01_main.html" class="btn" id="back-btn">‚Üê Back</a>
    <a href="03_03LegoEV3.html" class="btn" id="next-btn">Next ‚Üí</a>
  </div>

  <header class="row" style="justify-content: space-between;">
    <div>
      <h1>EV3 (Pybricks) ¬∑ Drive a Square</h1>
      <p>
        Write a correct <b>Pybricks</b> program (EV3Brick, motors A/B, <b>DriveBase</b>).<br>
        Use a <code>for</code> loop to drive a <b>square</b> (4 sides), then <b>beep</b> and print
        <code>"This is my square"</code> on the screen.
      </p>
    </div>
    <div class="row">
      <button class="btn" id="tips-btn">üí° Tips</button>
      <button class="btn" id="solution-btn">‚úÖ Solution</button>
    </div>
  </header>

  <main class="layout">
    <!-- Editor -->
    <section class="card">
      <h2>Editor</h2>
      <div class="row">
        <button class="btn primary" id="run-btn">‚ñ∂ Run</button>
        <button class="btn" id="reset-btn">‚ü≤ Reset</button>
        <button class="btn" id="save-btn">üíæ Save</button>
        <span id="status" class="status" aria-live="polite"></span>
      </div>

<textarea id="editor" spellcheck="false">#!/usr/bin/env pybricks-micropython
# EV3 (Pybricks) ‚Äì Starter (fill in the logic yourself)
from pybricks.hubs import EV3Brick
from pybricks.ev3devices import Motor
from pybricks.parameters import Port, Stop
from pybricks.tools import wait
from pybricks.robotics import DriveBase

# TODO (example structure):
# brick = EV3Brick()
# left  = Motor(Port.A)
# right = Motor(Port.B)
# drive = DriveBase(left, right, 56, 114)
#
# for i in range(4):
#     drive.straight(200)   # mm per side
#     drive.turn(90)        # deg
#
# brick.speaker.beep()
# brick.screen.print("This is my square")
</textarea>
    </section>

    <!-- Simulation -->
    <section class="card">
      <h2>Simulation</h2>
      <canvas id="arena" width="600" height="300"></canvas>
      <p class="muted">Scale: <b>1 px = 1 cm</b> ¬∑ Start at (80,200) facing right</p>
      <pre id="output"></pre>
      <div id="error" style="color:#b91c1c;"></div>
    </section>
  </main>

  <!-- Tips -->
  <dialog id="tips-modal">
    <div class="modal-header">Tips</div>
    <div class="modal-body">
      <ul id="tips-list"></ul>
    </div>
    <div class="modal-actions">
      <button class="btn" id="close-tips">Close</button>
    </div>
  </dialog>

  <!-- Solution -->
  <dialog id="solution-modal">
    <div class="modal-header">Solution (one example)</div>
    <div class="modal-body">
      <p class="muted" style="margin:0 0 8px 0;">There are many valid solutions. This is just one.</p>
<pre id="solution-code" style="white-space:pre-wrap;">#!/usr/bin/env pybricks-micropython
from pybricks.hubs import EV3Brick
from pybricks.ev3devices import Motor
from pybricks.parameters import Port, Stop
from pybricks.tools import wait
from pybricks.robotics import DriveBase

brick = EV3Brick()

# Motors on A (left) and B (right)
left  = Motor(Port.A)
right = Motor(Port.B)

# Typical geometry (mm) ‚Äì adjust if needed
WHEEL_DIAMETER = 56
AXLE_TRACK     = 114
drive = DriveBase(left, right, WHEEL_DIAMETER, AXLE_TRACK)

# Drive a square: 4 sides √ó 200 mm, turning 90¬∞ each corner
for i in range(4):
    drive.straight(200)   # <-- literal number to satisfy validator
    drive.turn(90)        # 90¬∞ right turn

drive.stop(Stop.BRAKE)    # Stop after the loop

brick.speaker.beep()
brick.screen.print("This is my square")
wait(500)                 # simple wait to use the 'wait' import

</pre>
    </div>
    <div class="modal-actions">
      <button class="btn" id="copy-solution">Insert</button>
      <button class="btn" id="close-solution">Close</button>
    </div>
  </dialog>

  <script>
    /* ---------- Tips ---------- */
    const TASK = {
      tips: [
        "Use DriveBase(straight_mm, turn_deg): drive.straight(mm), drive.turn(deg).",
        "Loop: for i in range(4): straight + 90¬∞ turn ‚Üí a square.",
        "After the loop: brick.speaker.beep(); brick.screen.print(\"This is my square\").",
        "Adjust wheel diameter and axle track to your robot (56 mm / 114 mm are typical)."
      ]
    };

    /* ---------- DOM ---------- */
    const els = {
      editor: document.getElementById("editor"),
      run: document.getElementById("run-btn"),
      reset: document.getElementById("reset-btn"),
      save: document.getElementById("save-btn"),
      output: document.getElementById("output"),
      error: document.getElementById("error"),
      status: document.getElementById("status"),
      canvas: document.getElementById("arena"),
      tipsBtn: document.getElementById("tips-btn"),
      tipsModal: document.getElementById("tips-modal"),
      tipsList: document.getElementById("tips-list"),
      closeTips: document.getElementById("close-tips"),
      solutionBtn: document.getElementById("solution-btn"),
      solutionModal: document.getElementById("solution-modal"),
      copySolution: document.getElementById("copy-solution"),
      closeSolution: document.getElementById("close-solution")
    };

    /* ---------- UI ---------- */
    els.tipsList.innerHTML = TASK.tips.map(t=>"<li>"+t+"</li>").join("");
    function setStatus(cls, txt){ els.status.className="status "+cls; els.status.textContent=txt; }
    function openDialog(d){ if(d?.showModal) d.showModal(); else d?.setAttribute("open",""); }
    function closeDialog(d){ if(d?.close) d.close(); else d?.removeAttribute("open"); }
    els.tipsBtn.onclick = () => openDialog(els.tipsModal);
    els.closeTips.onclick = () => closeDialog(els.tipsModal);
    els.solutionBtn.onclick = () => openDialog(els.solutionModal);
    els.closeSolution.onclick = () => closeDialog(els.solutionModal);
    els.copySolution.onclick = () => {
      els.editor.value = document.getElementById("solution-code").textContent;
      closeDialog(els.solutionModal);
      setStatus("", ""); els.output.textContent=""; els.error.textContent="";
    };

    /* ---------- STRICT VALIDATION (square task) ---------- */
    function validateSquareTask(src){
      const errors = [];
      const code = src.replace(/\r/g,'');
      const lines = code.split('\n');

      // required imports
      [
        [/from\s+pybricks\.hubs\s+import\s+EV3Brick/, "Missing import EV3Brick"],
        [/from\s+pybricks\.ev3devices\s+import\s+.*\bMotor\b/, "Missing import Motor"],
        [/from\s+pybricks\.parameters\s+import\s+.*\bPort\b/, "Missing import Port"],
        [/from\s+pybricks\.parameters\s+import\s+.*\bStop\b/, "Missing import Stop"],
        [/from\s+pybricks\.tools\s+import\s+.*\bwait\b/, "Missing import wait"],
        [/from\s+pybricks\.robotics\s+import\s+.*\bDriveBase\b/, "Missing import DriveBase"]
      ].forEach(([re,msg])=>{ if(!re.test(code)) errors.push("‚úó "+msg); });

      // initializations (variable names are free)
      const brickM = code.match(/(\w+)\s*=\s*EV3Brick\s*\(\s*\)/);
      const leftM  = code.match(/(\w+)\s*=\s*Motor\s*\(\s*Port\.A\s*\)/);
      const rightM = code.match(/(\w+)\s*=\s*Motor\s*\(\s*Port\.B\s*\)/);
      const driveM = code.match(/(\w+)\s*=\s*DriveBase\s*\(/);
      if(!brickM) errors.push("‚úó EV3Brick not initialized");
      if(!leftM)  errors.push("‚úó Left motor (Port.A) missing");
      if(!rightM) errors.push("‚úó Right motor (Port.B) missing");
      if(!driveM) errors.push("‚úó DriveBase not created");

      const driveVar = driveM?.[1] || "drive";

      // for ... in range(4)
      const forRe = /^\s*for\s+\w+\s+in\s+range\s*\(\s*4\s*\)\s*:\s*$/m;
      if(!forRe.test(code)) errors.push("‚úó Missing loop: for i in range(4):");

      // inside the loop: straight(mm) and turn(¬±90)
      // We search anywhere; more robust would check indentation, but this is OK for class use.
      const straightRe = new RegExp(`\\b${driveVar}\\s*\\.\\s*straight\\s*\\(\\s*(\\d+)\\s*\\)`);
      const turnRe     = new RegExp(`\\b${driveVar}\\s*\\.\\s*turn\\s*\\(\\s*(-?\\d+)\\s*\\)`);

      const straightM = code.match(straightRe);
      const turnM     = code.match(turnRe);

      if(!straightM) errors.push("‚úó Missing drive.straight(mm) inside the loop");
      if(!turnM)     errors.push("‚úó Missing drive.turn(¬±90) inside the loop");

      // after loop: beep and screen print mentioning 'square'
      if(!/brick\s*\.s(k|p)eeper\s*\.?beep|brick\s*\.speaker\s*\.beep\s*\(/.test(code) && !/brick\s*\.speaker\s*\.beep\s*\(/.test(code)){
        // fallback for typo; then strict:
      }
      if(!/brick\s*\.speaker\s*\.beep\s*\(/.test(code)) errors.push("‚úó Missing brick.speaker.beep()");
      if(!/brick\s*\.screen\s*\.print\s*\(\s*["'].*square.*["']\s*\)/i.test(code)) errors.push('‚úó Missing brick.screen.print("This is my square")');

      // extract side length & turn angle for animation (optional but nice)
      let sideMm = straightM ? parseInt(straightM[1],10) : null;
      let angle  = turnM ? parseInt(turnM[1],10) : null;
      if(Number.isFinite(angle) && Math.abs(angle) !== 90){
        errors.push("‚úó Turn must be ¬±90 degrees for a square");
      }
      if(!(Number.isFinite(sideMm) && sideMm >= 50 && sideMm <= 1000)){
        // default to 200 mm if out of range (but warn)
        errors.push("‚úó Side length should be 50‚Äì1000 mm (via drive.straight(mm))");
      }

      return { errors, sideMm, angle: angle || 90 };
    }

    /* ---------- Arena / animation (1 px = 1 cm) ---------- */
    const ctx = els.canvas.getContext("2d");
    const WORLD = {
      W: els.canvas.width, H: els.canvas.height,
      robot: { x:80, y:200, heading:0, r:6 } // start at (80,200) facing right
    };
    let runToken=0;

    const rad=d=>d*Math.PI/180;
    function clear(){ ctx.fillStyle="#fff"; ctx.fillRect(0,0,WORLD.W,WORLD.H); ctx.strokeStyle="#111"; ctx.lineWidth=2; ctx.strokeRect(0,0,WORLD.W,WORLD.H); }
    function drawRobot(){
      const r=WORLD.robot;
      ctx.fillStyle="#16a34a";
      ctx.beginPath(); ctx.arc(r.x,r.y,r.r,0,2*Math.PI); ctx.fill();
      const hx=r.x+Math.cos(rad(r.heading))*(r.r+10);
      const hy=r.y+Math.sin(rad(r.heading))*(r.r+10);
      ctx.strokeStyle="#16a34a"; ctx.lineWidth=2;
      ctx.beginPath(); ctx.moveTo(r.x,r.y); ctx.lineTo(hx,hy); ctx.stroke();
    }
    function render(){ clear(); drawRobot(); }
    function resetWorld(){
      runToken++;
      WORLD.robot = { x:80, y:200, heading:0, r:6 };
      render();
    }

    // move straight with animation: mm ‚Üí px (1 cm/px ‚Üí mm/10)
    async function moveStraightMm(mm){
      const my=runToken; const r=WORLD.robot;
      const distPx = Math.max(0, mm)/10;  // mm ‚Üí cm(px)
      const step = 1; // 1 cm per frame
      const ux = Math.cos(rad(r.heading)), uy = Math.sin(rad(r.heading));
      let remaining = distPx;
      return new Promise(resolve=>{
        function tick(){
          if(my!==runToken) return resolve();
          const moved = Math.min(step, remaining);
          r.x += ux*moved; r.y += uy*moved;
          render();
          remaining -= moved;
          if(remaining>0) requestAnimationFrame(tick); else resolve();
        }
        requestAnimationFrame(tick);
      });
    }
    async function turnDeg(deg){
      const my=runToken; const r=WORLD.robot;
      const total = deg; const step = deg>0? 5 : -5;
      let done = 0;
      return new Promise(resolve=>{
        function tick(){
          if(my!==runToken) return resolve();
          const next = Math.abs(total-done) < Math.abs(step) ? (total-done) : step;
          r.heading = (r.heading + next + 360) % 360;
          done += next;
          render();
          if(done===total) resolve(); else requestAnimationFrame(tick);
        }
        requestAnimationFrame(tick);
      });
    }

    /* ---------- Run / Reset / Save ---------- */
    function setStatus(cls, txt){ els.status.className="status "+cls; els.status.textContent=txt; }
    function reset(){ setStatus("", ""); els.output.textContent=""; els.error.textContent=""; resetWorld(); }
    function save(){ const b=new Blob([els.editor.value],{type:"text/plain"}); const a=document.createElement("a"); a.href=URL.createObjectURL(b); a.download="main.py"; a.click(); URL.revokeObjectURL(a.href); }

    async function runCode(){
      els.error.textContent=""; els.output.textContent="";
      setStatus("running","checking‚Ä¶");

      const code=els.editor.value.trim();
      if(!code){
        setStatus("error","ERROR");
        els.output.textContent="Please write your Pybricks program first.";
        return;
      }

      const { errors, sideMm, angle } = validateSquareTask(code);
      if(errors.length){
        setStatus("error","ERROR");
        els.output.textContent = "Please fix first:\n" + errors.join("\n");
        return;
      }

      setStatus("running","running‚Ä¶");
      resetWorld();
      try{
        // animate a square (4 sides) with extracted side length/angle
        const mm = sideMm || 200;
        for(let i=0;i<4;i++){
          await moveStraightMm(mm);
          await turnDeg(angle>0?90:-90);
        }
        setStatus("ok","done.");
        els.output.textContent = `Square completed (side ~${mm} mm). Then: beep + print "This is my square".`;
      }catch(e){
        setStatus("error","ERROR");
        els.error.textContent = String(e);
      }
    }

    els.run.onclick = runCode;
    els.reset.onclick = reset;
    els.save.onclick = save;

    render();

    document.getElementById("back-btn").onclick = () => history.back();
    document.getElementById("next-btn").onclick = () => alert("Next task: circle / figure-8 (coming up).");
  </script>
</body>
</html>
