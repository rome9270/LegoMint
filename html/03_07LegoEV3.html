<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>EV3 (Pybricks) ¬∑ Touch + Gyro: Bump 2 Walls & Exit</title>

  <link rel="stylesheet" href="../css/03_python.css" />

  <style>
    #arena { background:#f9fafb; border:2px solid #111; width:100%; height:240px; max-width:900px; border-radius:10px; display:block; margin-top:10px; }
    .status.ok { color:#15803d; }
    .status.error { color:#b91c1c; }
    .status.running { color:#374151; }
    .muted { color:#6b7280; }
    #error { color:#b91c1c; white-space:pre-wrap; }
  </style>
</head>
<body>
  <div class="nav-row">
    <a href="01_main.html" class="btn" id="back-btn">‚Üê Back</a>
    <a href="#" class="btn primary" id="next-btn">Next ‚Üí</a>
  </div>

  <header class="row" style="justify-content: space-between;">
    <div>
      <h1>EV3 (Pybricks) ¬∑ Touch + Gyro ‚Äî Bump 2 walls & leave the building</h1>
      <p>
        Write a correct <b>Pybricks program</b> (EV3Brick, motors A/B, <b>Touch S3</b>, <b>Gyro S4</b>) that
        <b>drives upward and bumps the top wall</b>, <b>backs ~50&nbsp;mm</b>, then <b>rotates RIGHT by 90¬∞ using the gyroscope</b>,
        <b>bumps the right wall</b>, <b>backs ~50&nbsp;mm</b>, <b>rotates RIGHT by 90¬∞ using the gyroscope</b> again, and finally
        <b>exits the building</b> through the door on the bottom wall (right side).
        <br>Use a gyro feedback loop (e.g. <code>gyro.reset_angle(0)</code> then <code>while abs(gyro.angle()) &lt; 90: ...</code>).
        <b>Do not use <code>drive.turn(...)</code>.</b>
      </p>
    </div>
    <div class="row">
      <button class="btn" id="tips-btn">üí° Tips</button>
      <button class="btn" id="solution-btn">‚úÖ Solution</button>
    </div>
  </header>

  <main class="layout">
    <section class="card">
      <h2>Editor</h2>
      <div class="row">
        <button class="btn primary" id="run-btn">‚ñ∂ Run</button>
        <button class="btn" id="reset-btn">‚ü≤ Reset</button>
        <button class="btn" id="save-btn">üíæ Save</button>
        <span id="status" class="status" aria-live="polite"></span>
      </div>

<textarea id="editor" spellcheck="false">#!/usr/bin/env pybricks-micropython
# Touch + Gyro task: bump top ‚Üí back ‚Üí gyro-right 90; bump right ‚Üí back ‚Üí gyro-right 90; exit
from pybricks.hubs import EV3Brick
from pybricks.ev3devices import Motor, TouchSensor, GyroSensor
from pybricks.parameters import Port, Stop
from pybricks.tools import wait
from pybricks.robotics import DriveBase

# Initialize
brick = EV3Brick()
left  = Motor(Port.A)
right = Motor(Port.B)
touch = TouchSensor(Port.S3)
gyro  = GyroSensor(Port.S4)           # <-- Gyro on S4
drive = DriveBase(left, right, 56, 114)

# TIP: use gyro.reset_angle(0) and a loop to hit exactly 90¬∞
# Example structure (fill in yourself):
# # 1) Up to top wall
# drive.drive(150, 0)
# while not touch.pressed():
#     wait(10)
# drive.stop(Stop.BRAKE)
# drive.straight(-50)
#
# # Gyro right turn (~ -90¬∞)
# gyro.reset_angle(0)
# drive.drive(0, -90)               # rotate in place to the right
# while abs(gyro.angle()) < 90:
#     wait(10)
# drive.stop(Stop.BRAKE)
#
# # 2) Right to right wall
# drive.drive(150, 0)
# while not touch.pressed():
#     wait(10)
# drive.stop(Stop.BRAKE)
# drive.straight(-50)
#
# # Gyro right turn again (~ -90¬∞) to face downward
# gyro.reset_angle(0)
# drive.drive(0, -90)
# while abs(gyro.angle()) < 90:
#     wait(10)
# drive.stop(Stop.BRAKE)
#
# # 3) Leave the building (downwards through the bottom-right door)
# drive.drive(150, 0)
# wait(1200)  # adjust if needed on the real robot
# drive.stop(Stop.BRAKE)
# brick.speaker.beep()
</textarea>
    </section>

    <section class="card">
      <h2>Simulation</h2>
      <canvas id="arena" width="640" height="240"></canvas>
      <p class="muted">
        Scale: <b>1 px = 1 cm</b> ¬∑ Room walls at left x=40, top y=40, right x=600, bottom y=200 ¬∑
        Door in bottom wall: <b>x=560‚Äì600</b> (right side). Start at (120, 120), facing up.
      </p>
      <pre id="output"></pre>
      <div id="error"></div>
    </section>
  </main>

  <!-- Tips -->
  <dialog id="tips-modal">
    <div class="modal-header">Tips</div>
    <div class="modal-body">
      <ul id="tips-list"></ul>
    </div>
    <div class="modal-actions">
      <button class="btn" id="close-tips">Close</button>
    </div>
  </dialog>

  <!-- Solution -->
  <dialog id="solution-modal">
    <div class="modal-header">Solution (one example)</div>
    <div class="modal-body">
<pre id="solution-code" style="white-space:pre-wrap;">#!/usr/bin/env pybricks-micropython
from pybricks.hubs import EV3Brick
from pybricks.ev3devices import Motor, TouchSensor, GyroSensor
from pybricks.parameters import Port, Stop
from pybricks.tools import wait
from pybricks.robotics import DriveBase

brick = EV3Brick()
left  = Motor(Port.A)
right = Motor(Port.B)
touch = TouchSensor(Port.S3)
gyro  = GyroSensor(Port.S4)
drive = DriveBase(left, right, 56, 114)

# 1) Up to top wall
drive.drive(150, 0)
while not touch.pressed():
    wait(10)
drive.stop(Stop.BRAKE)
drive.straight(-50)

# Gyro right turn ~90¬∞
gyro.reset_angle(0)
drive.drive(0, -90)            # rotate to the right using gyro feedback
while abs(gyro.angle()) < 90:
    wait(10)
drive.stop(Stop.BRAKE)

# 2) Right to right wall
drive.drive(150, 0)
while not touch.pressed():
    wait(10)
drive.stop(Stop.BRAKE)
drive.straight(-50)

# Gyro right turn again ~90¬∞ to face downward
gyro.reset_angle(0)
drive.drive(0, -90)
while abs(gyro.angle()) < 90:
    wait(10)
drive.stop(Stop.BRAKE)

# 3) Leave the building (downwards through right-side door)
drive.drive(150, 0)
wait(1200)
drive.stop(Stop.BRAKE)
brick.speaker.beep()
</pre>
    </div>
    <div class="modal-actions">
      <button class="btn" id="copy-solution">Insert</button>
      <button class="btn" id="close-solution">Close</button>
    </div>
  </dialog>

  <script>
    /* ---------- Tips content ---------- */
    const TASK = {
      tips: [
        'Touch: <code>touch = TouchSensor(Port.S3)</code> ; pressed? <code>touch.pressed()</code>.',
        'Gyro: <code>gyro = GyroSensor(Port.S4)</code>, then <code>gyro.reset_angle(0)</code> before each rotation.',
        'Rotate right with feedback: <code>drive.drive(0, -90)</code> and <code>while abs(gyro.angle()) &lt; 90: wait(10)</code>.',
        'Stop with <code>drive.stop(Stop.BRAKE)</code> after rotation.',
        'Back off after bumps: <code>drive.straight(-50)</code> (30‚Äì200 mm ok).',
        'Do not use <code>drive.turn(...)</code> for this task; use the gyroscope loop.',
      ]
    };

    /* ---------- DOM ---------- */
    const els = {
      editor: document.getElementById("editor"),
      run: document.getElementById("run-btn"),
      reset: document.getElementById("reset-btn"),
      save: document.getElementById("save-btn"),
      output: document.getElementById("output"),
      error: document.getElementById("error"),
      status: document.getElementById("status"),
      canvas: document.getElementById("arena"),
      tipsBtn: document.getElementById("tips-btn"),
      tipsModal: document.getElementById("tips-modal"),
      tipsList: document.getElementById("tips-list"),
      closeTips: document.getElementById("close-tips"),
      solutionBtn: document.getElementById("solution-btn"),
      solutionModal: document.getElementById("solution-modal"),
      copySolution: document.getElementById("copy-solution"),
      closeSolution: document.getElementById("close-solution")
    };

    /* ---------- UI ---------- */
    els.tipsList.innerHTML = TASK.tips.map(t=>"<li>"+t+"</li>").join("");
    function setStatus(cls, txt){ els.status.className="status "+(cls||""); els.status.textContent=txt||""; }
    function openDialog(d){ if(d?.showModal) d.showModal(); else d?.setAttribute("open",""); }
    function closeDialog(d){ if(d?.close) d.close(); else d?.removeAttribute("open"); }
    els.tipsBtn.onclick = () => openDialog(els.tipsModal);
    els.closeTips.onclick = () => closeDialog(els.tipsModal);
    els.solutionBtn.onclick = () => openDialog(els.solutionModal);
    els.closeSolution.onclick = () => closeDialog(els.solutionModal);
    els.copySolution.onclick = () => { els.editor.value = document.getElementById("solution-code").textContent; closeDialog(els.solutionModal); els.output.textContent=""; els.error.textContent=""; setStatus("",""); };

    /* ---------- Helpers ---------- */
    function stripComments(s){
      let x = s.replace(/^[ \t]*#.*$/gm, "");  // full-line comments
      x = x.replace(/[ \t]+#.*$/gm, "");       // trailing comments
      return x;
    }

    /* ---------- Strict validation (Touch + Gyro) ---------- */
    function validate(src){
      els.output.textContent=""; els.error.textContent="";
      const raw = src.replace(/\r/g,"");
      const code = stripComments(raw);
      const lines = code.split("\n");
      const errors = [];

      if(code.trim()===""){ errors.push("Please write your Pybricks program first."); return {ok:false, errors}; }

      // Required imports
      [
        [/from\s+pybricks\.hubs\s+import\s+EV3Brick/, "Missing import: EV3Brick"],
        [/from\s+pybricks\.ev3devices\s+import\s+.*\bMotor\b/, "Missing import: Motor"],
        [/from\s+pybricks\.ev3devices\s+import\s+.*\bTouchSensor\b/, "Missing import: TouchSensor"],
        [/from\s+pybricks\.ev3devices\s+import\s+.*\bGyroSensor\b/, "Missing import: GyroSensor"],
        [/from\s+pybricks\.parameters\s+import\s+.*\bPort\b/, "Missing import: Port"],
        [/from\s+pybricks\.parameters\s+import\s+.*\bStop\b/, "Missing import: Stop"],
        [/from\s+pybricks\.tools\s+import\s+.*\bwait\b/, "Missing import: wait"],
        [/from\s+pybricks\.robotics\s+import\s+.*\bDriveBase\b/, "Missing import: DriveBase"]
      ].forEach(([re,msg])=>{ if(!re.test(code)) errors.push("‚úó "+msg); });

      // Inits
      const leftM  = code.match(/\b(\w+)\s*=\s*Motor\s*\(\s*Port\.A\s*\)/);
      const rightM = code.match(/\b(\w+)\s*=\s*Motor\s*\(\s*Port\.B\s*\)/);
      const touchM = code.match(/\b(\w+)\s*=\s*TouchSensor\s*\(\s*Port\.S3\s*\)/);
      const gyroM  = code.match(/\b(\w+)\s*=\s*GyroSensor\s*\(\s*Port\.S4\s*\)/);
      const driveM = code.match(/\b(\w+)\s*=\s*DriveBase\s*\(/);
      if(!/EV3Brick\s*\(\s*\)/.test(code)) errors.push("‚úó EV3Brick not initialized");
      if(!leftM)  errors.push("‚úó Left motor (Port.A) missing");
      if(!rightM) errors.push("‚úó Right motor (Port.B) missing");
      if(!touchM) errors.push("‚úó TouchSensor on S3 missing");
      if(!gyroM)  errors.push("‚úó GyroSensor on S4 missing");
      if(!driveM) errors.push("‚úó DriveBase not created");

      const driveVar = driveM?.[1] || "drive";
      const touchVar = touchM?.[1] || "touch";
      const gyroVar  = gyroM?.[1] || "gyro";

      // Two touch loops (top wall, right wall)
      const touchLoopRE = new RegExp(`^([ \\t]*)while\\s+not\\s+${touchVar}\\s*\\.\\s*pressed\\s*\\(\\s*\\)\\s*:\\s*$`);
      const loopIdx = [];
      for(let i=0;i<lines.length;i++){ if(lines[i].match(touchLoopRE)) loopIdx.push(i); }
      if(loopIdx.length < 2) errors.push("‚úó You must have two loops: while not touch.pressed(): (for the two walls)");

      // drive.drive before loops
      const driveStartRe = new RegExp(`\\b${driveVar}\\s*\\.\\s*drive\\s*\\(\\s*\\d+\\s*,\\s*0\\s*\\)`);
      if(!driveStartRe.test(code)) errors.push("‚úó Missing drive.drive(150, 0) before the touch loops");

      // wait() inside each touch loop
      for(const idx of loopIdx){
        let hasWait=false, indent=(lines[idx].match(/^([ \t]*)/)||["",""])[1];
        for(let j=idx+1;j<lines.length;j++){
          const L=lines[j]; if(L.trim()==="") continue;
          const ind=(L.match(/^([ \t]*)/)||["",""])[1];
          if(ind.length<=indent.length) break;
          if(/\bwait\s*\(/.test(L)){ hasWait=true; break; }
        }
        if(!hasWait){ errors.push("‚úó Missing wait(...) inside the touch loop"); break; }
      }

      // Must NOT use drive.turn(...)
      if(/\bdrive\s*\.\s*turn\s*\(/.test(code)) errors.push("‚úó Do not use drive.turn(...). Use a gyro feedback loop instead.");

      // Gyro-based rotations: require at least two while-loops referencing gyro.angle() and 90
      const gyroWhileRE = new RegExp(`^\\s*while\\s+.*${gyroVar}\\s*\\.\\s*angle\\s*\\(\\s*\\).*90\\s*[:)]`, "i");
      let gyroLoops = 0;
      for(const L of lines){ if(gyroWhileRE.test(L)) gyroLoops++; }
      if(gyroLoops < 2) errors.push("‚úó Provide two gyro loops, e.g. while abs(gyro.angle()) < 90: ...");

      // Rotation actuation inside rotation phase
      // Accept either drive.drive(0, ¬±omega) or opposite motor run pattern
      const hasDriveOmega = new RegExp(`\\b${driveVar}\\s*\\.\\s*drive\\s*\\(\\s*0\\s*,\\s*-?\\d+\\s*\\)`).test(code);
      const hasOppMotors  = /\bleft\s*\.run\s*\(\s*-?\d+\s*\)\s*[\s\S]*\bright\s*\.run\s*\(\s*-\s*\d+\s*\)/.test(code)
                          || /\bright\s*\.run\s*\(\s*-?\d+\s*\)\s*[\s\S]*\bleft\s*\.run\s*\(\s*-\s*\d+\s*\)/.test(code);
      if(!(hasDriveOmega || hasOppMotors)) errors.push("‚úó Rotate using drive.drive(0, ¬±œâ) or opposite motor.run(...) inside the gyro loop");

      // stop after each rotation
      const stopRe = new RegExp(`\\b${driveVar}\\s*\\.\\s*stop\\s*\\(\\s*Stop\\.BRAKE\\s*\\)`);
      if(!stopRe.test(code)) errors.push("‚úó Missing drive.stop(Stop.BRAKE) after rotations");

      // back-offs (at least two)
      const backMatches = code.match(new RegExp(`\\b${driveVar}\\s*\\.\\s*straight\\s*\\(\\s*-(\\d+)\\s*\\)`, "g"));
      if(!(backMatches && backMatches.length>=2)) errors.push("‚úó Back off with drive.straight(-50) twice (30‚Äì200 mm accepted)");

      // Beep (finish)
      if(!/brick\s*\.\s*speaker\s*\.\s*beep\s*\(\s*\)/.test(code)) errors.push("‚úó Missing brick.speaker.beep() at the end");

      // Parameters for sim
      let backMm = 50;
      if(backMatches){
        const first = parseInt((/-(\d+)/.exec(backMatches[0])||[,"50"])[1],10);
        if(Number.isFinite(first)) backMm = Math.min(200, Math.max(30, first));
      }

      return { ok: errors.length===0, errors, backMm };
    }

    /* ---------- Canvas simulation (1 px = 1 cm) ---------- */
    const ctx = els.canvas.getContext("2d");
    const WORLD = {
      W: els.canvas.width,
      H: els.canvas.height,
      walls: {
        left:   { type:'v', x:40,  y1:40,  y2:200 },
        top:    { type:'h', y:40,  x1:40,  x2:600 },
        right:  { type:'v', x:600, y1:40,  y2:200 },
        bottom1:{ type:'h', y:200, x1:40,  x2:560 }, // bottom gap 560..600 is the door
      },
      robot: { x:120, y:120, heading:90, r:6 } // start inside, facing up (90¬∞)
    };
    let runToken = 0;

    const rad = d => d*Math.PI/180;

    function clear(){
      ctx.fillStyle="#fff"; ctx.fillRect(0,0,WORLD.W,WORLD.H);
      ctx.strokeStyle="#111"; ctx.lineWidth=2; ctx.strokeRect(0,0,WORLD.W,WORLD.H);
    }
    function drawWalls(){
      ctx.strokeStyle="#111"; ctx.lineWidth=4;
      const w = WORLD.walls;
      // top
      ctx.beginPath(); ctx.moveTo(w.top.x1||40, w.top.y); ctx.lineTo(w.top.x2||600, w.top.y); ctx.stroke();
      // left
      ctx.beginPath(); ctx.moveTo(w.left.x, w.left.y1); ctx.lineTo(w.left.x, w.left.y2); ctx.stroke();
      // right
      ctx.beginPath(); ctx.moveTo(w.right.x, w.right.y1); ctx.lineTo(w.right.x, w.right.y2); ctx.stroke();
      // bottom (left segment)
      ctx.beginPath(); ctx.moveTo(w.bottom1.x1, w.bottom1.y); ctx.lineTo(w.bottom1.x2, w.bottom1.y); ctx.stroke();
      // dashed door hint
      ctx.setLineDash([6,6]); ctx.strokeStyle="#9ca3af";
      ctx.beginPath(); ctx.moveTo(560, 200); ctx.lineTo(600, 200); ctx.stroke();
      ctx.setLineDash([]); ctx.strokeStyle="#111";
    }
    function drawRobot(){
      const r=WORLD.robot;
      // body
      ctx.fillStyle="#16a34a"; ctx.beginPath(); ctx.arc(r.x,r.y,r.r,0,2*Math.PI); ctx.fill();
      // "front" tick (shows heading)
      const hx=r.x+Math.cos(rad(r.heading))*(r.r+12), hy=r.y+Math.sin(rad(r.heading))*(r.r+12);
      ctx.strokeStyle="#16a34a"; ctx.lineWidth=2; ctx.beginPath(); ctx.moveTo(r.x,r.y); ctx.lineTo(hx,hy); ctx.stroke();
    }
    function render(){ clear(); drawWalls(); drawRobot(); }
    function resetWorld(){ runToken++; WORLD.robot={x:120,y:120,heading:90,r:6}; render(); }

    function contactTopWall(nextY){ const r=WORLD.robot; return (r.heading%360===90 && r.y>40 && nextY <= 40 + r.r); }
    function contactRightWall(nextX){ const r=WORLD.robot; return (r.heading%360===0 && r.x<600 && nextX >= 600 - r.r); }

    async function forwardUntilTop(){
      const my=++runToken; const r=WORLD.robot; const step=1;
      return new Promise(resolve=>{
        function tick(){
          if(my!==runToken) return resolve();
          const nx=r.x, ny=r.y - step;
          if(contactTopWall(ny)){ r.y = 40 + r.r; render(); return resolve(); }
          r.x=nx; r.y=ny; render();
          requestAnimationFrame(tick);
        }
        requestAnimationFrame(tick);
      });
    }
    async function forwardUntilRight(){
      const my=runToken; const r=WORLD.robot; const step=1;
      return new Promise(resolve=>{
        function tick(){
          if(my!==runToken) return resolve();
          const nx=r.x + step, ny=r.y;
          if(contactRightWall(nx)){ r.x = 600 - r.r; render(); return resolve(); }
          r.x=nx; r.y=ny; render();
          requestAnimationFrame(tick);
        }
        requestAnimationFrame(tick);
      });
    }
    async function straightPx(deltaPx){
      const my=runToken; const r=WORLD.robot; const step = deltaPx>=0 ? 1 : -1;
      let remaining = Math.abs(deltaPx);
      return new Promise(resolve=>{
        function tick(){
          if(my!==runToken) return resolve();
          const move = Math.min(1, remaining);
          r.x += Math.cos(rad(r.heading)) * step * move;
          r.y += Math.sin(rad(r.heading)) * step * move;
          render();
          remaining -= move;
          if(remaining>0) requestAnimationFrame(tick); else resolve();
        }
        requestAnimationFrame(tick);
      });
    }
    async function turnBy(deg){
      const my=runToken; const r=WORLD.robot;
      const total = Math.abs(deg); const sign = deg>=0 ? 1 : -1; const step=3*sign;
      let turned=0;
      return new Promise(resolve=>{
        function tick(){
          if(my!==runToken) return resolve();
          const d = Math.min(3, total-turned) * sign;
          r.heading = (r.heading + d + 360) % 360;
          turned += Math.abs(d);
          render();
          if(turned<total) requestAnimationFrame(tick); else resolve();
        }
        requestAnimationFrame(tick);
      });
    }
    async function forwardOutDoor(){
      const my=runToken; const r=WORLD.robot; const step=1;
      return new Promise(resolve=>{
        function tick(){
          if(my!==runToken) return resolve();
          const nx = r.x + Math.cos(rad(r.heading))*step;
          const ny = r.y + Math.sin(rad(r.heading))*step;

          // bottom wall except the door [560..600]
          if(r.heading%360===270){
            const doorL=560, doorR=600, bottom=200;
            const inDoor = (r.x >= doorL) && (r.x <= doorR);
            if(!inDoor && r.y < bottom && ny >= bottom - r.r){
              r.y = bottom - r.r; render();
              throw new Error("Hit the bottom wall outside the door. Adjust your turns/position.");
            }
            if(inDoor && r.y < bottom && ny >= bottom + r.r){
              r.y = bottom + r.r; render(); return resolve();
            }
          }
          r.x = nx; r.y = ny; render();
          if(r.y > 210) return resolve();
          requestAnimationFrame(tick);
        }
        requestAnimationFrame(tick);
      });
    }

    /* ---------- Run / Reset / Save ---------- */
    function reset(){ setStatus("",""); els.output.textContent=""; els.error.textContent=""; resetWorld(); }
    function save(){ const b=new Blob([els.editor.value],{type:"text/plain"}); const a=document.createElement("a"); a.href=URL.createObjectURL(b); a.download="main.py"; a.click(); URL.revokeObjectURL(a.href); }

    async function runCode(){
      els.output.textContent=""; els.error.textContent="";
      const raw = els.editor.value;
      const codeNoComments = stripComments(raw).trim();
      if(!codeNoComments){
        setStatus("error","ERROR");
        els.output.textContent="Please write your Pybricks program first.";
        return;
      }

      setStatus("running","checking‚Ä¶");
      const { ok, errors, backMm } = validate(raw);
      if(!ok){
        setStatus("error","ERROR");
        els.output.textContent = "Please fix first:\n" + errors.join("\n");
        return;
      }

      // Passed ‚Üí simulate scripted sequence (right turns of -90¬∞ each)
      setStatus("running","running‚Ä¶");
      resetWorld();
      try{
        await forwardUntilTop();
        await straightPx(-(backMm/10));
        await turnBy(-90);

        await forwardUntilRight();
        await straightPx(-(backMm/10));
        await turnBy(-90);

        await forwardOutDoor();

        setStatus("ok","done.");
        els.output.textContent = `Simulated: bumped top, back ${backMm} mm, gyro-turn ~90¬∞ right ‚Üí bumped right, back ${backMm} mm, gyro-turn ~90¬∞ right ‚Üí exited.`;
      }catch(e){
        setStatus("error","ERROR");
        els.error.textContent = String(e.message || e);
      }
    }

    els.run.onclick = runCode;
    els.reset.onclick = reset;
    els.save.onclick = save;

    render();
    document.getElementById("next-btn").onclick = (e)=>{ e.preventDefault(); alert("No next task configured yet."); };
  </script>
</body>
</html>
