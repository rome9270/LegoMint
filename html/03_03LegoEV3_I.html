<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>EV3 - drive a circle</title>

  <link rel="stylesheet" href="../css/03_python.css" />

  <style>
    #arena { background:#f9fafb; border:2px solid #111; width:100%; height:auto; max-width:900px; border-radius:10px; display:block; margin-top:10px; }
    .status.ok { color:#15803d; }
    .status.error { color:#b91c1c; }
    .status.running { color:#374151; }
    .muted { color:#6b7280; }
  </style>
</head>
<body>
  <!--  EINZIGER NAVIGATIONSBLOCK -->
  <nav class="link-grid" aria-label="Topic selection">
    <a class="btn" href="../app/01_main.php" id="go-main" aria-label="Back to main">‚¨ÖÔ∏è Going to main</a>
    <a class="btn" href="../app/logout.php">üö™ Logout</a>
    <a class="btn primary" id="next-btn" href="03_04LegoEV3_I.html">Next ‚Üí</a>
  </nav>

  <header class="row" style="justify-content: space-between;">
    <div>
      <h1>EV3 (Pybricks) ¬∑ Drive a Circle</h1>
      <p>
        Write a correct <b>Pybricks</b> program (EV3Brick, motors A/B, <b>DriveBase</b>).<br>
        Use a loop to approximate a <b>circle</b> (e.g., 36 steps √ó turn 10¬∞).<br>
        After the loop: <b>stop</b>, <b>beep</b>, and print something that includes the word <code>circle</code>.
      </p>
    </div>
    <div class="row">
      <button class="btn" id="tips-btn">üí° Tips</button>
      <button class="btn" id="solution-btn">‚úÖ Solution</button>
    </div>
  </header>

  <main class="layout">
    <!-- Editor -->
    <section class="card">
      <h2>Editor</h2>
      <div class="row">
        <button class="btn primary" id="run-btn">‚ñ∂ Run</button>
        <button class="btn" id="reset-btn">‚ü≤ Reset</button>
        <button class="btn" id="save-btn">üíæ Save</button>
        <span id="status" class="status" aria-live="polite"></span>
      </div>

<textarea id="editor" spellcheck="false">#!/usr/bin/env pybricks-micropython
# EV3 (Pybricks) ‚Äì Starter (fill in the logic yourself)
from pybricks.hubs import EV3Brick
from pybricks.ev3devices import Motor
from pybricks.parameters import Port, Stop
from pybricks.tools import wait
from pybricks.robotics import DriveBase

# TODO (example structure):
# brick = EV3Brick()
# left  = Motor(Port.A)
# right = Motor(Port.B)
# drive = DriveBase(left, right, 56, 114)
#
# STEP_MM = 35
# for _ in range(36):
#     drive.straight(STEP_MM)  # small forward step
#     drive.turn(10)           # small turn ‚Üí arc
#
# drive.stop(Stop.BRAKE)
# brick.speaker.beep()
# brick.screen.print("This is my circle")
# wait(500)
</textarea>
    </section>

    <!-- Simulation -->
    <section class="card">
      <h2>Simulation</h2>
      <canvas id="arena" width="600" height="300"></canvas>
      <p class="muted">Scale: <b>1 px = 1 cm</b> ¬∑ Start at (200, 180) facing right</p>
      <pre id="output"></pre>
      <div id="error" style="color:#b91c1c;"></div>
    </section>
  </main>

  <!-- Tips -->
  <dialog id="tips-modal">
    <div class="modal-header">Tips</div>
    <div class="modal-body">
      <ul id="tips-list"></ul>
    </div>
    <div class="modal-actions">
      <button class="btn" id="close-tips">Close</button>
    </div>
  </dialog>

  <!-- Solution -->
  <dialog id="solution-modal">
    <div class="modal-header">Solution (one example)</div>
    <div class="modal-body">
      <p class="muted" style="margin:0 0 8px 0;">There are many valid solutions. This is just one.</p>
<pre id="solution-code" style="white-space:pre-wrap;">#!/usr/bin/env pybricks-micropython
from pybricks.hubs import EV3Brick
from pybricks.ev3devices import Motor
from pybricks.parameters import Port, Stop
from pybricks.tools import wait
from pybricks.robotics import DriveBase

brick = EV3Brick()
left  = Motor(Port.A)
right = Motor(Port.B)

# Typical geometry (mm) ‚Äì adjust for your robot
WHEEL_DIAMETER = 56
AXLE_TRACK     = 114
drive = DriveBase(left, right, WHEEL_DIAMETER, AXLE_TRACK)

STEP_MM = 35
for _ in range(36):
    drive.straight(STEP_MM)
    drive.turn(10)

drive.stop(Stop.BRAKE)
brick.speaker.beep()
brick.screen.print("This is my circle")
wait(500)
</pre>
    </div>
    <div class="modal-actions">
      <button class="btn" id="copy-solution">Insert</button>
      <button class="btn" id="close-solution">Close</button>
    </div>
  </dialog>

  <script>
    /* ---------- Tips ---------- */
    const TASK = {
      taskId: 3, 
      tips: [
        "DriveBase: drive.straight(mm) moves in millimeters; drive.turn(deg) rotates in degrees.",
        "Circle approximation: many small forward steps + small turns (e.g., 36 √ó 10¬∞ = 360¬∞).",
        "Use a constant for step length (e.g., STEP_MM = 35).",
        "After the loop: drive.stop(Stop.BRAKE), brick.speaker.beep(), brick.screen.print(\"...circle...\").",
        "Adjust wheel diameter and axle track to your robot (56/114 mm are typical)."
      ]
    };

    /* ---------- DOM ---------- */
    const els = {
      editor: document.getElementById("editor"),
      run: document.getElementById("run-btn"),
      reset: document.getElementById("reset-btn"),
      save: document.getElementById("save-btn"),
      output: document.getElementById("output"),
      error: document.getElementById("error"),
      status: document.getElementById("status"),
      canvas: document.getElementById("arena"),
      tipsBtn: document.getElementById("tips-btn"),
      tipsModal: document.getElementById("tips-modal"),
      tipsList: document.getElementById("tips-list"),
      closeTips: document.getElementById("close-tips"),
      solutionBtn: document.getElementById("solution-btn"),
      solutionModal: document.getElementById("solution-modal"),
      copySolution: document.getElementById("copy-solution"),
      closeSolution: document.getElementById("close-solution")
    };

    /* ---------- UI ---------- */
    els.tipsList.innerHTML = TASK.tips.map(t=>"<li>"+t+"</li>").join("");
    function setStatus(cls, txt){ els.status.className="status "+cls; els.status.textContent=txt; }
    function openDialog(d){ if(d?.showModal) d.showModal(); else d?.setAttribute("open",""); }
    function closeDialog(d){ if(d?.close) d.close(); else d?.removeAttribute("open"); }
    els.tipsBtn.onclick = () => openDialog(els.tipsModal);
    els.closeTips.onclick = () => closeDialog(els.tipsModal);
    els.solutionBtn.onclick = () => openDialog(els.solutionModal);
    els.closeSolution.onclick = () => closeDialog(els.solutionModal);
    els.copySolution.onclick = () => {
      els.editor.value = document.getElementById("solution-code").textContent;
      closeDialog(els.solutionModal);
      setStatus("", ""); els.output.textContent=""; els.error.textContent="";
    };

    /* ---------- STRICT VALIDATION (circle task) ---------- */
    function validateCircleTask(src){
      const errors = [];
      const code = src.replace(/\r/g,'');
      const lines = code.split('\n');

      // required imports
      [
        [/from\s+pybricks\.hubs\s+import\s+EV3Brick/, "Missing import EV3Brick"],
        [/from\s+pybricks\.ev3devices\s+import\s+.*\bMotor\b/, "Missing import Motor"],
        [/from\s+pybricks\.parameters\s+import\s+.*\bPort\b/, "Missing import Port"],
        [/from\s+pybricks\.parameters\s+import\s+.*\bStop\b/, "Missing import Stop"],
        [/from\s+pybricks\.tools\s+import\s+.*\bwait\b/, "Missing import wait"],
        [/from\s+pybricks\.robotics\s+import\s+.*\bDriveBase\b/, "Missing import DriveBase"]
      ].forEach(([re,msg])=>{ if(!re.test(code)) errors.push("‚úó "+msg); });

      // initializations (variable names are free)
      const brickM = code.match(/(\w+)\s*=\s*EV3Brick\s*\(\s*\)/);
      const leftM  = code.match(/(\w+)\s*=\s*Motor\s*\(\s*Port\.A\s*\)/);
      const rightM = code.match(/(\w+)\s*=\s*Motor\s*\(\s*Port\.B\s*\)/);
      const driveM = code.match(/(\w+)\s*=\s*DriveBase\s*\(/);
      if(!brickM) errors.push("‚úó EV3Brick not initialized");
      if(!leftM)  errors.push("‚úó Left motor (Port.A) missing");
      if(!rightM) errors.push("‚úó Right motor (Port.B) missing");
      if(!driveM) errors.push("‚úó DriveBase not created");
      const driveVar = driveM?.[1] || "drive";

      // map simple assignments NAME = NUMBER (constants)
      const assigns = {};
      for(const L of lines){
        const m = L.match(/^\s*([A-Za-z_]\w*)\s*=\s*(\d+)\s*$/);
        if(m) assigns[m[1]] = parseInt(m[2],10);
      }

      // find for-loop "for _ in range(36):" (capture indent)
      let forIndex = -1, forIndent = "";
      for(let i=0;i<lines.length;i++){
        const m = lines[i].match(/^(\s*)for\s+\w+\s+in\s+range\s*\(\s*36\s*\)\s*:\s*$/);
        if(m){ forIndex=i; forIndent=m[1]||""; break; }
      }
      if(forIndex < 0) errors.push("‚úó Missing loop: for _ in range(36):");

      // inside the loop: need drive.straight(mm) and drive.turn(¬±10)
      let stepMm = null;
      let hasStraight = false;
      let hasTurn10   = false;

      if(forIndex >= 0){
        for(let j=forIndex+1; j<lines.length; j++){
          const L = lines[j];
          if(L.trim()==="") continue;
          const indent = (L.match(/^(\s*)/)||["",""])[1];
          if(indent.length <= forIndent.length) break; // end of block

          // straight: number or named constant
          const straightRe = new RegExp(`\\b${driveVar}\\s*\\.\\s*straight\\s*\\(\\s*([A-Za-z_]\\w*|\\d+)\\s*\\)`);
          const sm = L.match(straightRe);
          if(sm){
            hasStraight = true;
            const arg = sm[1];
            if(/^\d+$/.test(arg)){
              stepMm = parseInt(arg,10);
            } else if(assigns[arg] !== undefined){
              stepMm = assigns[arg];
            }
          }

          // turn: must be ¬±10 (number or constant that resolves to ¬±10)
          const turnRe = new RegExp(`\\b${driveVar}\\s*\\.\\s*turn\\s*\\(\\s*([A-Za-z_]\\w*|-?\\d+)\\s*\\)`);
          const tm = L.match(turnRe);
          if(tm){
            let ang = null;
            const arg = tm[1];
            if(/^-?\d+$/.test(arg)) ang = parseInt(arg,10);
            else if(assigns[arg] !== undefined) ang = assigns[arg];
            if(ang === 10 || ang === -10) hasTurn10 = true;
          }
        }
      }

      if(!hasStraight) errors.push("‚úó Missing drive.straight(mm) inside the loop");
      if(!hasTurn10)   errors.push("‚úó Missing drive.turn(¬±10) inside the loop");

      // step length sanity
      if(!(Number.isFinite(stepMm) && stepMm >= 10 && stepMm <= 150)){
        errors.push("‚úó Step length should be 10‚Äì150 mm (via drive.straight(mm) or a constant)");
      }

      // after the loop: require stop + beep + screen print("...circle...")
      let afterIdx = forIndex >= 0 ? forIndex+1 : 0;
      if(forIndex >= 0){
        for(let j=forIndex+1; j<lines.length; j++){
          const L = lines[j];
          const indent = (L.match(/^(\s*)/)||["",""])[1];
          if(L.trim()!=="" && indent.length <= forIndent.length){ afterIdx = j; break; }
          if(j === lines.length-1) afterIdx = j+1;
        }
      }
      const afterCode = lines.slice(afterIdx).join("\n");
      if(!new RegExp(`\\b${driveVar}\\s*\\.\\s*stop\\s*\\(\\s*Stop\\.BRAKE\\s*\\)`).test(afterCode)){
        errors.push("‚úó Missing drive.stop(Stop.BRAKE) after the loop");
      }
      if(!/brick\s*\.speaker\s*\.beep\s*\(/.test(afterCode)) {
        errors.push("‚úó Missing brick.speaker.beep() after the loop");
      }
      if(!/brick\s*\.screen\s*\.print\s*\(\s*["'][^"']*circle[^"']*["']\s*\)/i.test(afterCode)) {
        errors.push('‚úó Missing brick.screen.print("This is my circle") after the loop');
      }

      return { errors, stepMm: stepMm || 35, angle: 10 };
    }

    /* ---------- Arena / animation (1 px = 1 cm) ---------- */
    const ctx = els.canvas.getContext("2d");
    const WORLD = {
      W: els.canvas.width, H: els.canvas.height,
      robot: { x:200, y:180, heading:0, r:6 } // start at (200,180) facing right
    };
    let runToken=0;

    const rad=d=>d*Math.PI/180;
    function clear(){ ctx.fillStyle="#fff"; ctx.fillRect(0,0,WORLD.W,WORLD.H); ctx.strokeStyle="#111"; ctx.lineWidth=2; ctx.strokeRect(0,0,WORLD.W,WORLD.H); }
    function drawRobot(){
      const r=WORLD.robot;
      ctx.fillStyle="#16a34a";
      ctx.beginPath(); ctx.arc(r.x,r.y,r.r,0,2*Math.PI); ctx.fill();
      const hx=r.x+Math.cos(rad(r.heading))*(r.r+10);
      const hy=r.y+Math.sin(rad(r.heading))*(r.r+10);
      ctx.strokeStyle="#16a34a"; ctx.lineWidth=2;
      ctx.beginPath(); ctx.moveTo(r.x,r.y); ctx.lineTo(hx,hy); ctx.stroke();
    }
    function render(){ clear(); drawRobot(); }
    function resetWorld(){
      runToken++;
      WORLD.robot = { x:200, y:180, heading:0, r:6 };
      render();
    }

    // move straight with animation: mm ‚Üí px (1 cm/px ‚Üí mm/10)
    async function moveStraightMm(mm){
      const my=runToken; const r=WORLD.robot;
      const distPx = Math.max(0, mm)/10;  // mm ‚Üí cm(px)
      const step = 1; // 1 cm per frame
      const ux = Math.cos(rad(r.heading)), uy = Math.sin(rad(r.heading));
      let remaining = distPx;
      return new Promise(resolve=>{
        function tick(){
          if(my!==runToken) return resolve();
          const moved = Math.min(step, remaining);
          r.x += ux*moved; r.y += uy*moved;
          render();
          remaining -= moved;
          if(remaining>0) requestAnimationFrame(tick); else resolve();
        }
        requestAnimationFrame(tick);
      });
    }
    async function turnDeg(deg){
      const my=runToken; const r=WORLD.robot;
      const total = deg; const step = deg>0? 5 : -5;
      let done = 0;
      return new Promise(resolve=>{
        function tick(){
          if(my!==runToken) return resolve();
          const next = Math.abs(total-done) < Math.abs(step) ? (total-done) : step;
          r.heading = (r.heading + next + 360) % 360;
          done += next;
          render();
          if(done===total) resolve(); else requestAnimationFrame(tick);
        }
        requestAnimationFrame(tick);
      });
    }

    /* ---------- Run / Reset / Save ---------- */
    function setStatus(cls, txt){ els.status.className="status "+cls; els.status.textContent=txt; }
    function reset(){ setStatus("", ""); els.output.textContent=""; els.error.textContent=""; resetWorld(); }
    function save(){ const b=new Blob([els.editor.value],{type:"text/plain"}); const a=document.createElement("a"); a.href=URL.createObjectURL(b); a.download="main.py"; a.click(); URL.revokeObjectURL(a.href); }

    async function runCode(){
      els.error.textContent=""; els.output.textContent="";
      setStatus("running","checking‚Ä¶");

      const code=els.editor.value.trim();
      if(!code){
        setStatus("error","ERROR");
        els.output.textContent="Please write your Pybricks program first.";
        return;
      }

      const { errors, stepMm, angle } = validateCircleTask(code);
      if(errors.length){
        setStatus("error","ERROR");
        els.output.textContent = "Please fix first:\n" + errors.join("\n");
        return;
      }

      setStatus("running","running‚Ä¶");
      resetWorld();
      try{
        for(let i=0;i<36;i++){
          await moveStraightMm(stepMm);
          await turnDeg(angle);
        }
        setStatus("ok","done.");
        els.output.textContent = `Circle completed (~36 steps √ó ${stepMm} mm, turn ${angle}¬∞).`;
      }catch(e){
        setStatus("error","ERROR");
        els.error.textContent = String(e);
      }
    }

    els.run.onclick = runCode;
    els.reset.onclick = reset;
    els.save.onclick = save;

    render();

    document.getElementById("back-btn").onclick = () => history.back();
  </script>
</body>
</html>
