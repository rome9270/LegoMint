<!doctype html>
<html lang="de">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>EV3 · Schritt 3 – Ultraschall: Anhalten vor Hindernis</title>

<style>
/* ===== Deine CSS (unverändert, mit Bugfix) ===== */
/* Basislayout */
body { font-family: Arial, sans-serif; text-align: center; padding: 60px; }
h1 { margin-bottom: 30px; }
p  { margin-bottom: 30px; }
hr  { margin: 40px 0; }

/* Startseiten-Grid (Themen-Auswahl) */
.link-grid{
  display: grid !important;
  grid-template-columns: repeat(auto-fit, minmax(260px, 1fr));
  gap: 24px;
  padding: 20px 24px;        /* ✅ Bugfix */
  background: #fff;
  margin-top: 40px;
}
.link-grid > a.topic,
.link-grid > button.topic{
  display: block; width: 100%; margin: 0; text-align: center;
  padding: 18px 24px; border-radius: 24px; background: #3fb257; color: #fff; font-weight: 700;
}
.link-grid.debug > *{ outline: 2px dashed #f0f; }

.level-grid { display:flex; flex-wrap:wrap; justify-content:center; column-gap:16px; row-gap:16px; margin-top:20px; }
.level-btn{
  display: inline-block; width: 260px; padding: 18px 28px; font-size: 20px; font-weight: bold;
  color: #fff; background: #4CAF50; border-radius: 12px; text-decoration: none; text-align: center;
  transition: background-color .3s, transform .2s; cursor: pointer; border: none;
}
.level-btn:hover{ background:#45a049; transform: translateY(-3px); }

/* Mobile Feinschliff */
@media (max-width: 640px){
  body{ padding: 32px 16px; }
  .level-btn{ width: 100%; max-width: 360px; }
}

/* ===== Zusatzstyles für Karte/Editor/Ausgabe/Simulator ===== */
main { max-width: 1100px; margin: 0 auto; }
.card { background:#fff; border: 1px solid #e7e7e7; border-radius:16px; padding:18px; text-align:left; box-shadow: 0 6px 24px rgba(0,0,0,.06); }
.card h2 { margin: 0 0 10px; }
.small, .status { color:#666; font-size:14px; }
.row{ display:flex; gap:12px; align-items:center; flex-wrap:wrap; }

textarea{
  width:100%; min-height: 280px; border:1px solid #ddd; border-radius:12px; padding:14px;
  font:14px/1.45 Consolas, ui-monospace, Menlo, Monaco, "Liberation Mono", monospace;
}
pre{
  margin:0; padding:12px; min-height:140px; background:#f7f7f7; border:1px solid #e7e7e7; border-radius:12px;
  white-space: pre-wrap; word-break: break-word;
}
.result{ font-weight:700; }
.ok{ color:#2e7d32; }
.fail{ color:#c62828; }

/* Simulator */
.sim-wrap { margin-top: 14px; }
#sim {
  width: 100%;
  height: 360px;
  display: block;
  background: #fff;
  border: 1px solid #e7e7e7;
  border-radius: 12px;
}
.sim-legend { margin-top: 6px; font-size: 13px; color:#666; }
</style>
</head>

<body>
  <main>
    <h1>EV3 · Schritt 3: Ultraschall – anhalten vor Hindernis</h1>
    <p>Aufgabe: Fahre vorwärts, **stoppe &lt; THRESHOLD mm** vor einem Hindernis, fahre **ein Stück zurück** und **biege ab**.<br>
       <small>Nutze <code>UltrasonicSensor</code>, <code>robot.drive(...)</code> + <code>while ultra.distance() &gt; THRESHOLD</code>, dann <code>robot.stop()</code>, <code>robot.straight(-...)</code>, <code>robot.turn(...)</code>.</small></p>

    <section class="card">
      <h2 style="margin:0 0 8px">Dein Code</h2>
      <p class="status">Tipp: Sensor z. B. an Port S4: <code>ultra = UltrasonicSensor(Port.S4)</code> · Schwelle typisch 150–200&nbsp;mm</p>

      <textarea id="code" spellcheck="false">#!/usr/bin/env pybricks-micropython
from pybricks.hubs import EV3Brick
from pybricks.ev3devices import Motor, UltrasonicSensor
from pybricks.parameters import Port
from pybricks.robotics import DriveBase
from pybricks.tools import wait

# Antrieb
left = Motor(Port.B); right = Motor(Port.C)
robot = DriveBase(left, right, wheel_diameter=56, axle_track=114)

# Ultraschall
ultra = UltrasonicSensor(Port.S4)
THRESHOLD = 150  # mm

# Vorwärts rollen, bis Abstand < THRESHOLD
robot.drive(150, 0)
while ultra.distance() > THRESHOLD:
    wait(10)
robot.stop()

# Zurücksetzen und abbiegen
robot.straight(-120)
robot.turn(90)
</textarea>

      <div class="row" style="margin-top:10px">
        <button id="run" class="level-btn">Simulation ausführen</button>
        <button id="check" class="level-btn" style="background:#3fb257">Aufgabe prüfen</button>
        <button id="download" class="level-btn" style="background:#3fb257">Als main.py herunterladen</button>
        <button id="next" class="level-btn" disabled>Nächster Schritt ▷</button>
        <span id="status" class="status">Bereit (Schnellmodus)</span>
      </div>

      <div class="sim-wrap">
        <canvas id="sim"></canvas>
        <div class="sim-legend">Simulator: Maßstab <b>1&nbsp;px = 1&nbsp;mm</b> · Start in der Mitte · Hindernis rot (400&nbsp;mm vor Start)</div>
      </div>

      <h3>Ausgabe</h3>
      <pre id="out" aria-live="polite"></pre>
      <p class="result" id="result"></p>
    </section>
  </main>

<script>
/* ===== Web Audio (für BEEPs, falls im Code genutzt) ===== */
let audioCtx;
async function ensureAudio(){
  if(!audioCtx){ audioCtx = new (window.AudioContext || window.webkitAudioContext)(); }
  if(audioCtx.state === 'suspended'){ try { await audioCtx.resume(); } catch(_){} }
  return audioCtx;
}
function playBeep(duration=120, freq=880, volume=0.15){
  const ctx = audioCtx;
  const osc = ctx.createOscillator();
  const gain = ctx.createGain();
  osc.type = 'square';
  osc.frequency.value = freq;
  gain.gain.value = volume;
  osc.connect(gain); gain.connect(ctx.destination);
  const t = ctx.currentTime;
  osc.start(t); osc.stop(t + duration/1000);
}

/* ===== DOM ===== */
const codeEl = document.getElementById('code');
const outEl  = document.getElementById('out');
const resEl  = document.getElementById('result');
const nextBtn= document.getElementById('next');
const statusEl = document.getElementById('status');
function clearOut(){ outEl.textContent=''; resEl.textContent=''; resEl.className='result'; }

/* ===== Simulator (Canvas) ===== */
const canvas = document.getElementById('sim');
const ctx = canvas.getContext('2d', { alpha: false });

function setupCanvas(){
  const dpr = window.devicePixelRatio || 1;
  const cssHeight = parseFloat(getComputedStyle(canvas).height);
  const cssWidth  = canvas.clientWidth;
  canvas.width  = Math.round(cssWidth * dpr);
  canvas.height = Math.round(cssHeight * dpr);
  ctx.setTransform(dpr,0,0,dpr,0,0);
}
window.addEventListener('resize', ()=>{ setupCanvas(); drawAll(); });

const STATE = {
  scale: 1,                 // 1 px = 1 mm
  x: 0, y: 0, theta: 0,     // Pose
  path: [],
  obstacle: { x: 0, y: 0, r: 30 } // Hindernis als Kreis (r ≈ 30 mm)
};

function resetSim(){
  setupCanvas();
  STATE.x = canvas.clientWidth / 2;
  STATE.y = canvas.clientHeight / 2;
  STATE.theta = 0; // nach rechts
  STATE.path = [];
  // Hindernis 400 mm vor Start auf derselben Linie
  STATE.obstacle.x = STATE.x + 400;
  STATE.obstacle.y = STATE.y;
  drawAll();
}

function drawGrid(){
  const w = canvas.clientWidth, h = canvas.clientHeight;
  ctx.save();
  ctx.clearRect(0,0,w,h);
  ctx.fillStyle = '#ffffff';
  ctx.fillRect(0,0,w,h);
  ctx.strokeStyle = '#eee'; ctx.lineWidth = 1;
  for(let x=0; x<=w; x+=50){ ctx.beginPath(); ctx.moveTo(x,0); ctx.lineTo(x,h); ctx.stroke(); }
  for(let y=0; y<=h; y+=50){ ctx.beginPath(); ctx.moveTo(0,y); ctx.lineTo(w,y); ctx.stroke(); }
  ctx.strokeStyle = '#ddd';
  ctx.beginPath(); ctx.moveTo(0,h/2); ctx.lineTo(w,h/2); ctx.stroke();
  ctx.beginPath(); ctx.moveTo(w/2,0); ctx.lineTo(w/2,h); ctx.stroke();
  ctx.restore();
}

function drawPath(){
  ctx.save();
  ctx.strokeStyle = '#3fb257';
  ctx.lineWidth = 2;
  for(const seg of STATE.path){
    const [x1,y1,x2,y2] = seg;
    ctx.beginPath(); ctx.moveTo(x1,y1); ctx.lineTo(x2,y2); ctx.stroke();
  }
  ctx.restore();
}

function drawRobot(){
  const r = 8, L = 18, a = STATE.theta, x=STATE.x, y=STATE.y;
  ctx.save();
  // Punkt
  ctx.fillStyle = '#4CAF50';
  ctx.beginPath(); ctx.arc(x, y, r, 0, Math.PI*2); ctx.fill();
  // Pfeil
  const tipX = x + Math.cos(a) * (r + L);
  const tipY = y - Math.sin(a) * (r + L);
  const leftX = x + Math.cos(a + Math.PI*0.75) * r;
  const leftY = y - Math.sin(a + Math.PI*0.75) * r;
  const rightX= x + Math.cos(a - Math.PI*0.75) * r;
  const rightY= y - Math.sin(a - Math.PI*0.75) * r;
  ctx.beginPath(); ctx.moveTo(tipX, tipY); ctx.lineTo(leftX, leftY); ctx.lineTo(rightX, rightY); ctx.closePath(); ctx.fill();
  ctx.restore();
}

function drawObstacle(){
  const o = STATE.obstacle;
  ctx.save();
  ctx.fillStyle = '#e53935';
  ctx.beginPath(); ctx.arc(o.x, o.y, o.r, 0, Math.PI*2); ctx.fill();
  ctx.restore();
}

function drawAll(){
  drawGrid();
  drawPath();
  drawObstacle();
  drawRobot();
}

function forwardMM(mm){
  const dx = Math.cos(STATE.theta) * mm * STATE.scale;
  const dy = -Math.sin(STATE.theta) * mm * STATE.scale;
  const x1 = STATE.x, y1 = STATE.y;
  STATE.x += dx; STATE.y += dy;
  STATE.path.push([x1,y1, STATE.x, STATE.y]);
  drawAll();
}
function turnDeg(deg){
  STATE.theta += (deg * Math.PI / 180);
  drawAll();
}

/* ===== Parser + Ablaufsteuerung für Aufgabe 3 ===== */
function extractConfig(src){
  // Sensor-Variable finden: <name> = UltrasonicSensor(...)
  let sensorName = 'ultra';
  const s = src.match(/([A-Za-z_]\w*)\s*=\s*UltrasonicSensor\s*\(/);
  if(s) sensorName = s[1];

  // Threshold (aus while ... distance() > NUMBER) oder THRESHOLD = NUMBER
  let threshold = 150;
  const t1 = src.match(new RegExp(sensorName.replace(/[.*+?^${}()|[\]\\]/g,'\\$&') + String.raw`\s*\.\s*distance\(\)\s*>\s*(\d+)`));
  const t2 = src.match(/THRESHOLD\s*=\s*(\d+)/);
  if(t1) threshold = parseInt(t1[1],10); else if(t2) threshold = parseInt(t2[1],10);

  // Rücksetzlänge & Drehwinkel (erste Vorkommen)
  let back = 120;
  const b = src.match(/robot\.straight\(\s*(-\d+)\s*\)/);
  if(b) back = Math.abs(parseInt(b[1],10));

  let turn = 90;
  const a = src.match(/robot\.turn\(\s*(-?\d+)\s*\)/);
  if(a) turn = parseInt(a[1],10);

  // Vorwärts-Drive-Geschwindigkeit (optional)
  let speed = 150;
  const d = src.match(/robot\.drive\(\s*(\d+)\s*,\s*0\s*\)/);
  if(d) speed = parseInt(d[1],10);

  return { sensorName, threshold, back, turn, speed };
}

function runSimulatorFromCode(src){
  resetSim();
  outEl.textContent = '';

  // Konfiguration aus Code holen
  const { sensorName, threshold, back, turn, speed } = extractConfig(src);

  // 1) Vorrollen bis threshold vor Hindernis (vereinfachte 1D-Geometrie entlang X)
  const o = STATE.obstacle;
  const stopX = o.x - threshold; // Abstand in mm (px)
  const dist = stopX - STATE.x;
  const travel = Math.max(0, Math.round(dist));

  // 2) Animations-Timeline
  let t = 0;
  // evtl. Beep(s)
  const beeps = (src.match(/speaker\.beep\(\)/g) || []).length;
  for(let i=0;i<beeps;i++){
    setTimeout(()=>{ playBeep(); outEl.textContent += '[BEEP]\n'; }, t);
    t += 180;
  }

  // Drive vorwärts (nur Log; Animation durch forwardMM)
  setTimeout(()=>{ outEl.textContent += `[DRIVE ${speed}mm/s, 0°/s]\n`; }, t);
  // Fahrt bis Stoppunkt
  const seg = Math.max(200, Math.min(1200, travel*2)); // reine Animationszeit
  setTimeout(()=>{ forwardMM(travel); outEl.textContent += `[APPROACH ${travel}mm → Abstand ≈ ${threshold}mm]\n`; }, t);
  t += seg;

  // Stop
  setTimeout(()=>{ outEl.textContent += '[STOP]\n'; }, t);
  t += 100;

  // Back & Turn
  setTimeout(()=>{ forwardMM(-back); outEl.textContent += `[STRAIGHT -${back}mm]\n`; }, t);
  t += Math.max(200, Math.min(1000, back*2));
  setTimeout(()=>{ turnDeg(turn); outEl.textContent += `[TURN ${turn}°]\n`; }, t);
}

/* ===== Checker ===== */
function checkTask(){
  const code = codeEl.value;
  // 1) Ultraschall vorhanden?
  const hasUltra = /UltrasonicSensor\s*\(/.test(code);
  // 2) while ultra.distance() > NUMBER ?
  //    Variablennamen robust herausziehen
  const varMatch = code.match(/([A-Za-z_]\w*)\s*=\s*UltrasonicSensor\s*\(/);
  let condOK = false, threshold = null;
  if(varMatch){
    const v = varMatch[1].replace(/[.*+?^${}()|[\]\\]/g,'\\$&');
    const m = code.match(new RegExp(v + String.raw`\s*\.\s*distance\(\)\s*>\s*(\d+)`));
    if(m){ condOK = true; threshold = parseInt(m[1],10); }
  } else {
    // fallback auf generische Schreibweise
    condOK = /distance\(\)\s*>\s*\d+/.test(code);
  }
  // 3) stop + back + turn?
  const hasStop = /robot\.stop\s*\(\s*\)/.test(code);
  const hasBack = /robot\.straight\(\s*-\d+\s*\)/.test(code);
  const hasTurn = /robot\.turn\(\s*-?\d+\s*\)/.test(code);

  const ok = hasUltra && condOK && hasStop && hasBack && hasTurn;

  if(ok){
    resEl.textContent = '✔︎ Aufgabe erfüllt – Sensor, Stop, Rückwärts & Turn erkannt' + (threshold? ` (Schwelle ${threshold} mm)` : '');
    resEl.className = 'result ok';
    nextBtn.disabled = false;
  }else{
    const miss = [];
    if(!hasUltra) miss.push('UltrasonicSensor fehlt');
    if(!condOK)  miss.push('while … distance() > THRESHOLD fehlt');
    if(!hasStop) miss.push('robot.stop() fehlt');
    if(!hasBack) miss.push('Rückwärts (robot.straight(-…)) fehlt');
    if(!hasTurn) miss.push('robot.turn(…) fehlt');
    resEl.textContent = 'Noch nicht ganz: ' + miss.join(', ') + '.';
    resEl.className = 'result fail';
    nextBtn.disabled = true;
  }
}

/* ===== Download als main.py ===== */
function downloadMain(){
  const blob = new Blob([codeEl.value], {type:'text/x-python'});
  const url  = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url; a.download = 'main.py'; a.click();
  URL.revokeObjectURL(url);
}

/* ===== UI Events ===== */
document.getElementById('run').addEventListener('click', async ()=>{
  await ensureAudio();
  clearOut();
  runSimulatorFromCode(codeEl.value);
});
document.getElementById('check').addEventListener('click', checkTask);
document.getElementById('download').addEventListener('click', downloadMain);
nextBtn.addEventListener('click', ()=> alert('Weiter: Schritt 4 – Linienfolge (einfacher Schwellenwert), wenn du willst!'));

/* Init */
resetSim();
</script>
</body>
</html>
