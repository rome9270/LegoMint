<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>EV3 (Pybricks) ‚Äì Drive a Square (Gyro)</title>

  <link rel="stylesheet" href="../css/03_python.css" />
  <style>
    #arena {
      background:#f9fafb;
      border:2px solid #111;
      width:100%;
      height:auto;
      max-width:900px;
      border-radius:10px;
      display:block;
      margin-top:10px;
    }

    .status.ok { color:#15803d; }
    .status.error { color:#b91c1c; }
    .status.running { color:#374151; }
    .muted { color:#6b7280; }
    #error { color:#b91c1c; white-space:pre-wrap; }
  </style>
</head>
<body>
  <!-- NAV -->
  <!--  EINZIGER NAVIGATIONSBLOCK -->
  <nav class="link-grid" aria-label="Topic selection">
    <a class="btn" href="../app/01_main.php" id="go-main" aria-label="Back to main">‚¨ÖÔ∏è Going to main</a>
    <a class="btn" href="../app/logout.php">üö™ Logout</a>
    <a class="btn" href="../html/03_09LegoEV3.html">Next ‚Üí</a>
  </nav>


  <header class="row" style="justify-content: space-between;">
    <div>
      <h1>EV3 (Pybricks) ¬∑ Drive a Square ‚Äì with Gyro</h1>
      <p>
        Write a <b>Pybricks</b> program using:
        <ul>
          <li><code>EV3Brick()</code></li>
          <li>2 motors on <b>Port A</b> and <b>Port B</b></li>
          <li><b>GyroSensor on Port S4</b></li>
          <li><b>DriveBase</b></li>
        </ul>

        Your robot should:
        <ol>
          <li>Drive forward ~400 mm while keeping a straight heading using the gyro (correction with <code>gyro.angle()</code>).</li>
          <li>Turn RIGHT by 90¬∞ using the gyro (no <code>drive.turn(...)</code>).</li>
          <li>Repeat 4 times ‚Üí full square.</li>
        </ol>

        After the loop, do:
        <code>brick.speaker.beep()</code> and
        <code>brick.screen.print("This is my square")</code>.
      </p>

      <p class="muted" style="margin-top:8px;">
        Straight driving idea:<br>
        <code>gyro.reset_angle(0)</code><br>
        <code>drive.reset()</code><br>
        <code>while drive.distance() &lt; 400:</code><br>
        <code>&nbsp;&nbsp;error = gyro.angle()</code><br>
        <code>&nbsp;&nbsp;correction = -error * 2</code><br>
        <code>&nbsp;&nbsp;drive.drive(100, correction)</code><br><br>

        Turn idea:<br>
        <code>gyro.reset_angle(0)</code><br>
        <code>drive.drive(0, -90)</code>  <!-- spin in place to the right --><br>
        <code>while abs(gyro.angle()) &lt; 90:</code><br>
        <code>&nbsp;&nbsp;wait(10)</code><br>
        <code>drive.stop(Stop.BRAKE)</code>
      </p>
    </div>

    <div class="row">
      <button class="btn" id="tips-btn">üí° Tips</button>
      <button class="btn" id="solution-btn">‚úÖ Solution</button>
    </div>
  </header>

  <main class="layout">
    <!-- EDITOR CARD -->
    <section class="card">
      <h2>Editor</h2>
      <div class="row">
        <button class="btn primary" id="run-btn">‚ñ∂ Run</button>
        <button class="btn" id="reset-btn">‚ü≤ Reset</button>
        <button class="btn" id="save-btn">üíæ Save</button>
        <span id="status" class="status" aria-live="polite"></span>
      </div>

<textarea id="editor" spellcheck="false">#!/usr/bin/env pybricks-micropython
# EV3 (Pybricks) ‚Äì Gyro Square
# - Drive 4 sides of a square
# - Keep straight using gyro feedback
# - Turn 90¬∞ right using the gyro
# - End: beep + "square"

from pybricks.hubs import EV3Brick
from pybricks.ev3devices import Motor, GyroSensor
from pybricks.parameters import Port, Stop
from pybricks.tools import wait
from pybricks.robotics import DriveBase

brick = EV3Brick()
left  = Motor(Port.A)
right = Motor(Port.B)
gyro  = GyroSensor(Port.S4)

drive = DriveBase(left, right, 56, 114)

def drive_straight_mm(mm):
    gyro.reset_angle(0)
    drive.reset()
    while drive.distance() < mm:
        error = gyro.angle()
        correction = -error * 2
        drive.drive(100, correction)
        wait(10)
    drive.stop(Stop.BRAKE)

def turn_right_90():
    gyro.reset_angle(0)
    drive.drive(0, -90)
    while abs(gyro.angle()) < 90:
        wait(10)
    drive.stop(Stop.BRAKE)

for i in range(4):
    drive_straight_mm(400)
    turn_right_90()

brick.speaker.beep()
brick.screen.print("This is my square")
wait(500)
</textarea>
    </section>

    <!-- SIMULATION CARD -->
    <section class="card">
      <h2>Simulation</h2>
      <canvas id="arena" width="600" height="300"></canvas>
      <p class="muted">
        Scale: <b>1 px = 1 cm</b> ¬∑ Start at (80,200) facing right.
      </p>
      <pre id="output"></pre>
      <div id="error"></div>
    </section>
  </main>

  <!-- Tips Modal -->
  <dialog id="tips-modal">
    <div class="modal-header">Tips</div>
    <div class="modal-body">
      <ul id="tips-list">
        <li>Use GyroSensor(Port.S4) to measure heading (angle in degrees).</li>
        <li>Keep straight with correction = -gyro.angle()*2 in drive.drive(100, correction).</li>
        <li>To turn right 90¬∞: spin and wait until abs(gyro.angle()) reaches 90.</li>
        <li>Repeat 4 times in a for-loop.</li>
        <li>End with beep + print("This is my square").</li>
      </ul>
    </div>
    <div class="modal-actions">
      <button class="btn" id="close-tips">Close</button>
    </div>
  </dialog>

  <!-- Solution Modal -->
  <dialog id="solution-modal">
    <div class="modal-header">Solution (one example)</div>
    <div class="modal-body">
<pre id="solution-code" style="white-space:pre-wrap;">#!/usr/bin/env pybricks-micropython
from pybricks.hubs import EV3Brick
from pybricks.ev3devices import Motor, GyroSensor
from pybricks.parameters import Port, Stop
from pybricks.tools import wait
from pybricks.robotics import DriveBase

brick = EV3Brick()
left  = Motor(Port.A)
right = Motor(Port.B)
gyro  = GyroSensor(Port.S4)

drive = DriveBase(left, right, 56, 114)

def drive_straight_mm(mm):
    gyro.reset_angle(0)
    drive.reset()
    while drive.distance() < mm:
        error = gyro.angle()
        correction = -error * 2
        drive.drive(100, correction)
        wait(10)
    drive.stop(Stop.BRAKE)

def turn_right_90():
    gyro.reset_angle(0)
    drive.drive(0, -90)
    while abs(gyro.angle()) < 90:
        wait(10)
    drive.stop(Stop.BRAKE)

for i in range(4):
    drive_straight_mm(400)
    turn_right_90()

brick.speaker.beep()
brick.screen.print("This is my square")
wait(500)
</pre>
    </div>
    <div class="modal-actions">
      <button class="btn" id="copy-solution">Insert</button>
      <button class="btn" id="close-solution">Close</button>
    </div>
  </dialog>

  <script>
  // === grab DOM elements safely ===
  const editorEl   = document.getElementById("editor");
  const runBtn     = document.getElementById("run-btn");
  const resetBtn   = document.getElementById("reset-btn");
  const saveBtn    = document.getElementById("save-btn");
  const statusEl   = document.getElementById("status");
  const outputEl   = document.getElementById("output");
  const errorEl    = document.getElementById("error");
  const canvasEl   = document.getElementById("arena");

  const tipsBtn        = document.getElementById("tips-btn");
  const tipsModal      = document.getElementById("tips-modal");
  const closeTipsBtn   = document.getElementById("close-tips");

  const solutionBtn       = document.getElementById("solution-btn");
  const solutionModal     = document.getElementById("solution-modal");
  const closeSolutionBtn  = document.getElementById("close-solution");
  const copySolutionBtn   = document.getElementById("copy-solution");
  const solutionCodeEl    = document.getElementById("solution-code");

  // === helper: set status text/color ===
  function setStatus(cls, txt){
    if (!statusEl) return;
    statusEl.className = "status " + (cls || "");
    statusEl.textContent = txt || "";
  }

  // === modal helpers (defensive) ===
  function openDialog(d){
    if (!d) return;
    if (d.showModal) d.showModal();
    else d.setAttribute("open","");
  }
  function closeDialog(d){
    if (!d) return;
    if (d.close) d.close();
    else d.removeAttribute("open");
  }

  if (tipsBtn) tipsBtn.onclick = ()=>openDialog(tipsModal);
  if (closeTipsBtn) closeTipsBtn.onclick = ()=>closeDialog(tipsModal);

  if (solutionBtn) solutionBtn.onclick = ()=>openDialog(solutionModal);
  if (closeSolutionBtn) closeSolutionBtn.onclick = ()=>closeDialog(solutionModal);
  if (copySolutionBtn) copySolutionBtn.onclick = ()=>{
    if (editorEl && solutionCodeEl) {
      editorEl.value = solutionCodeEl.textContent;
    }
    closeDialog(solutionModal);
    setStatus("", "");
    if (outputEl) outputEl.textContent = "";
    if (errorEl)  errorEl.textContent  = "";
  };

  // === canvas setup (this was crashing before if canvasEl was null) ===
  const ctx = canvasEl ? canvasEl.getContext("2d") : null;
  const degToRad = d => d * Math.PI / 180;

  const WORLD = {
    robot: { x:80, y:200, heading:0, r:6 }
  };

  function drawWorld(){
    if (!ctx || !canvasEl) return;

    // clear bg
    ctx.fillStyle = "#fff";
    ctx.fillRect(0,0,canvasEl.width,canvasEl.height);

    // border
    ctx.strokeStyle = "#111";
    ctx.lineWidth = 2;
    ctx.strokeRect(0,0,canvasEl.width,canvasEl.height);

    // robot body
    const r = WORLD.robot;
    ctx.fillStyle = "#16a34a";
    ctx.beginPath();
    ctx.arc(r.x, r.y, r.r, 0, Math.PI*2);
    ctx.fill();

    // heading tick
    ctx.strokeStyle = "#16a34a";
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.moveTo(r.x, r.y);
    ctx.lineTo(
      r.x + Math.cos(degToRad(r.heading)) * (r.r+10),
      r.y + Math.sin(degToRad(r.heading)) * (r.r+10)
    );
    ctx.stroke();
  }

  function resetWorld(){
    WORLD.robot = { x:80, y:200, heading:0, r:6 };
    drawWorld();
  }

  async function moveStraightPx(px){
    // move forward px pixels in small steps
    for (let walked = 0; walked < px; walked += 1){
      const r = WORLD.robot;
      r.x += Math.cos(degToRad(r.heading));
      r.y += Math.sin(degToRad(r.heading));
      drawWorld();
      await new Promise(res => setTimeout(res, 10));
    }
  }

  async function turnRight90(){
    // rotate heading clockwise 90¬∞ in 5¬∞ steps
    for (let turned = 0; turned < 90; turned += 5){
      const r = WORLD.robot;
      r.heading = (r.heading + 5) % 360;
      drawWorld();
      await new Promise(res => setTimeout(res, 20));
    }
  }

  async function runSim(){
    // simulate square: forward ~400mm (‚âà40px), then right turn
    resetWorld();
    setStatus("running","running‚Ä¶");
    if (outputEl) outputEl.textContent = "";
    if (errorEl)  errorEl.textContent  = "";

    for (let side=0; side<4; side++){
      await moveStraightPx(40); // 40px ‚âà 400mm
      await turnRight90();
    }

    setStatus("ok","done.");
    if (outputEl){
      outputEl.textContent = 'Simulated: drove 4 sides, gyro-stable forward, 90¬∞ right turns, then "This is my square".';
    }
  }

  function saveFile(){
    if (!editorEl) return;
    const blob = new Blob([editorEl.value], { type:"text/plain" });
    const a = document.createElement("a");
    a.href = URL.createObjectURL(blob);
    a.download = "main.py";
    a.click();
    URL.revokeObjectURL(a.href);
  }

  function doReset(){
    resetWorld();
    setStatus("", "");
    if (outputEl) outputEl.textContent = "";
    if (errorEl)  errorEl.textContent  = "";
  }

  if (runBtn)   runBtn.onclick   = runSim;
  if (resetBtn) resetBtn.onclick = doReset;
  if (saveBtn)  saveBtn.onclick  = saveFile;

  // draw robot once on load
  resetWorld();
  </script>
</body>
</html>
