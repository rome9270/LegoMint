<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <title>Robot Template ‚Äì Arena + Bodies + Line Follower (Pyodide)</title>

  <!-- Deine gemeinsame CSS -->
  <link rel="stylesheet" href="../css/03_python.css" />

  <!-- Pyodide (echtes Python im Browser) -->
  <script src="https://cdn.jsdelivr.net/pyodide/v0.26.1/full/pyodide.js"></script>
</head>
<body>
  <div class="nav-row">
    <a href="01_main.html" class="btn" id="back-btn">‚Üê Back</a>
    <a href="#" class="btn primary" id="next-btn">Next ‚Üí</a>
  </div>

  <header class="row" style="justify-content: space-between;">
    <div>
      <h1>Robot Template ‚Äî 3√ó3 m Arena (Pyodide)</h1>
      <p id="task-desc">F√ºge K√∂rper ein: <code>add_rect()</code>, <code>add_circle()</code>. Linie zeichnen: <code>track_polyline()</code>. Bewegen: <code>robot.forward_m()</code>, <code>robot.left()</code>, <code>robot.right()</code>. Line-Follower: <code>robot.follow_line()</code>.</p>
    </div>
    <div class="row">
      <button class="btn" id="tips-btn">üí° Tips</button>
      <button class="btn" id="solution-btn">‚úÖ Solution</button>
    </div>
  </header>

  <main class="layout">
    <!-- Editor -->
    <section class="card">
      <h2>Editor</h2>
      <div class="row">
        <button class="btn primary" id="run-btn">‚ñ∂ Run</button>
        <button class="btn" id="reset-btn">‚ü≤ Reset</button>
        <button class="btn" id="save-btn">üíæ Save</button>
        <span id="status" class="status" aria-live="polite"></span>
      </div>
      <textarea id="editor" spellcheck="false" placeholder="# Schreibe Python hier‚Ä¶"></textarea>
    </section>

    <!-- Output + Canvas -->
    <section class="card">
      <h2>Output</h2>
      <pre id="output" aria-live="polite"></pre>
      <h3>Arena</h3>
      <canvas id="arena" width="540" height="540" aria-label="robot arena"
              style="border:2px solid #111; background:#fff; width:100%; max-width:540px; height:auto;"></canvas>
    </section>
  </main>

  <!-- Tips modal -->
  <dialog id="tips-modal">
    <div class="modal-header">Tips</div>
    <div class="modal-body">
      <ul>
        <li>1 m = 100 px, Arena ist 3√ó3 m, Ursprung (0,0) in der Mitte.</li>
        <li>K√∂rper: <code>add_rect(x,y,w,h,deg=0, color="#94a3b8")</code>, <code>add_circle(x,y,r,color="#94a3b8")</code> (x/y in Metern).</li>
        <li>Linie: <code>track_polyline([(x1,y1),(x2,y2),...], width_mm=40)</code> (Koordinaten in m).</li>
        <li>Line-Follower: <code>robot.follow_line(seconds=5, base_speed_mm_s=120, kp=2.0, sensor_mm=12)</code>.</li>
      </ul>
    </div>
    <div class="modal-actions">
      <button class="btn" id="close-tips">Close</button>
    </div>
  </dialog>

  <!-- Solution modal -->
  <dialog id="solution-modal">
    <div class="modal-header">Solution (Beispiel)</div>
    <div class="modal-body">
<pre id="solution-code" style="white-space:pre-wrap;"></pre>
    </div>
    <div class="modal-actions">
      <button class="btn" id="copy-solution">Insert</button>
      <button class="btn" id="close-solution">Close</button>
    </div>
  </dialog>

  <script>
    // ---------- Refs ----------
    let pyodide;
    const els = {
      editor: document.getElementById('editor'),
      run: document.getElementById('run-btn'),
      reset: document.getElementById('reset-btn'),
      save: document.getElementById('save-btn'),
      out: document.getElementById('output'),
      status: document.getElementById('status'),
      canvas: document.getElementById('arena'),
      tipsBtn: document.getElementById('tips-btn'),
      tipsDlg: document.getElementById('tips-modal'),
      closeTips: document.getElementById('close-tips'),
      solBtn: document.getElementById('solution-btn'),
      solDlg: document.getElementById('solution-modal'),
      solCode: document.getElementById('solution-code'),
      copySolution: document.getElementById('copy-solution'),
      closeSol: document.getElementById('close-solution'),
    };

    // ---------- Status ----------
    function setStatus(state, text){
      els.status.className = "status" + (state ? (" " + state) : "");
      els.status.textContent = text || "";
    }
    function printLine(s){ els.out.textContent += s + "\\n"; }

    // ---------- Canvas helpers exposed to Python ----------
    const ctx = els.canvas.getContext('2d');

    function samplePixel(x, y){
      // x/y in canvas px; returns "blackness" 0..1
      const d = ctx.getImageData(Math.round(x), Math.round(y), 1, 1).data;
      const r=d[0], g=d[1], b=d[2];
      const lum = 0.2126*r + 0.7152*g + 0.0722*b; // Rec.709 luma
      return 1 - (lum / 255); // 0=wei√ü, 1=schwarz
    }

    // ---------- Boot Pyodide and Python world ----------
    async function boot(){
      setStatus("running","loading Pyodide‚Ä¶");
      els.out.textContent = "";
      if (!pyodide) pyodide = await loadPyodide();
      pyodide.setStdout({batched: s => { if(s) els.out.textContent += s; }});
      pyodide.setStderr({batched: s => { if(s) els.out.textContent += s; }});
      pyodide.registerJsModule("uiconsole", { printLine });
      pyodide.registerJsModule("uicanvas", { ctx, samplePixel });

      // Python environment
      await pyodide.runPythonAsync(`
from uicanvas import ctx, samplePixel
from uiconsole import printLine
import math, time

W, H = ctx.canvas.width, ctx.canvas.height
SCALE = 100       # 1 m = 100 px
SIZE  = 3 * SCALE # 300 px Arena
ORIGIN = (W//2, H//2)

# --- drawing utils ---
def to_canvas(x, y):
    # world (m) center -> canvas (px, top-left)
    return ORIGIN[0] + x*SCALE, ORIGIN[1] - y*SCALE

def clear_canvas():
    ctx.fillStyle = "#ffffff"
    ctx.fillRect(0,0,W,H)
    # border
    ctx.strokeStyle = "#111"; ctx.lineWidth = 2
    left = ORIGIN[0]-SIZE//2; top = ORIGIN[1]-SIZE//2
    ctx.strokeRect(left, top, SIZE, SIZE)

# --- "engine" state ---
BODIES = []  # (type, params_dict)
TRACK  = []  # list of points [(x,y) in meters]
TRACK_W = 0  # width in px

def add_rect(x, y, w, h, deg=0, color="#94a3b8"):
    BODIES.append(("rect", dict(x=x, y=y, w=w, h=h, deg=deg, color=color)))
    render()

def add_circle(x, y, r, color="#94a3b8"):
    BODIES.append(("circle", dict(x=x, y=y, r=r, color=color)))
    render()

def track_polyline(points, width_mm=40, color="#000000"):
    global TRACK, TRACK_W, TRACK_COLOR
    TRACK = list(points)
    TRACK_W = max(1, int(width_mm/1000 * SCALE))
    TRACK_COLOR = color
    render()

def draw_bodies():
    for t, p in BODIES:
        if t == "rect":
            cx, cy = to_canvas(p["x"], p["y"])
            wpx, hpx = p["w"]*SCALE, p["h"]*SCALE
            ang = math.radians(p["deg"])
            ctx.save()
            ctx.translate(cx, cy)
            ctx.rotate(-ang)  # canvas y down; world y up
            ctx.fillStyle = p["color"]
            ctx.fillRect(-wpx/2, -hpx/2, wpx, hpx)
            ctx.restore()
        elif t == "circle":
            cx, cy = to_canvas(p["x"], p["y"])
            rpx = p["r"]*SCALE
            ctx.fillStyle = p["color"]
            ctx.beginPath(); ctx.arc(cx, cy, rpx, 0, 2*math.pi); ctx.fill()

def draw_track():
    if len(TRACK) < 2: return
    ctx.strokeStyle = TRACK_COLOR
    ctx.lineWidth = TRACK_W
    ctx.lineCap = "round"; ctx.lineJoin = "round"
    x0,y0 = to_canvas(*TRACK[0])
    ctx.beginPath(); ctx.moveTo(x0,y0)
    for x,y in TRACK[1:]:
        cx,cy = to_canvas(x,y)
        ctx.lineTo(cx,cy)
    ctx.stroke()

def is_inside_arena(x, y):
    half = (SIZE/2)/SCALE
    return (-half <= x <= half) and (-half <= y <= half)

# --- Robot with 2 line sensors ---
class Robot:
    def __init__(self):
        self.x = -1.3   # m
        self.y = -1.3   # m
        self.heading = 0.0  # deg, 0 = +x
        self.body_px = 10

    def render(self):
        clear_canvas()
        draw_track()
        draw_bodies()
        # draw robot
        cx, cy = to_canvas(self.x, self.y)
        ctx.fillStyle = "#16a34a"
        ctx.beginPath(); ctx.arc(cx, cy, self.body_px, 0, 2*math.pi); ctx.fill()
        # heading tick
        hx = cx + 14*math.cos(math.radians(self.heading))
        hy = cy - 14*math.sin(math.radians(self.heading))
        ctx.strokeStyle = "#16a34a"; ctx.lineWidth = 2
        ctx.beginPath(); ctx.moveTo(cx, cy); ctx.lineTo(hx, hy); ctx.stroke()

    def _try_move(self, nx, ny):
        if is_inside_arena(nx, ny):
            self.x, self.y = nx, ny

    def forward_m(self, m):
        rad = math.radians(self.heading)
        nx = self.x + m*math.cos(rad)
        ny = self.y + m*math.sin(rad)
        self._try_move(nx, ny)
        self.render()

    def forward_mm(self, mm):
        self.forward_m(mm/1000.0)

    def left(self, deg=90):
        self.heading = (self.heading + deg) % 360
        self.render()

    def right(self, deg=90):
        self.heading = (self.heading - deg) % 360
        self.render()

    # --- Line sensors ---
    def _sensor_px(self, offset_mm=12, ahead_mm=12):
        # zwei Sensoren: links/rechts je offset quer zur Fahrtrichtung, "ahead" vor dem Zentrum
        rad = math.radians(self.heading)
        # Quer-Vektor (links)
        lx = -math.sin(rad); ly = math.cos(rad)
        # Vorw√§rts-Vektor
        fx =  math.cos(rad); fy = math.sin(rad)
        # Offset/Ahead in Meter
        off = offset_mm/1000.0; ah = ahead_mm/1000.0
        # Positionen in Weltkoordinaten
        Lx = self.x + fx*ah + lx*off
        Ly = self.y + fy*ah + ly*off
        Rx = self.x + fx*ah - lx*off
        Ry = self.y + fy*ah - ly*off
        # nach Canvas-Pixel
        lcx,lcy = to_canvas(Lx, Ly)
        rcx,rcy = to_canvas(Rx, Ry)
        return (lcx,lcy), (rcx,rcy)

    def read_line_sensors(self, offset_mm=12, ahead_mm=12):
        (lcx,lcy), (rcx,rcy) = self._sensor_px(offset_mm, ahead_mm)
        # samplePixel kommt aus JS, gibt 0..1 (0=wei√ü, 1=schwarz)
        left = samplePixel(lcx, lcy)
        right = samplePixel(rcx, rcy)
        return left, right

    def follow_line(self, seconds=6.0, base_speed_mm_s=120, kp=2.0, sensor_mm=12, ahead_mm=12, dt=0.05):
        steps = int(seconds / dt)
        for _ in range(steps):
            L, R = self.read_line_sensors(offset_mm=sensor_mm, ahead_mm=ahead_mm)
            error = (L - R)  # pos -> zu viel links (schw√§rzer), neg -> rechts
            turn = kp * error  # deg/s proportional
            # Update heading
            self.heading = (self.heading + turn*dt) % 360
            # Vorw√§rts
            self.forward_m((base_speed_mm_s/1000.0) * dt)
        self.render()

# global robot
robot = Robot()
clear_canvas(); draw_track(); draw_bodies(); robot.render()
printLine("Arena bereit. Verf√ºgbar: add_rect, add_circle, track_polyline, robot.*")
      `);

      // Beispiel-L√∂sung (Starter)
      els.solCode.textContent =
`# --- Beispiel: Bodies + Linie + Line-Follower ---
# 1) K√∂rper
add_rect(x=0.0, y=0.0, w=0.6, h=0.2, deg=0,  color="#a3e635")  # gr√ºner Block
add_circle(x=0.8, y=0.6, r=0.12,            color="#f59e0b")   # oranger Kreis

# 2) Linie (Poly-Line in Metern, Breite 40 mm)
track_polyline([(-1.2,-1.2), (-0.8,-0.8), (-0.2,-0.8), (0.4,-0.2),
                (0.8,0.4), (0.6,0.9), (0.0,1.2)], width_mm=40)

# 3) Roboter an Start und folgen lassen
robot.x, robot.y, robot.heading = -1.3, -1.3, 0
robot.render()
robot.follow_line(seconds=7, base_speed_mm_s=140, kp=2.4, sensor_mm=12, ahead_mm=12, dt=0.05)
`;

      setStatus("ok","ready");
    }

    // ---------- Run / Reset / Save ----------
    async function runCode(){
      if(!pyodide) return;
      els.out.textContent = "";
      setStatus("running","running‚Ä¶");
      try{
        await pyodide.runPythonAsync(els.editor.value);
        setStatus("ok","done.");
      }catch(e){
        els.out.textContent += String(e) + "\\n";
        setStatus("error","error");
      }
    }
    async function resetAll(){
      setStatus("running","reset‚Ä¶");
      await boot();
      setStatus("ok","ready");
    }
    function saveCode(){
      const b = new Blob([els.editor.value], {type:"text/plain"});
      const a = document.createElement("a");
      a.href = URL.createObjectURL(b);
      a.download = "robot_program.py";
      a.click();
      URL.revokeObjectURL(a.href);
    }

    // ---------- Dialog Handling (mit Fallback) ----------
    function openDialog(dlg){
      if (dlg && typeof dlg.showModal === "function") dlg.showModal();
      else if (dlg){ dlg.setAttribute("open",""); document.documentElement.style.overflow="hidden"; }
    }
    function closeDialog(dlg){
      if (dlg && typeof dlg.close === "function") dlg.close();
      else if (dlg){ dlg.removeAttribute("open"); document.documentElement.style.overflow=""; }
    }

    // ---------- Bindings ----------
    els.run.onclick = runCode;
    els.reset.onclick = resetAll;
    els.save.onclick = saveCode;

    els.tipsBtn.onclick = ()=> openDialog(els.tipsDlg);
    els.closeTips.onclick = ()=> closeDialog(els.tipsDlg);

    els.solBtn.onclick = ()=> { openDialog(els.solDlg); };
    els.closeSol.onclick = ()=> closeDialog(els.solDlg);
    els.copySolution.onclick = ()=>{
      els.editor.value = els.solCode.textContent;
      closeDialog(els.solDlg);
      els.out.textContent = "";
      setStatus("", "");
    };

    // ---------- Boot once & preload solution into modal ----------
    (async () => {
      await boot();
      // optional: Starter in den Editor legen
      els.editor.value = els.solCode.textContent;
    })();
  </script>
</body>
</html>
