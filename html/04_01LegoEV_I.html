<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>EV3 (Pybricks) ‚Äì Warehouse Mission (Seek ‚Üí 3 Stops ‚Üí End)</title>

  <link rel="stylesheet" href="../css/03_python.css" />
  <style>
    #arena {
      background:#f9fafb;
      border:2px solid #111;
      width:100%;
      height:auto;
      max-width:900px;
      border-radius:10px;
      display:block;
      margin-top:10px;
    }

    .status.ok      { color:#15803d; }
    .status.error   { color:#b91c1c; }
    .status.running { color:#374151; }
    .muted { color:#6b7280; }
    #error { color:#b91c1c; white-space:pre-wrap; }

    .tipbox {
      background:#f0fdf4;
      border:1px solid #86efac;
      border-radius:8px;
      padding:10px 12px;
      margin-top:8px;
      font-size:0.9rem;
      color:#166534;
    }
  </style>
</head>
<body>
  <!-- NAV -->
  <nav class="link-grid" aria-label="Topic selection">
    <a class="btn" href="../app/01_main.php" id="go-main">‚¨ÖÔ∏è Main</a>
    <a class="btn" href="../app/logout.php">üö™ Logout</a>
    <a class="btn primary" id="next-btn" href="03_11LegoEV3_I.html">Next ‚Üí</a>
  </nav>

  <header class="row" style="justify-content: space-between;">
    <div>
      <h1>EV3 (Pybricks) ¬∑ Warehouse Mission</h1>

      <p>The robot should:</p>
      <ol>
        <li>Start <b>off the black line</b> (ColorSensor on <b>Port S1</b> is not on the line yet).</li>
        <li><b>Seek the line</b>: move until it finds the black line.</li>
        <li>Follow the line forward. At each <b>beige marker</b>: stop and say
          <code>"please load the vehicle"</code>.</li>
        <li>Do this 3 times (3 loading stations).</li>
        <li>Then continue following the line to the end.</li>
        <li>At the end say:
          <code>"please unload the car"</code>,
          then
          <code>"job done, ready for the next one"</code>.</li>
      </ol>

      <p class="muted">
        ‚Ä¢ Click <b>‚úÖ Solution ‚Üí Insert</b> to load example code into the editor.<br>
        ‚Ä¢ Press <b>‚ñ∂ Run</b> to watch the simulation.<br>
        ‚Ä¢ This version uses the calm drive logic from the good task (slow, stable).
      </p>
    </div>

    <div class="row">
      <button class="btn" id="tips-btn">üí° Tips</button>
      <button class="btn" id="solution-btn">‚úÖ Solution</button>
    </div>
  </header>

  <main class="layout">
    <!-- EDITOR -->
    <section class="card">
      <h2>Editor</h2>
      <div class="row">
        <button class="btn primary" id="run-btn">‚ñ∂ Run</button>
        <button class="btn" id="reset-btn">‚ü≤ Reset</button>
        <button class="btn" id="save-btn">üíæ Save</button>
        <span id="status" class="status" aria-live="polite"></span>
      </div>

<textarea id="editor" spellcheck="false">#!/usr/bin/env pybricks-micropython
# EV3 (Pybricks) ‚Äì Warehouse Mission
# GOAL:
# 1. Robot starts OFF the line.
# 2. SEEK the black line using ColorSensor (Port S1).
# 3. Follow the line.
# 4. At each beige marker: stop + say "please load the vehicle" (3 times).
# 5. After 3rd stop: continue to the end.
# 6. At the end: "please unload the car" / "job done, ready for the next one".

from pybricks.hubs import EV3Brick
from pybricks.ev3devices import Motor, ColorSensor
from pybricks.parameters import Port, Stop
from pybricks.tools import wait
from pybricks.robotics import DriveBase

brick = EV3Brick()
left  = Motor(Port.A)
right = Motor(Port.B)
color = ColorSensor(Port.S1)
drive = DriveBase(left, right, 56, 114)

brick.speaker.beep()
brick.screen.print("Warehouse ready")
wait(500)

# Student steps:
# - SEEK: Move until sensor sees dark (low reflection).
# - FOLLOW: Use (target - reflection) * KP as steering.
# - STOP AT STATIONS: 3x "please load the vehicle".
# - END: "please unload the car" then "job done, ready for the next one".
</textarea>
    </section>

    <!-- SIMULATION -->
    <section class="card">
      <h2>Simulation</h2>

      <canvas id="arena" width="600" height="300"></canvas>

      <p class="muted">
        Robot (green) starts below the black line, first seeks it,
        then follows the line. At each beige station it pauses.
        After station 3 it continues to the end and unloads.
      </p>

      <div class="tipbox">
        <strong>üí° Sensor tip:</strong><br>
        ‚Ä¢ Black line = low reflection (~10-20).<br>
        ‚Ä¢ Beige station = much brighter (~70+).<br>
        ‚Ä¢ After 3rd station: continue until the end of the route, then unload.
      </div>

      <pre id="output"></pre>
      <div id="error"></div>
    </section>
  </main>

  <!-- TIPS MODAL -->
  <dialog id="tips-modal">
    <div class="modal-header">Tips</div>
    <div class="modal-body">
      <ul>
        <li><code>ColorSensor(Port.S1).reflection()</code> returns 0..100.</li>
        <li>"Seek line": move until reflection is very low (black line).</li>
        <li>"Follow line": drive forward with steering = error * KP.</li>
        <li>At beige marker: stop + "please load the vehicle".</li>
        <li>After 3rd stop: go to the end and say unload messages.</li>
      </ul>
    </div>
    <div class="modal-actions">
      <button class="btn" id="close-tips">Close</button>
    </div>
  </dialog>

  <!-- SOLUTION MODAL -->
  <dialog id="solution-modal">
    <div class="modal-header">Solution (Warehouse Mission)</div>
    <div class="modal-body">
<pre id="solution-code" style="white-space:pre-wrap;">#!/usr/bin/env pybricks-micropython
from pybricks.hubs import EV3Brick
from pybricks.ev3devices import Motor, ColorSensor
from pybricks.parameters import Port, Stop
from pybricks.tools import wait
from pybricks.robotics import DriveBase

brick = EV3Brick()
left  = Motor(Port.A)
right = Motor(Port.B)
color = ColorSensor(Port.S1)
drive = DriveBase(left, right, 56, 114)

# --- tunable constants ---
DARK_TARGET      = 20    # about the black line brightness
KP               = 1.0   # steering gain
SPEED_FWD        = 40    # mm/s forward during follow
BEIGE_LIMIT      = 70    # reflection() > this means beige station
STOP_COUNT_GOAL  = 3     # how many "please load" stops
FINAL_ROLL_MS    = 3000  # after last stop, keep rolling to end (ms)

# === SEEK PHASE ===
# Move slowly until we detect dark (on the black line)
while color.reflection() > DARK_TARGET + 5:
    drive.drive(30, 0)      # creep forward gently
    wait(20)
drive.stop(Stop.BRAKE)

# === FOLLOW + STOPS PHASE ===
stops = 0
while stops < STOP_COUNT_GOAL:
    # line following (basic P-control)
    ref   = color.reflection()
    error = DARK_TARGET - ref
    steer = error * KP
    drive.drive(SPEED_FWD, steer)

    # station check
    if color.reflection() > BEIGE_LIMIT:
        drive.stop(Stop.BRAKE)
        brick.speaker.say("please load the vehicle")
        wait(2000)

        stops += 1

        # pull forward a tiny bit to clear station
        drive.drive(SPEED_FWD, 0)
        wait(800)
        drive.stop(Stop.BRAKE)

    wait(20)

# === FINAL RUN PHASE ===
# after last station, keep going forward to final drop zone
drive.drive(SPEED_FWD, 0)
wait(FINAL_ROLL_MS)
drive.stop(Stop.BRAKE)

# === UNLOAD PHASE ===
brick.speaker.say("please unload the car")
wait(1000)
brick.speaker.say("job done, ready for the next one")
brick.speaker.beep()
brick.screen.print("done")
wait(1000)
</pre>
    </div>
    <div class="modal-actions">
      <button class="btn" id="copy-solution">Insert</button>
      <button class="btn" id="close-solution">Close</button>
    </div>
  </dialog>

  <script>
  // ===== DOM ELEMENTS =====
  const runBtn        = document.getElementById("run-btn");
  const resetBtn      = document.getElementById("reset-btn");
  const saveBtn       = document.getElementById("save-btn");
  const editorEl      = document.getElementById("editor");
  const statusEl      = document.getElementById("status");
  const outputEl      = document.getElementById("output");
  const errorEl       = document.getElementById("error");

  const canvasEl      = document.getElementById("arena");

  const tipsBtn       = document.getElementById("tips-btn");
  const tipsModal     = document.getElementById("tips-modal");
  const closeTips     = document.getElementById("close-tips");

  const solutionBtn   = document.getElementById("solution-btn");
  const solutionModal = document.getElementById("solution-modal");
  const copySolution  = document.getElementById("copy-solution");
  const closeSolution = document.getElementById("close-solution");

  function setStatus(cls, txt){
    statusEl.className = "status " + cls;
    statusEl.textContent = txt;
  }

  // ===== SIM SETTINGS =====
  // World geometry
  const LINE_Y        = 200;     // y-position of the black transport line
  const START_X       = 80;      // robot start x (off the line)
  const START_Y       = 235;     // robot start y (below the line)
  const START_HEADING = 0;       // initial heading for display, will change on seek

  // Beige "stations" (x positions along the line)
  const STATION_XS    = [200, 350, 500];

  // End point of mission (where unload happens)
  const LINE_END_X    = 560;

  // Motion tuning
  const SEEK_SPEED_PX        = 1.0;   // seek speed (vertical)
  const FOLLOW_SPEED_PX      = 0.6;   // forward speed during follow
  const KP_FOLLOW            = 0.06;  // steering strength toward the line
  const ROTATE_MAX_PER_FRAME = 2;     // deg/frame (smooth turn)
  const STOP_WAIT_FRAMES     = 60;    // how long to "load vehicle" at station
  const FINAL_ROLL_FRAMES    = 180;   // rollout frames after last station to reach the end

  let running = false;
  let simulationReady = false;

  // ===== WORLD STATE / RENDERING =====
  const ctx = canvasEl.getContext("2d");
  const deg2rad = d => d * Math.PI/180;

  const WORLD = {
    robot: { x: START_X, y: START_Y, heading: START_HEADING, r: 6 }
  };

  function drawWorld(label){
    // clear bg + border
    ctx.fillStyle="#fff";
    ctx.fillRect(0,0,canvasEl.width,canvasEl.height);

    ctx.strokeStyle="#111";
    ctx.lineWidth=2;
    ctx.strokeRect(0,0,canvasEl.width,canvasEl.height);

    // draw black main line (not extended beyond canvas)
    ctx.strokeStyle="#000";
    ctx.lineWidth=4;
    ctx.beginPath();
    ctx.moveTo(0, LINE_Y);
    ctx.lineTo(canvasEl.width, LINE_Y);
    ctx.stroke();

    // draw beige loading stations
    STATION_XS.forEach(xPos => {
      ctx.strokeStyle="#e7e3c2";
      ctx.lineWidth=8;
      ctx.beginPath();
      ctx.moveTo(xPos, LINE_Y-20);
      ctx.lineTo(xPos, LINE_Y+20);
      ctx.stroke();
    });

    // draw robot as green circle + heading arrow
    const r = WORLD.robot;
    ctx.fillStyle="#16a34a";
    ctx.beginPath();
    ctx.arc(r.x, r.y, r.r, 0, Math.PI*2);
    ctx.fill();

    ctx.strokeStyle="#16a34a";
    ctx.lineWidth=2;
    ctx.beginPath();
    ctx.moveTo(r.x, r.y);
    ctx.lineTo(
      r.x + Math.cos(deg2rad(r.heading))*15,
      r.y + Math.sin(deg2rad(r.heading))*15
    );
    ctx.stroke();

    if (label){
      ctx.fillStyle="#374151";
      ctx.font="12px sans-serif";
      ctx.fillText(label, 10, 20);
    }
  }

  function resetWorld(){
    WORLD.robot.x = START_X;
    WORLD.robot.y = START_Y;
    WORLD.robot.heading = START_HEADING;
    drawWorld("ready (off the line)");
  }

  function stepForward(px){
    WORLD.robot.x += Math.cos(deg2rad(WORLD.robot.heading)) * px;
    WORLD.robot.y += Math.sin(deg2rad(WORLD.robot.heading)) * px;
  }

  function turnToward(targetDeg, maxStepDeg){
    let cur = WORLD.robot.heading;
    let diff = ((targetDeg - cur + 540) % 360) - 180;
    const step = Math.sign(diff) * Math.min(Math.abs(diff), maxStepDeg);
    WORLD.robot.heading = (cur + step + 360) % 360;
  }

  // === SEEK PHASE ===
  // Move straight "up" until we reach the black line height.
  function simSeekLine(){
    return new Promise(resolve=>{
      const needUp = WORLD.robot.y > LINE_Y;
      WORLD.robot.heading = needUp ? 270 : 90; // 270¬∞ = up, 90¬∞ = down

      function tick(){
        if (!running) return resolve();

        stepForward(SEEK_SPEED_PX); // go vertically toward line
        drawWorld("seeking line‚Ä¶");

        const closeEnough = Math.abs(WORLD.robot.y - LINE_Y) <= 1;
        const crossed = needUp
          ? (WORLD.robot.y <= LINE_Y)
          : (WORLD.robot.y >= LINE_Y);

        if (closeEnough || crossed){
          WORLD.robot.y = LINE_Y;
          WORLD.robot.heading = 0; // face right once on the line
          drawWorld("line found");
          return resolve();
        }

        requestAnimationFrame(tick);
      }

      requestAnimationFrame(tick);
    });
  }

  // === FOLLOW PHASE (with station stops) ===
  // gentleFollowStep = slow forward, keep y on LINE_Y using KP_FOLLOW.
  function gentleFollowStep(){
    const desiredHeading = 0;                 // aim to face right
    const errorY = LINE_Y - WORLD.robot.y;    // how far off the line vertically
    const correction = errorY * KP_FOLLOW;    // proportional correction
    const targetHeading = desiredHeading + correction * 180;
    turnToward(targetHeading, ROTATE_MAX_PER_FRAME);
    stepForward(FOLLOW_SPEED_PX);
  }

  // follow until all stations visited
  function simFollowWithStops(){
    return new Promise(resolve=>{
      let stopIndex = 0;
      let phase = "drive";
      let waitFrames = 0;

      function tick(){
        if (!running) return resolve();

        // done with all stations? resolve
        if (stopIndex >= STATION_XS.length){
          return resolve();
        }

        if (phase === "drive"){
          gentleFollowStep();
          drawWorld(`Going to station ${stopIndex+1}`);

          // reached the x-position of this station?
          if (WORLD.robot.x >= STATION_XS[stopIndex]){
            phase = "wait";
            waitFrames = 0;
          }

          requestAnimationFrame(tick);
          return;
        }

        if (phase === "wait"){
          // "please load the vehicle"
          drawWorld(`Station ${stopIndex+1}: "please load the vehicle"`);
          waitFrames++;

          if (waitFrames >= STOP_WAIT_FRAMES){
            // done waiting at this station
            stopIndex++;
            phase = "drive";
          }

          requestAnimationFrame(tick);
          return;
        }
      }

      requestAnimationFrame(tick);
    });
  }

  // === FINAL RUN PHASE ===
  // After last station: continue forward smoothly to end,
  // unload / ready.
  function simContinueToEndAndUnload(){
    return new Promise(resolve=>{
      let frameCount = 0;
      function tick(){
        if (!running) return resolve();

        gentleFollowStep();
        drawWorld("Continuing to end...");

        // either we actually reached the visual end
        if (WORLD.robot.x >= LINE_END_X){
          WORLD.robot.x = LINE_END_X;
          WORLD.robot.heading = 0;
          drawWorld('End: "please unload the car" / "job done, ready for the next one"');
          return resolve();
        }

        // or we timed out rolling to the end anyway
        frameCount++;
        if (frameCount >= FINAL_ROLL_FRAMES){
          WORLD.robot.heading = 0;
          drawWorld('End: "please unload the car" / "job done, ready for the next one"');
          return resolve();
        }

        requestAnimationFrame(tick);
      }
      requestAnimationFrame(tick);
    });
  }

  // ===== RUN BUTTON HANDLER =====
  async function runMission(){
    if (!simulationReady){
      setStatus("error","ERROR");
      errorEl.textContent = "‚ö†Ô∏è Click 'Solution ‚Üí Insert' first!";
      return;
    }
    if (running) return;

    running = true;
    setStatus("running","running‚Ä¶");
    outputEl.textContent = "";
    errorEl.textContent  = "";

    resetWorld();

    // 1) SEEK the line first
    await simSeekLine();

    // 2) FOLLOW and stop at 3 beige stations
    await simFollowWithStops();

    // 3) CONTINUE to end (unload)
    await simContinueToEndAndUnload();

    running = false;
    setStatus("ok","done.");
    outputEl.textContent =
      'Simulation: seek line ‚Üí 3√ó "please load the vehicle" ‚Üí end ‚Üí "please unload the car" / "job done, ready for the next one".';
  }

  // ===== BUTTONS =====
  runBtn.onclick = runMission;

  resetBtn.onclick = ()=>{
    running = false;
    setStatus("","");
    outputEl.textContent="";
    errorEl.textContent="";
    resetWorld();
  };

  saveBtn.onclick = ()=>{
    const blob = new Blob([editorEl.value], {type:"text/plain"});
    const a = document.createElement("a");
    a.href = URL.createObjectURL(blob);
    a.download="main.py";
    a.click();
    URL.revokeObjectURL(a.href);
  };

  // tips modal
  tipsBtn.onclick = ()=>{
    if (tipsModal.showModal) tipsModal.showModal();
    else tipsModal.setAttribute("open","");
  };
  closeTips.onclick = ()=>{
    if (tipsModal.close) tipsModal.close();
    else tipsModal.removeAttribute("open","");
  };

  // solution modal
  solutionBtn.onclick = ()=>{
    if (solutionModal.showModal) solutionModal.showModal();
    else solutionModal.setAttribute("open","");
  };
  closeSolution.onclick = ()=>{
    if (solutionModal.close) solutionModal.close();
    else solutionModal.removeAttribute("open","");
  };

  // copy solution into editor (unlocks Run)
  copySolution.onclick = ()=>{
    editorEl.value = document.getElementById("solution-code").textContent;
    simulationReady = true;

    if (solutionModal.close) solutionModal.close();
    else solutionModal.removeAttribute("open","");

    setStatus("ok","Ready to run");
    outputEl.textContent = "Solution code inserted. Press ‚ñ∂ Run.";
    errorEl.textContent  = "";
    resetWorld();
  };

  // init
  resetWorld();
  setStatus("","");
  </script>
</body>
</html>
